<!DOCTYPE html>
<html>
<head>
    <script src="https://unpkg.com/peerjs@1.5.4/dist/peerjs.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/crypto-js/4.1.1/crypto-js.min.js"></script>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Ëø∑ÂÆ´ÂÜíÈô© - 1.8.3</title>
    <link rel="icon" href="favicon.ico" type="image/x-icon">
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            margin: 0;
            padding: 0;
            background: linear-gradient(135deg, #1a1a2e, #16213e);
            color: white;
            overflow: hidden;
        }
        
        /* ‰∏ªËèúÂçïÊ†∑Âºè */
        .main-menu {
            text-align: center;
            margin-top: 100px;
            
        }
        
        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(20px); }
            to { opacity: 1; transform: translateY(0); }
        }
        
        .menu-title {
            font-size: 60px;
            margin-bottom: 40px;
            color: #4CAF50;
            text-shadow: 0 0 15px rgba(76, 175, 80, 0.6);
            letter-spacing: 3px;
            background: linear-gradient(to right, #4CAF50, #8BC34A);
            background-clip: text;
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
        }
        
        .menu-button {
            display: block;
            width: 250px;
            margin: 25px auto;
            padding: 18px;
            font-size: 22px;
            background: linear-gradient(135deg, #4CAF50, #2E7D32);
            color: white;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 5px 15px rgba(0,0,0,0.3);
        }
        
        .menu-button:hover {
            transform: translateY(-3px);
            box-shadow: 0 8px 20px rgba(0,0,0,0.4);
            background: linear-gradient(135deg, #66BB6A, #388E3C);
        }
        
        /* ÂÖ≥Âç°ÈÄâÊã©Ê†∑Âºè */
        .level-select {
            text-align: center;
            margin-top: 20px;
            animation: slideIn 0.8s ease-out;
            position: relative;
            padding-top: 80px;
        }
        
        @keyframes slideIn {
            from { opacity: 0; transform: translateX(-50px); }
            to { opacity: 1; transform: translateX(0); }
        }
        
.level-container {
    display: flex;
    flex-wrap: wrap;
    justify-content: center;
    max-width: 700px;
    margin: 30px auto;
    margin-top: 60px;
    max-height: calc(100vh - 200px);
    overflow-y: auto;
    padding: 20px;
    box-sizing: border-box;
    -webkit-overflow-scrolling: touch; /* iOSÊªëÂä®ÊµÅÁïÖ */
    touch-action: pan-y; /* ‰ºòÂåñËß¶ÊéßË°å‰∏∫ */
    overscroll-behavior: contain; /* Èò≤Ê≠¢ÊªöÂä®‰º†Êí≠Âà∞Â§ñÂ±Ç */
}
        
        .level-container::-webkit-scrollbar-track {
            background: rgba(255, 255, 255, 0.1);
            border-radius: 4px;
        }
        
        .level-container::-webkit-scrollbar-thumb {
            background: rgba(76, 175, 80, 0.5);
            border-radius: 4px;
        }
        
        .level-container::-webkit-scrollbar-thumb:hover {
            background: rgba(76, 175, 80, 0.8);
        }
        
        .level-button {
            width: 60px;
            height: 60px;
            margin: 12px;
            font-size: 20px;
            font-weight: bold;
            background: linear-gradient(135deg, #4CAF50, #2E7D32);
            color: white;
            border: none;
            border-radius: 50%;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 4px 10px rgba(0,0,0,0.3);
        }
        
        .level-button:hover {
            transform: scale(1.1);
            box-shadow: 0 6px 15px rgba(0,0,0,0.4);
        }
        
        .level-button.locked {
            background: linear-gradient(135deg, #555, #333);
            cursor: not-allowed;
        }
        
        .level-button.completed {
            background: linear-gradient(135deg, #FFC107, #FF9800);
        }

        .level-button.unsolvable {
            background: linear-gradient(135deg, #f44336, #d32f2f);
            position: relative;
            overflow: hidden;
        }
        
        .level-button.unsolvable::after {
            content: "?";
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 24px;
            color: rgba(255,255,255,0.7);
        }
        
        /* Ê∏∏ÊàèÁîªÂ∏ÉÊ†∑Âºè */
        #gameCanvas {
            display: block;
            margin: 20px auto;
            background-color: #111;
            border-radius: 10px;
            box-shadow: 0 0 30px rgba(0,0,0,0.7);
        }
        
        /* Ê∏∏Êàè‰ø°ÊÅØÊ†∑Âºè */
        .game-info {
            position: absolute;
            top: 20px;
            left: 20px;
            background: rgba(0, 0, 0, 0.6);
            padding: 10px 15px;
            border-radius: 8px;
            font-family: monospace;
            z-index: 10;
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            max-width: 300px;
            transition: all 0.3s ease;
        }
        
        .game-info-item {
            display: flex;
            align-items: center;
            padding: 5px;
            background: rgba(76, 175, 80, 0.2);
            border-radius: 4px;
            min-width: 80px;
        }
        
        /* ÈÄöÂÖ≥ÊèêÁ§∫Ê†∑Âºè */
        .level-complete {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.85);
            padding: 40px;
            border-radius: 15px;
            text-align: center;
            z-index: 100;
            width: 400px;
            box-shadow: 0 0 40px rgba(76, 175, 80, 0.5);
            border: 2px solid #4CAF50;
            animation: popIn 0.5s ease-out;
        }
        
        @keyframes popIn {
            0% { transform: translate(-50%, -50%) scale(0.8); opacity: 0; }
            100% { transform: translate(-50%, -50%) scale(1); opacity: 1; }
        }
        
        .level-complete h2 {
            font-size: 36px;
            margin-bottom: 25px;
            color: #4CAF50;
        }
        
        .level-complete p {
            font-size: 22px;
            margin-bottom: 30px;
            font-family: monospace;
        }
        
        .level-complete button {
            margin: 0 10px;
            padding: 12px 25px;
            font-size: 18px;
            background: linear-gradient(135deg, #4CAF50, #2E7D32);
            color: white;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.3s ease;
        }
        
        .level-complete button:hover {
            transform: translateY(-3px);
            box-shadow: 0 5px 15px rgba(0,0,0,0.3);
        }
        
        /* ËøîÂõûÊåâÈíÆÊ†∑Âºè */
        .back-button {
            position: absolute;
            top: 15px;
            left: 15px;
            padding: 8px 16px;
            font-size: 16px;
            background: linear-gradient(135deg, #f44336, #d32f2f);
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 3px 8px rgba(0,0,0,0.3);
            z-index: 20;
        }
        
        .back-button:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 12px rgba(0,0,0,0.4);
        }
        
        /* Â§ö‰∫∫Ê∏∏ÊàèËÆæÁΩÆÊ†∑Âºè */
        .multiplayer-setup {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.85);
            padding: 40px;
            border-radius: 15px;
            text-align: center;
            width: 400px;
            box-shadow: 0 0 30px rgba(76, 175, 80, 0.5);
            border: 2px solid #4CAF50;
        }
        
        .multiplayer-setup h2 {
            font-size: 32px;
            margin-bottom: 30px;
            color: #4CAF50;
        }
        
        .setup-input {
            margin: 15px 0;
            padding: 12px 15px;
            width: 100%;
            font-size: 16px;
            background: rgba(255, 255, 255, 0.1);
            color: white;
            border: 1px solid #4CAF50;
            border-radius: 5px;
            outline: none;
        }
        
        .setup-input:focus {
            border-color: #8BC34A;
            box-shadow: 0 0 10px rgba(139, 195, 74, 0.5);
        }
        
        /* Â§ö‰∫∫Ê∏∏ÊàèÁïåÈù¢Ê†∑Âºè */
        .player-list {
            position: absolute;
            top: 80px;
            right: 20px;
            background: rgba(0, 0, 0, 0.6);
            padding: 15px;
            border-radius: 10px;
            min-width: 180px;
            backdrop-filter: blur(5px);
            font-family: monospace;
            z-index: 10;
        }
        
        .player-list h3 {
            margin-top: 0;
            margin-bottom: 15px;
            color: #4CAF50;
            text-align: center;
            border-bottom: 1px solid #4CAF50;
            padding-bottom: 10px;
        }
        
        .player-item {
            margin: 10px 0;
            display: flex;
            align-items: center;
            justify-content: space-between;
        }
        
        .player-color {
            display: inline-block;
            width: 15px;
            height: 15px;
            border-radius: 50%;
            margin-right: 10px;
        }
        
        .connection-status {
            background-color: rgba(244, 252, 2, 0.8);
            position: absolute;
            bottom: 15px;
            right: 15px;
            padding: 8px 15px;
            border-radius: 5px;
            font-size: 14px;
            font-family: monospace;
            z-index: 10;
        }
        
        .connected {
            background-color: rgb(0, 255, 0);
        }
        
        .disconnected {
            background: rgba(244, 67, 54, 0.8);
        }
        
        /* ÈöêËóèÁ±ª */
        .hidden {
            display: none !important;
        }
        
        /* Ê∏∏ÊàèËØ¥ÊòéÂºπÁ™ó */
        .instructions-modal {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.9);
            padding: 30px;
            border-radius: 15px;
            width: 80%;
            max-width: 600px;
            z-index: 1000;
            box-shadow: 0 0 40px rgba(76, 175, 80, 0.7);
            border: 2px solid #4CAF50;
        }
        
        .instructions-modal h2 {
            color: #4CAF50;
            text-align: center;
            margin-top: 0;
        }
        
        .instructions-modal p {
            line-height: 1.6;
            margin-bottom: 20px;
            font-family: monospace;
        }
        
        .instructions-modal ul {
            text-align: left;
            padding-left: 20px;
        }
        
        .instructions-modal li {
            margin-bottom: 10px;
            line-height: 1.4;
        }
        
        .instructions-modal button {
            display: block;
            margin: 20px auto 0;
            padding: 10px 25px;
            background: linear-gradient(135deg, #4CAF50, #2E7D32);
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-size: 16px;
        }

        /* ÊñπÂêëÈîÆÊéßÂà∂Èù¢Êùø */
        .controls-panel {
            position: fixed;
            background: rgba(0, 0, 0, 0.6);
            padding: 15px;
            border-radius: 10px;
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            grid-template-rows: repeat(3, 1fr);
            gap: 5px;
            z-index: 10;
            transition: all 0.3s ease;
            backdrop-filter: blur(5px);
            width: 150px;
            height: 150px;
            box-sizing: border-box;
        }

        .control-button {
            width: 100%;
            height: 100%;
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid #4CAF50;
            border-radius: 5px;
            color: white;
            font-size: 20px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all 0.2s;
        }

        .control-button:hover {
            background: rgba(76, 175, 80, 0.3);
            transform: scale(1.05);
        }

        .control-button:active {
            background: rgba(76, 175, 80, 0.5);
            transform: scale(0.95);
        }

        .control-up {
            grid-column: 2;
            grid-row: 1;
        }

        .control-left {
            grid-column: 1;
            grid-row: 2;
        }

        .control-right {
            grid-column: 3;
            grid-row: 2;
        }

        .control-down {
            grid-column: 2;
            grid-row: 3;
        }
        
        /* ÂÖ≥Âç°ÂÜÖÊéßÂà∂ÊåâÈíÆ */
        .level-controls {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 20px;
            z-index: 10;
        }
        
        .level-control-button {
            padding: 10px 20px;
            font-size: 16px;
            background: linear-gradient(135deg, #2196F3, #0D47A1);
            color: white;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 3px 8px rgba(0,0,0,0.3);
        }
        
        .level-control-button.reset {
            background: linear-gradient(135deg, #FF9800, #F57C00);
        }
        
        .level-control-button.exit {
            background: linear-gradient(135deg, #f44336, #d32f2f);
        }
        
        .level-control-button:hover {
            transform: translateY(-3px);
            box-shadow: 0 5px 15px rgba(0,0,0,0.4);
        }
        
        /* ÂÖ≥Âç°ÈÄâÊã©Ê†áÈ¢òÊ†∑Âºè */
        .level-select-title {
            position: absolute;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            font-size: 36px;
            color: #4CAF50;
            text-shadow: 0 0 10px rgba(76, 175, 80, 0.5);
            z-index: 10;
            width: 100%;
            text-align: center;
        }
        
        /* ËøΩÈÄêËÄÖÊ†∑Âºè */
        .enemy-info {
            position: absolute;
            top: 60px;
            left: 50%;
            transform: translateX(-50%);
            color: white;
            background: rgba(0, 0, 0, 0.6);
            padding: 8px 15px;
            border-radius: 8px;
            font-size: 16px;
            backdrop-filter: blur(5px);
            font-family: monospace;
            z-index: 10;
            white-space: nowrap;
            animation: pulse 2s infinite;
        }
        
        @keyframes pulse {
            0% { box-shadow: 0 0 5px rgba(244, 67, 54, 0.5); }
            50% { box-shadow: 0 0 20px rgba(244, 67, 54, 0.8); }
            100% { box-shadow: 0 0 5px rgba(244, 67, 54, 0.5); }
        }
        
        /* Èí•ÂåôÂíåÈó®Ê†∑Âºè */
        .key-info {
            position: absolute;
            top: 60px;
            left: 50%;
            transform: translateX(-50%);
            color: white;
            background: rgba(0, 0, 0, 0.6);
            padding: 8px 15px;
            border-radius: 8px;
            font-size: 16px;
            backdrop-filter: blur(5px);
            font-family: monospace;
            z-index: 10;
            white-space: nowrap;
            animation: glow 1.5s infinite alternate;
        }
        
        @keyframes glow {
            from { box-shadow: 0 0 5px rgba(255, 215, 0, 0.5); }
            to { box-shadow: 0 0 15px rgba(255, 215, 0, 0.8); }
        }
        
        .unlock-timer {
            position: absolute;
            top: 100px;
            left: 50%;
            transform: translateX(-50%);
            color: white;
            background: rgba(0, 0, 0, 0.6);
            padding: 8px 15px;
            border-radius: 8px;
            font-size: 16px;
            backdrop-filter: blur(5px);
            font-family: monospace;
            z-index: 10;
            white-space: nowrap;
            animation: glow 1.5s infinite alternate;
        }
        
        /* ÊéßÂà∂Âè∞Ê†∑Âºè */
        .console-container {
            position: fixed;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.85);
            width: 500px;
            max-width: 90%;
            padding: 15px;
            border-radius: 10px;
            border: 2px solid #4CAF50;
            box-shadow: 0 0 20px rgba(76, 175, 80, 0.7);
            z-index: 2000;
            display: flex;
            flex-direction: column;
            font-family: 'Courier New', monospace;
        }
        
        .console-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding-bottom: 10px;
            border-bottom: 1px solid #4CAF50;
            margin-bottom: 10px;
        }
        
        .console-title {
            font-size: 18px;
            font-weight: bold;
            color: #4CAF50;
        }
        
        .console-close {
            background: none;
            border: none;
            color: #f44336;
            font-size: 20px;
            cursor: pointer;
            padding: 0;
            width: 30px;
            height: 30px;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 50%;
            transition: all 0.3s;
        }
        
        .console-close:hover {
            background: rgba(244, 67, 54, 0.2);
        }
        
        .console-output {
            background: rgba(20, 20, 30, 0.9);
            height: 200px;
            border-radius: 5px;
            padding: 10px;
            margin-bottom: 10px;
            overflow-y: auto;
            font-size: 14px;
            color: #ccc;
            white-space: pre-wrap;
        }
        
        .console-input-group {
            display: flex;
        }
        
        .console-prompt {
            color: #4CAF50;
            padding: 8px 10px 8px 0;
            font-weight: bold;
        }
        
        .console-input {
            flex: 1;
            background: rgba(30, 30, 40, 0.9);
            border: 1px solid #4CAF50;
            border-radius: 5px;
            padding: 8px 12px;
            color: white;
            font-family: 'Courier New', monospace;
            font-size: 14px;
            outline: none;
        }
        
        .console-input:focus {
            border-color: #8BC34A;
            box-shadow: 0 0 8px rgba(139, 195, 74, 0.5);
        }
        
        .console-status {
            margin-top: 10px;
            padding: 5px 10px;
            background: rgba(30, 30, 40, 0.9);
            border-radius: 5px;
            font-size: 12px;
            color: #aaa;
        }
        
        .console-hidden {
            display: none;
        }
        
        /* ÊéßÂà∂Âè∞ÊèêÁ§∫ */
        .console-hint {
            position: fixed;
            bottom: 20px;
            right: 20px;
            background: rgba(0, 0, 0, 0.7);
            padding: 8px 15px;
            border-radius: 5px;
            font-size: 14px;
            font-family: monospace;
            border: 1px solid #4CAF50;
            z-index: 100;
            animation: fadeInHint 0.5s;
        }
        
        @keyframes fadeInHint {
            from { opacity: 0; transform: translateY(20px); }
            to { opacity: 1; transform: translateY(0); }
        }
        
        .console-hint.hidden {
            display: none;
        }
        
        /* UIËÆæÁΩÆÈù¢ÊùøÊ†∑Âºè */
        .settings-modal {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.9);
            padding: 30px;
            border-radius: 15px;
            width: 80%;
            max-width: 500px;
            z-index: 1000;
            box-shadow: 0 0 40px rgba(76, 175, 80, 0.7);
            border: 2px solid #4CAF50;
        }

        .settings-modal h2 {
            color: #4CAF50;
            text-align: center;
            margin-top: 0;
            margin-bottom: 20px;
        }

        .setting-group {
            margin-bottom: 20px;
            padding-bottom: 15px;
            border-bottom: 1px solid #4CAF50;
        }

        .setting-group h3 {
            color: #8BC34A;
            margin-top: 0;
            margin-bottom: 15px;
        }

        .setting-row {
            display: flex;
            align-items: center;
            margin: 10px 0;
        }

        .setting-row label {
            width: 80px;
            margin-right: 15px;
            color: white;
        }

        .setting-row select, 
        .setting-row input[type="range"] {
            flex: 1;
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid #4CAF50;
            color: white;
            padding: 8px;
            border-radius: 5px;
        }

        .setting-row input[type="range"] {
            padding: 0;
        }
        
        .setting-checkbox {
            display: flex;
            align-items: center;
            margin-bottom: 10px;
        }
        
        .setting-checkbox input {
            margin-right: 10px;
        }

        .buttons {
            display: flex;
            justify-content: center;
            gap: 20px;
            margin-top: 20px;
        }

        .buttons button {
            padding: 10px 25px;
            background: linear-gradient(135deg, #4CAF50, #2E7D32);
            color: white;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .buttons button:hover {
            transform: translateY(-3px);
            box-shadow: 0 5px 15px rgba(0,0,0,0.4);
        }

        /* ËÆæÁΩÆÊåâÈíÆÊ†∑Âºè */
        .settings-button {
            position: fixed;
            top: 15px;
            right: 15px;
            background: rgba(0, 0, 0, 0.6);
            border: none;
            color: white;
            font-size: 24px;
            width: 40px;
            height: 40px;
            border-radius: 50%;
            cursor: pointer;
            z-index: 20;
            transition: all 0.3s;
        }

        .settings-button:hover {
            background: rgba(76, 175, 80, 0.8);
            transform: scale(1.1);
        }
        
        /* Ê∏∏Êàè‰ø°ÊÅØËÆæÁΩÆ */
        .info-settings {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
        }
        .drag-handle {
            width: 100%;
            height: 20px;
            background: rgba(76, 175, 80, 0.2);
            border-top-left-radius: 10px;
            border-top-right-radius: 10px;
            cursor: move;
            position: absolute;
            top: -20px;
            left: 0;
            z-index: 1;
        }
        
        .controls-panel.draggable {
            cursor: grabbing;
        }
#controlsPanel {
    position: fixed;
    /* ÂàùÂßã‰ΩçÁΩÆÔºà‰ºöË¢´JSË¶ÜÁõñÔºâ */
    left: 20px;
    bottom: 20px;
    /* Âπ≥ÊªëÁßªÂä®ÊïàÊûú */
    transition: left 0.2s, top 0.2s;
    /* Èò≤Ê≠¢Ëß¶Êë∏È´ò‰∫Æ */
    -webkit-tap-highlight-color: transparent;
}

#dragHandle {
    width: 100%;
    height: 30px;
    /* Ëß¶Êë∏‰ºòÂåñ */
    touch-action: none;
    cursor: grab;
}
.level-control-button.next {
    background: linear-gradient(135deg, #4CAF50, #2E7D32);
}

.level-control-button.skip {
    background: linear-gradient(135deg, #FF9800, #F57C00);
    animation: pulse 1.5s infinite;
}

@keyframes pulse {
    0% { box-shadow: 0 0 5px rgba(255, 152, 0, 0.7); }
    50% { box-shadow: 0 0 15px rgba(255, 152, 0, 0.9); }
    100% { box-shadow: 0 0 5px rgba(255, 152, 0, 0.7); }
}

        /* Êñ∞Â¢ûÊ†∑ÂºèÔºöË∏¢Âá∫ÊåâÈíÆ */
        .kick-button {
            background: linear-gradient(135deg, #f44336, #d32f2f);
            color: white;
            border: none;
            border-radius: 3px;
            padding: 2px 6px;
            font-size: 12px;
            cursor: pointer;
            margin-left: 5px;
        }
        
        .kick-button:hover {
            background: linear-gradient(135deg, #ff5252, #ff1744);
        }
        
        /* ÊàøÈó¥ËÆæÁΩÆÊ†∑Âºè */
        .room-settings {
            background: rgba(0, 0, 0, 0.7);
            padding: 15px;
            border-radius: 10px;
            margin-top: 15px;
            border: 1px solid #4CAF50;
        }
        
        .room-settings h4 {
            margin-top: 0;
            margin-bottom: 10px;
            color: #8BC34A;
        }
/* Êõ¥Â§öÊåëÊàòÊ†∑Âºè */
.challenges-container {
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 20px;
    max-width: 600px;
    margin: 30px auto;
    padding: 20px;
}

.challenge-card {
    background: rgba(0, 0, 0, 0.7);
    border: 2px solid #4CAF50;
    border-radius: 15px;
    padding: 25px;
    width: 100%;
    cursor: pointer;
    transition: all 0.3s ease;
    text-align: left;
}

.challenge-card:hover {
    transform: translateY(-5px);
    box-shadow: 0 10px 25px rgba(76, 175, 80, 0.3);
    background: rgba(0, 0, 0, 0.8);
}

.challenge-card h3 {
    color: #4CAF50;
    margin-top: 0;
    font-size: 24px;
}

.challenge-card p {
    color: #ccc;
    margin-bottom: 15px;
}

.challenge-stats {
    color: #8BC34A;
    font-size: 14px;
}

/* ÊàêÂ∞±Á≥ªÁªüÊ†∑Âºè */
.achievements-container {
    max-width: 600px;
    margin: 30px auto;
    padding: 20px;
}

.achievement-item {
    display: flex;
    align-items: center;
    background: rgba(0, 0, 0, 0.7);
    border: 2px solid #333;
    border-radius: 10px;
    padding: 15px;
    margin-bottom: 15px;
    transition: all 0.3s ease;
}

.achievement-item.completed {
    border-color: #FFD700;
    background: rgba(255, 215, 0, 0.1);
}

.achievement-icon {
    font-size: 32px;
    margin-right: 15px;
}

.achievement-info {
    flex: 1;
}

.achievement-info h3 {
    color: #fff;
    margin: 0 0 5px 0;
    font-size: 18px;
}

.achievement-info p {
    color: #ccc;
    margin: 0 0 10px 0;
    font-size: 14px;
}

.achievement-progress {
    display: flex;
    align-items: center;
    gap: 10px;
}
.special-challenges {
    margin-top: 30px;
    border-top: 1px solid #4CAF50;
    padding-top: 20px;
}

.challenge-button {
    background: rgba(76, 175, 80, 0.2);
    border: 1px dashed #4CAF50;
    border-radius: 8px;
    padding: 15px;
    width: 100%;
    display: flex;
    align-items: center;
    cursor: pointer;
    transition: all 0.3s;
}

.challenge-button:hover {
    background: rgba(76, 175, 80, 0.4);
}

.challenge-icon {
    font-size: 30px;
    margin-right: 15px;
}
.progress-bar {
    flex: 1;
    height: 8px;
    background: #333;
    border-radius: 4px;
    overflow: hidden;
}

.progress-fill {
    height: 100%;
    background: linear-gradient(135deg, #4CAF50, #8BC34A);
    border-radius: 4px;
    transition: width 0.3s ease;
}

.achievement-status {
    padding: 5px 10px;
    background: #333;
    border-radius: 15px;
    font-size: 12px;
    color: #ccc;
}

.achievement-item.completed .achievement-status {
    background: #FFD700;
    color: #000;
    font-weight: bold;
}

/* Êó∂Èó¥ÊåëÊàòÊèêÁ§∫ */
.time-challenge-info {
    position: absolute;
    top: 20px;
    right: 20px;
    background: rgba(244, 67, 54, 0.9);
    color: white;
    padding: 10px 15px;
    border-radius: 8px;
    font-family: monospace;
    z-index: 10;
    animation: pulse 1.5s infinite;
}
.replay-list {
    max-height: 400px;
    overflow-y: auto;
    margin: 15px 0;
    border: 1px solid #333;
    border-radius: 5px;
}

.replay-item {
    padding: 12px;
    border-bottom: 1px solid #444;
    cursor: pointer;
    transition: background 0.2s;
}

.replay-item:hover {
    background: rgba(76, 175, 80, 0.1);
}

.replay-meta {
    display: flex;
    justify-content: space-between;
    margin-bottom: 5px;
}

.player-container {
    margin-top: 20px;
    background: #111;
    padding: 15px;
    border-radius: 5px;
}

.player-controls {
    display: flex;
    align-items: center;
    gap: 10px;
    margin-top: 15px;
}

.speed-control {
    margin-left: auto;
}
/* ‰∫ã‰ª∂ÈÄöÁü•Ê†∑Âºè */
#event-notifications {
  position: fixed;
  top: 20px;
  left: 50%;
  transform: translateX(-50%);
  z-index: 1000;
}

.event-notification {
  background: rgba(0,0,0,0.8);
  color: #fff;
  padding: 10px 15px;
  border-radius: 5px;
  border-left: 4px solid #FF9800;
  margin-bottom: 5px;
  animation: fadeIn 0.3s;
}

@keyframes fadeIn {
  from { opacity: 0; transform: translateY(-20px); }
  to { opacity: 1; transform: translateY(0); }
}
/* ÂïÜÂ∫óÊ®°ÊÄÅÊ°ÜÊ†∑Âºè */
.shop-modal {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: rgba(0, 0, 0, 0.85);
    display: flex;
    justify-content: center;
    align-items: center;
    z-index: 2000;
}

.shop-content {
    background: linear-gradient(135deg, #1a1a2e, #16213e);
    border: 2px solid #4CAF50;
    border-radius: 15px;
    padding: 25px;
    width: 90%;
    max-width: 600px;
    max-height: 80vh;
    overflow-y: auto;
    box-shadow: 0 0 40px rgba(76, 175, 80, 0.5);
}

.shop-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 25px;
    padding-bottom: 15px;
    border-bottom: 1px solid #4CAF50;
}

.shop-header h2 {
    color: #4CAF50;
    margin: 0;
}

.shop-close-btn {
    background: none;
    border: none;
    color: #f44336;
    font-size: 24px;
    cursor: pointer;
    padding: 0;
    width: 30px;
    height: 30px;
    display: flex;
    align-items: center;
    justify-content: center;
    border-radius: 50%;
    transition: all 0.3s;
}

.shop-close-btn:hover {
    background: rgba(244, 67, 54, 0.2);
}

.shop-items {
    display: flex;
    flex-direction: column;
    gap: 15px;
}

.shop-item {
    background: rgba(0, 0, 0, 0.5);
    border: 1px solid #4CAF50;
    border-radius: 10px;
    padding: 15px;
    display: flex;
    align-items: center;
    transition: all 0.3s ease;
}

.shop-item:hover {
    background: rgba(76, 175, 80, 0.1);
    transform: translateY(-3px);
    box-shadow: 0 5px 15px rgba(0,0,0,0.4);
}

.item-icon {
    font-size: 40px;
    margin-right: 20px;
}

.item-info {
    flex: 1;
}

.item-info h3 {
    color: #8BC34A;
    margin: 0 0 5px 0;
    font-size: 20px;
}

.item-info p {
    color: #ccc;
    margin: 0;
    font-size: 14px;
}

.item-price {
    display: flex;
    align-items: center;
    margin: 0 20px;
}

.coin-icon {
    color: gold;
    font-size: 20px;
    margin-right: 5px;
}

.price-amount {
    color: gold;
    font-weight: bold;
    font-size: 18px;
}

.buy-btn {
    padding: 8px 20px;
    background: linear-gradient(135deg, #FFC107, #FF9800);
    color: white;
    border: none;
    border-radius: 6px;
    cursor: pointer;
    font-size: 16px;
    transition: all 0.3s;
}

.buy-btn:hover {
    transform: scale(1.05);
    box-shadow: 0 3px 10px rgba(255, 152, 0, 0.5);
}

/* ÂΩìÈáëÂ∏Å‰∏çË∂≥Êó∂ÔºåÊåâÈíÆÂèòÁÅ∞‰∏î‰∏çÂèØÁÇπÂáª */
.buy-btn:disabled {
    background: #555;
    cursor: not-allowed;
    transform: scale(1);
}
/* ÁâàÊú¨Ê£ÄÊü•Ê®°ÊÄÅÊ°Ü */
.version-modal {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: rgba(0, 0, 0, 0.85);
    display: flex;
    justify-content: center;
    align-items: center;
    z-index: 2000;
}

.version-content {
    background: linear-gradient(135deg, #1a1a2e, #16213e);
    border: 2px solid #4CAF50;
    border-radius: 15px;
    padding: 30px;
    width: 90%;
    max-width: 500px;
    box-shadow: 0 0 40px rgba(76, 175, 80, 0.5);
}

.version-input-group {
    margin-bottom: 20px;
}

.version-input-group label {
    display: block;
    margin-bottom: 8px;
    color: #4CAF50;
    font-weight: bold;
}

.version-input-group input {
    width: 100%;
    padding: 12px;
    background: rgba(255, 255, 255, 0.1);
    border: 1px solid #4CAF50;
    border-radius: 5px;
    color: white;
    font-size: 16px;
}

.ip-tips {
    margin-top: 5px;
    color: #888;
}

.version-actions {
    display: flex;
    gap: 15px;
    justify-content: center;
    margin: 20px 0;
}

.version-actions button {
    padding: 10px 25px;
    background: linear-gradient(135deg, #4CAF50, #2E7D32);
    color: white;
    border: none;
    border-radius: 6px;
    cursor: pointer;
    transition: all 0.3s ease;
}

.version-actions button:hover {
    transform: translateY(-3px);
    box-shadow: 0 5px 15px rgba(0,0,0,0.4);
}

.version-status {
    background: rgba(0, 0, 0, 0.3);
    padding: 15px;
    border-radius: 8px;
    margin: 15px 0;
    border: 1px solid #4CAF50;
}

.version-status h4 {
    color: #4CAF50;
    margin-top: 0;
    margin-bottom: 10px;
}

.version-info {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin: 8px 0;
    padding: 5px 0;
    border-bottom: 1px solid rgba(76, 175, 80, 0.2);
}

.version-info:last-child {
    border-bottom: none;
}

.version-label {
    color: #aaa;
    font-size: 14px;
}

.version-value {
    color: white;
    font-weight: bold;
    font-family: monospace;
}

.connection-status {
    display: flex;
    align-items: center;
    justify-content: center;
    gap: 10px;
    padding: 20px;
    background: rgba(76, 175, 80, 0.2);
    border-radius: 8px;
    margin: 15px 0;
}

.spinner {
    width: 20px;
    height: 20px;
    border: 2px solid rgba(255, 255, 255, 0.3);
    border-top: 2px solid #4CAF50;
    border-radius: 50%;
    animation: spin 1s linear infinite;
}

@keyframes spin {
    0% { transform: rotate(0deg); }
    100% { transform: rotate(360deg); }
}

.server-response {
    margin-top: 20px;
    padding: 15px;
    background: rgba(0, 0, 0, 0.3);
    border-radius: 8px;
    border: 1px solid #4CAF50;
}

.server-response h3 {
    color: #4CAF50;
    margin-top: 0;
    margin-bottom: 10px;
}

#responseContent {
    color: white;
    white-space: pre-wrap;
    font-family: monospace;
}

.update-progress {
    margin-top: 15px;
}

.progress-bar {
    width: 100%;
    height: 8px;
    background: rgba(255, 255, 255, 0.1);
    border-radius: 4px;
    overflow: hidden;
    margin-bottom: 8px;
}

.progress-fill {
    height: 100%;
    background: linear-gradient(90deg, #2196F3, #4CAF50);
    border-radius: 4px;
    transition: width 0.3s ease;
    width: 0%;
}

.progress-text {
    text-align: center;
    color: #aaa;
    font-size: 12px;
    margin-top: 5px;
}

.update-files {
    margin-top: 15px;
    background: rgba(0, 0, 0, 0.3);
    border-radius: 6px;
    padding: 10px;
    max-height: 200px;
    overflow-y: auto;
}

.file-item {
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding: 5px 0;
    border-bottom: 1px solid rgba(255, 255, 255, 0.1);
    font-size: 12px;
}

.file-item:last-child {
    border-bottom: none;
}

.file-name {
    color: #ccc;
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
    max-width: 60%;
}

.file-size {
    color: #888;
}

.file-status {
    color: #4CAF50;
}

.version-indicator {
    display: inline-block;
    width: 8px;
    height: 8px;
    border-radius: 50%;
    margin-right: 5px;
}

.version-indicator.up-to-date {
    background: #4CAF50;
}

.version-indicator.outdated {
    background: #f44336;
    animation: pulse 2s infinite;
}

@keyframes pulse {
    0% { opacity: 1; }
    50% { opacity: 0.5; }
    100% { opacity: 1; }
}

.version-indicator.checking {
    background: #FF9800;
    animation: spin 1s linear infinite;
}

/* Ë∞ÉËØïÂ±èÂπï */
.screen {
    position: fixed;
    top: 20px;
    right: 20px;
    background: rgba(0, 0, 0, 0.9);
    border: 1px solid #4CAF50;
    border-radius: 10px;
    padding: 20px;
    min-width: 300px;
    max-width: 500px;
    z-index: 1000;
    font-family: monospace;
    font-size: 12px;
    max-height: 80vh;
    overflow-y: auto;
}
    .room-browser {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: rgba(0, 0, 0, 0.85);
        display: flex;
        justify-content: center;
        align-items: center;
        z-index: 2000;
    }
    
    .room-browser-container {
        background: linear-gradient(135deg, #1a1a2e, #16213e);
        border: 2px solid #4CAF50;
        border-radius: 15px;
        padding: 30px;
        width: 90%;
        max-width: 800px;
        height: 80vh;
        display: flex;
        flex-direction: column;
        box-shadow: 0 0 40px rgba(76, 175, 80, 0.5);
    }
    
    .browser-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-bottom: 20px;
        padding-bottom: 15px;
        border-bottom: 1px solid #4CAF50;
    }
    
    .browser-title {
        color: #4CAF50;
        font-size: 24px;
        margin: 0;
    }
    
    .browser-close {
        background: none;
        border: none;
        color: #f44336;
        font-size: 24px;
        cursor: pointer;
        padding: 0;
        width: 30px;
        height: 30px;
        display: flex;
        align-items: center;
        justify-content: center;
        border-radius: 50%;
        transition: all 0.3s;
    }
    
    .browser-close:hover {
        background: rgba(244, 67, 54, 0.2);
    }
    
    .browser-controls {
        display: flex;
        gap: 15px;
        margin-bottom: 20px;
        flex-wrap: wrap;
    }
    
    .search-box {
        flex: 1;
        min-width: 200px;
        position: relative;
    }
    
    .search-input {
        width: 100%;
        padding: 10px 40px 10px 15px;
        background: rgba(255, 255, 255, 0.1);
        border: 1px solid #4CAF50;
        border-radius: 5px;
        color: white;
        font-size: 16px;
        outline: none;
    }
    
    .search-input:focus {
        border-color: #8BC34A;
        box-shadow: 0 0 8px rgba(139, 195, 74, 0.5);
    }
    
    .search-icon {
        position: absolute;
        right: 10px;
        top: 50%;
        transform: translateY(-50%);
        color: #4CAF50;
    }
    
    .filter-select {
        padding: 10px 15px;
        background: rgba(255, 255, 255, 0.1);
        border: 1px solid #4CAF50;
        border-radius: 5px;
        color: white;
        font-size: 16px;
        outline: none;
        cursor: pointer;
    }
    
    .filter-select option {
        background: #16213e;
        color: white;
    }
    
    .room-list {
        flex: 1;
        overflow-y: auto;
        border: 1px solid #333;
        border-radius: 5px;
        padding: 10px;
        background: rgba(0, 0, 0, 0.3);
    }
    
    .room-item {
        background: rgba(255, 255, 255, 0.05);
        border: 1px solid #4CAF50;
        border-radius: 10px;
        padding: 15px;
        margin-bottom: 10px;
        transition: all 0.3s ease;
        cursor: pointer;
    }
    
    .room-item:hover {
        background: rgba(76, 175, 80, 0.1);
        transform: translateX(5px);
    }
    
    .room-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-bottom: 10px;
    }
    
    .room-name {
        font-size: 18px;
        font-weight: bold;
        color: #4CAF50;
    }
    
    .room-code {
        background: rgba(0, 0, 0, 0.5);
        padding: 5px 10px;
        border-radius: 15px;
        font-size: 14px;
        color: #fff;
        border: 1px solid #666;
    }
    
    .room-info {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-top: 10px;
    }
    
    .room-host {
        color: #8BC34A;
        font-size: 14px;
    }
    
    .room-players {
        display: flex;
        align-items: center;
        gap: 5px;
    }
    
    .player-badge {
        width: 25px;
        height: 25px;
        border-radius: 50%;
        background: #4CAF50;
        display: flex;
        align-items: center;
        justify-content: center;
        font-size: 12px;
        font-weight: bold;
        color: white;
    }
    
    .room-status {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-top: 10px;
    }
    
    .player-count {
        font-size: 14px;
        color: #ccc;
    }
    
    .join-button {
        padding: 8px 20px;
        background: linear-gradient(135deg, #4CAF50, #2E7D32);
        color: white;
        border: none;
        border-radius: 5px;
        cursor: pointer;
        font-size: 16px;
        transition: all 0.3s;
    }
    
    .join-button:hover {
        transform: translateY(-2px);
        box-shadow: 0 5px 15px rgba(0,0,0,0.4);
    }
    
    .join-button:disabled {
        background: #555;
        cursor: not-allowed;
        transform: none;
        box-shadow: none;
    }
    
    .room-private {
        position: absolute;
        top: 10px;
        right: 10px;
        background: rgba(255, 152, 0, 0.2);
        border: 1px solid #FF9800;
        border-radius: 15px;
        padding: 3px 10px;
        font-size: 12px;
        color: #FF9800;
    }
    
    .refresh-button {
        position: absolute;
        top: 20px;
        right: 20px;
        background: rgba(76, 175, 80, 0.2);
        border: 1px solid #4CAF50;
        border-radius: 50%;
        width: 40px;
        height: 40px;
        display: flex;
        align-items: center;
        justify-content: center;
        cursor: pointer;
        transition: all 0.3s;
    }
    
    .refresh-button:hover {
        background: rgba(76, 175, 80, 0.4);
    }
    
    .refresh-button.spinning {
        animation: spin 1s linear infinite;
    }
    
    @keyframes spin {
        from { transform: rotate(0deg); }
        to { transform: rotate(360deg); }
    }
    
    .no-rooms {
        text-align: center;
        color: #888;
        padding: 40px;
        font-size: 18px;
    }
    
    .connection-status-server {
        position: absolute;
        top: 20px;
        left: 20px;
        background: rgba(0, 0, 0, 0.7);
        padding: 10px 15px;
        border-radius: 5px;
        font-size: 14px;
        display: flex;
        align-items: center;
        gap: 10px;
    }
    
    .status-dot {
        width: 10px;
        height: 10px;
        border-radius: 50%;
        background: #4CAF50;
        animation: pulse 2s infinite;
    }
    
    .status-dot.error {
        background: #f44336;
        animation: none;
    }
    
    @keyframes pulse {
        0% { opacity: 1; }
        50% { opacity: 0.5; }
        100% { opacity: 1; }
    }
/* ÊúçÂä°Âô®ËÆæÁΩÆÊ†∑Âºè */
.server-settings {
    background: rgba(0, 0, 0, 0.7);
    padding: 15px;
    border-radius: 10px;
    margin-bottom: 15px;
    border: 1px solid #4CAF50;
}

.server-settings h4 {
    margin-top: 0;
    margin-bottom: 10px;
    color: #8BC34A;
}

.test-button {
    background: linear-gradient(135deg, #2196F3, #0D47A1);
    color: white;
    border: none;
    border-radius: 6px;
    padding: 8px 16px;
    cursor: pointer;
    transition: all 0.3s ease;
}

.test-button:hover {
    transform: translateY(-2px);
    box-shadow: 0 5px 15px rgba(0,0,0,0.4);
}

.test-button:disabled {
    background: #666;
    cursor: not-allowed;
    transform: none;
    box-shadow: none;
}

/* Á¶ªÁ∫øÊ®°ÂºèÊèêÁ§∫ */
.offline-mode {
    background: rgba(255, 152, 0, 0.2);
    border: 1px solid #FF9800;
    border-radius: 8px;
    padding: 10px;
    margin: 10px 0;
    color: #FF9800;
    text-align: center;
}
/* ÊàøÈó¥ÊµèËßàÂô®ÊåâÈíÆÊ†∑Âºè */
.browser-footer .menu-button {
    background: linear-gradient(135deg, #4CAF50, #2E7D32);
    margin: 5px;
    min-width: 120px;
}

.browser-footer .menu-button:last-child {
    background: linear-gradient(135deg, #666, #444);
}

/* Âä†ËΩΩÂä®Áîª */
@keyframes spin {
    from { transform: rotate(0deg); }
    to { transform: rotate(360deg); }
}

.spinner {
    display: inline-block;
    width: 16px;
    height: 16px;
    border: 2px solid rgba(255,255,255,0.3);
    border-top: 2px solid #4CAF50;
    border-radius: 50%;
    animation: spin 1s linear infinite;
    margin-right: 8px;
}
.small-menu-button {
    display: block;
    width: 150px;
    margin: 15px auto;
    padding: 13px;
    font-size: 18px;
    background: linear-gradient(135deg, #4CAF50, #2E7D32);
    color: white;
    border: none;
    border-radius: 6px;
    cursor: pointer;
    transition: all 0.3s ease;
    box-shadow: 0 3px 10px rgba(0,0,0,0.3);
}
    </style>
</head>

<body>
    <div id="shopModal" class="shop-modal hidden">
        <div class="shop-content">
            <div class="shop-header">
                <h2>Ê∏∏ÊàèÂïÜÂ∫ó</h2>
                <button class="shop-close-btn" onclick="closeShop()">√ó</button>
            </div>
            <div class="shop-items">
                <!-- ÈÅìÂÖ∑1ÔºöÊïàÊûúÊ∏ÖÈô§ -->
                <div class="shop-item" data-item="clear-events">
                    <div class="item-icon">‚ú®</div>
                    <div class="item-info">
                        <h3>ÊïàÊûúÊ∏ÖÈô§</h3>
                        <p>Ê∏ÖÈô§ÂΩìÂâçËß¶ÂèëÁöÑÊâÄÊúâÈöèÊú∫‰∫ã‰ª∂ÔºàÂ¶ÇÊéßÂà∂ÂèçËΩ¨Ôºâ„ÄÇ</p>
                    </div>
                    <div class="item-price">
                        <span class="coin-icon">ü™ô</span>
                        <span class="price-amount">20</span>
                    </div>
                    <button class="buy-btn" onclick="buyItem('clear-events')">Ë¥≠‰π∞</button>
                </div>
                
                <!-- ÈÅìÂÖ∑3Ôºö‰º†ÈÄÅ -->
                <div class="shop-item" data-item="teleport">
                    <div class="item-icon">üåÄ</div>
                    <div class="item-info">
                        <h3>‰º†ÈÄÅ</h3>
                        <p>Âú®Âçï‰∫∫Ê∏∏Êàè‰∏≠ÔºåËÆ©‰Ω†‰º†ÈÄÅÂà∞Âú∞Âõæ‰∏äÁöÑ‰ªªÊÑè‰ΩçÁΩÆ„ÄÇ</p>
                        <p class="item-note" style="color: #888; font-size: 12px;">*‰ªÖÈôêÂçï‰∫∫Ê∏∏Êàè</p>
                    </div>
                    <div class="item-price">
                        <span class="coin-icon">ü™ô</span>
                        <span class="price-amount">25</span>
                    </div>
                    <button class="buy-btn" onclick="buyItem('teleport')">Ë¥≠‰π∞</button>
                </div>
            </div>
        </div>
    </div>
    <!-- ‰∏ªËèúÂçï -->
    <div id="mainMenu" class="main-menu">
        <h1 class="menu-title">Ëø∑ÂÆ´ÂÜíÈô©</h1>
        <button class="menu-button" onclick="showScreen('singlePlayerLevelSelect')">Âçï‰∫∫Ê∏∏Êàè</button>
        <button class="menu-button" onclick="showScreen('multiplayerSetup')">Â±ÄÂüüÁΩëÂ§ö‰∫∫Ê∏∏Êàè iOSËØ∑Á°Æ‰øùÊúçÂä°Âô®ÂºÄÂêØ</button>
        <button class="menu-button" onclick="showInstructions()">Ê∏∏ÊàèËØ¥Êòé</button>
        <button class="menu-button" onclick="showScreen('achievementsScreen')">ÊàêÂ∞±Á≥ªÁªü</button>
        <!-- <button class="menu-button" onclick="showScreen('moreChallengesScreen')">Êõ¥Â§öÊåëÊàò</button> -->
        <!-- <button class="menu-button" onclick="showSaveLoadMenu()">Â≠òÊ°£/ËØªÊ°£</button> -->
        <button class="menu-button" onclick="showUISettings()">UIËÆæÁΩÆ</button>
        <button class="menu-button" onclick="openShop()">Ê∏∏ÊàèÂïÜÂ∫ó</button>
        
        <!-- Êñ∞Â¢ûÁé©ÂÆ∂Â∑•ÂùäÊåâÈíÆ -->
        <button id="workshopBtn" class="menu-btn highlight">
            Áé©ÂÆ∂Â∑•Âùä
            <span class="badge" id="newLevelsBadge">12</span>
        </button>
        
        <button id="playBtn" class="menu-btn">
            <i class="icon-play"></i> ÂºÄÂßãÊ∏∏Êàè
        </button>
        </div>
    
    <div id="moreChallengesScreen" class="hidden">
        <button class="back-button" onclick="showScreen('mainMenu')">ËøîÂõû</button>
        <h2 class="level-select-title">Êõ¥Â§öÊåëÊàò</h2>
        <div class="challenges-container">
            <div class="challenge-card" onclick="startTimeChallenge()">
                <h3>Êó∂Èó¥ÊåëÊàò</h3>
                <p>Âú®60ÁßíÂÜÖÂ∞ΩÂèØËÉΩÈÄöËøáÊõ¥Â§öÂÖ≥Âç°ÔºÅ</p>
                <div class="challenge-stats">ÊúÄ‰Ω≥ËÆ∞ÂΩï: <span id="timeChallengeBest">0</span>Áßí</div>
            </div>
            <div class="challenge-card" onclick="startPuzzleMode()">
                <h3>Ëß£Ë∞úÊ®°Âºè</h3>
                <p>Ëß£ÂºÄÁ≤æÂøÉËÆæËÆ°ÁöÑË∞úÈ¢òÂÖ≥Âç°„ÄÇ</p>
                <div class="challenge-stats">Â∑≤ÂÆåÊàê: <span id="puzzleCompleted">0</span>/10</div>
            </div>
        </div>
    </div>
    <!-- ÊàêÂ∞±Á≥ªÁªüÁïåÈù¢ -->
    <div id="achievementsScreen" class="hidden">
        <button class="back-button" onclick="showScreen('mainMenu')">ËøîÂõû</button>
        <h2 class="level-select-title">ÊàêÂ∞±Á≥ªÁªü</h2>
        
        <div class="achievements-container">
            <div class="achievement-item" id="achievement1">
                <div class="achievement-icon">üèÜ</div>
                <div class="achievement-info">
                    <h3>Ëø∑ÂÆ´Â§ßÂ∏à</h3>
                    <p>ÈÄöÂÖ≥ÊâÄÊúâÂÖ≥Âç°</p>
                    <div class="achievement-progress">
                        <div class="progress-bar">
                            <div class="progress-fill" id="progress1"></div>
                        </div>
                        <span id="progressText1">0/80</span>
                    </div>
                </div>
                <div class="achievement-status" id="status1">Êú™ÂÆåÊàê</div>
            </div>
            
            <div class="achievement-item" id="achievement2">
                <div class="achievement-icon">üë•</div>
                <div class="achievement-info">
                    <h3>Á§æ‰∫§Ëææ‰∫∫</h3>
                    <p>ÈÄöÂÖ≥10Ê¨°Â§ö‰∫∫ËÅîÊú∫ÊåëÊàò</p>
                    <div class="achievement-progress">
                        <div class="progress-bar">
                            <div class="progress-fill" id="progress2"></div>
                        </div>
                        <span id="progressText2">0/10</span>
                    </div>
                </div>
                <div class="achievement-status" id="status2">Êú™ÂÆåÊàê</div>
            </div>
            
            <div class="achievement-item" id="achievement3">
                <div class="achievement-icon">üí•</div>
                <div class="achievement-info">
                    <h3>Èô∑Èò±‰∏ìÂÆ∂</h3>
                    <p>Ëµ∞Âà∞Èô∑Èò±30Ê¨°</p>
                    <div class="achievement-progress">
                        <div class="progress-bar">
                            <div class="progress-fill" id="progress3"></div>
                        </div>
                        <span id="progressText3">0/30</span>
                    </div>
                </div>
                <div class="achievement-status" id="status3">Êú™ÂÆåÊàê</div>
            </div>
        </div>
    </div>
    <!-- Âçï‰∫∫Ê∏∏ÊàèÁïåÈù¢ -->
    <div id="singlePlayerLevelSelect" class="hidden">
        <button class="back-button" onclick="showScreen('mainMenu')">ËøîÂõû</button>
        <h2 class="level-select-title">ÈÄâÊã©ÂÖ≥Âç°</h2>
        <div class="level-container" id="levelContainer"></div>
    </div>

    <div id="singlePlayerGame" class="hidden">
        <button class="settings-button" onclick="showUISettings()">‚öôÔ∏è</button>
        <div class="game-info" id="gameInfo">
            <div class="game-info-item" id="levelDisplay">ÂÖ≥Âç°: 1</div>
            <div class="game-info-item" id="timeDisplay">Êó∂Èó¥: 0:00</div>
            <div class="game-info-item" id="moveCount">ÁßªÂä®: 0</div>
            <div class="game-info-item" id="keyStatus">Èí•Âåô: Êú™Ëé∑Âæó</div>
        </div>
        <div id="enemyInfo" class="enemy-info hidden">ÁßªÂä®Êïå‰∫∫Ê≠£Âú®ËøΩÈÄê‰Ω†ÔºÅ</div>
        <div id="keyInfo" class="key-info hidden">ÊâæÂà∞Èí•ÂåôÊâçËÉΩÂºÄÈó®ÔºÅ</div>
        <div id="unlockTimer" class="unlock-timer hidden">ÂºÄÈó®ÂÄíËÆ°Êó∂: 10Áßí</div>
        <canvas id="singlePlayerCanvas"></canvas>
        <div class="level-controls">
            <button class="level-control-button reset" onclick="resetSinglePlayerLevel()">ÈáçÁΩÆÂÖ≥Âç°</button>
            <button id="regularNextButton" class="level-control-button next" style="display:none;" onclick="loadNextLevel()">‰∏ã‰∏ÄÂÖ≥</button>
            <button id="unsolvableNextButton" class="level-control-button skip" style="display:none;" onclick="loadNextLevel()">Ë∑≥ËøáÊó†Ëß£ÂÖ≥Âç°</button>
            <!-- <button class="level-control-button exit" onclick="showExitConfirmation()">ÈÄÄÂá∫ÂÖ≥Âç°</button> -->
            <button class="level-control-button exit" onclick="showScreen('mainMenu')">ÈÄÄÂá∫ÂÖ≥Âç°</button>
            <button class="level-control-button shop-trigger" onclick="openShop()">üõí ÂïÜÂ∫ó</button>
        </div>
        <!-- ÊñπÂêëÈîÆÊéßÂà∂Èù¢Êùø -->
        <div class="controls-panel hidden" id="singlePlayerControls">
            <div class="control-button control-up" onclick="handleControlButtonClick('ArrowUp')">‚Üë</div>
            <div class="control-button control-left" onclick="handleControlButtonClick('ArrowLeft')">‚Üê</div>
            <div class="control-button control-right" onclick="handleControlButtonClick('ArrowRight')">‚Üí</div>
            <div class="control-button control-down" onclick="handleControlButtonClick('ArrowDown')">‚Üì</div>
        </div>
    </div>

    <div id="singlePlayerComplete" class="level-complete hidden">
        <h2>ÂÖ≥Âç°ÂÆåÊàê!</h2>
        <p id="singlePlayerCompleteTime">Áî®Êó∂: 0:00</p>
        <p id="singlePlayerCompleteMoves">ÁßªÂä®Ê¨°Êï∞: 0</p>
        <button onclick="loadNextLevel()">‰∏ã‰∏ÄÂÖ≥</button>
        <button onclick="showScreen('singlePlayerLevelSelect')">ÈÄâÊã©ÂÖ≥Âç°</button>
    </div>

    <!-- Â§ö‰∫∫Ê∏∏ÊàèÁïåÈù¢ -->
    <div id="multiplayerSetup" class="hidden">
        <div class="multiplayer-setup">
            <h2>Â§ö‰∫∫Ê∏∏ÊàèËÆæÁΩÆ</h2>
            <div>
                <input type="text" id="playerName" class="setup-input" placeholder="‰Ω†ÁöÑÂêçÂ≠ó" maxlength="10" value="Áé©ÂÆ∂">
            </div>
            <div>
                <input type="text" id="roomCode" class="setup-input" placeholder="ÊàøÈó¥‰ª£Á†Å (ÁïôÁ©∫ÂàõÂª∫Êñ∞ÊàøÈó¥)">
            </div>
            <div class="room-settings">
                <h4>ÊàøÈó¥ËÆæÁΩÆ (‰ªÖÂàõÂª∫ÊàøÈó¥Êó∂ÊúâÊïà)</h4>
                <div class="setting-row">
                    <label for="maxPlayers">ÊúÄÂ§ß‰∫∫Êï∞:</label>
                    <select id="maxPlayers" class="setup-input">
                        <option value="2">2‰∫∫</option>
                        <option value="3">3‰∫∫</option>
                        <option value="4">4‰∫∫</option>
                        <option value="5">5‰∫∫</option>
                        <option value="6">6‰∫∫</option>
                        <option value="7">7‰∫∫</option>
                        <option value="8">8‰∫∫</option>
                    </select>
                </div>
            </div>
                <button class="small-menu-button" onclick="connectToMultiplayerGame()">ÂºÄÂßãÊ∏∏Êàè</button>
                <button class="small-menu-button" onclick="showScreen('mainMenu')">ËøîÂõû</button>
            </div>
        </div>
    </div>

    <div id="multiplayerGame" class="hidden">
        <button class="settings-button" onclick="showUISettings()">‚öôÔ∏è</button>
        <div class="player-list" id="playerList">
            <h3>Áé©ÂÆ∂ÂàóË°®</h3>
            <div id="playersContainer"></div>
        </div>
        <div class="game-info" id="multiplayerGameInfo">
            <div class="game-info-item" id="multiplayerRoomCode">ÊàøÈó¥: </div>
            <div class="game-info-item" id="multiplayerTimeDisplay">Êó∂Èó¥: 0:00</div>
            <div class="game-info-item" id="multiplayerMoveCount">ÁßªÂä®: 0</div>
            <div class="game-info-item" id="multiplayerPlayerCount">Áé©ÂÆ∂: 0/0</div>
        </div>
        <div id="connectionStatus" class="connection-status connected">Â∑≤ËøûÊé•</div>
        <canvas id="multiplayerCanvas"></canvas>
        <div class="level-controls">
            <button class="level-control-button reset" onclick="resetMultiplayerPlayer()">ÈáçÁΩÆ‰ΩçÁΩÆ</button>
            <button class="level-control-button exit" onclick="disconnectMultiplayer()">ÈÄÄÂá∫Ê∏∏Êàè</button>
        </div>
        <!-- ÊñπÂêëÈîÆÊéßÂà∂Èù¢Êùø -->
        <div class="controls-panel hidden" id="multiplayerControls">
            <div class="control-button control-up" onclick="handleControlButtonClick('ArrowUp')">‚Üë</div>
            <div class="control-button control-left" onclick="handleControlButtonClick('ArrowLeft')">‚Üê</div>
            <div class="control-button control-right" onclick="handleControlButtonClick('ArrowRight')">‚Üí</div>
            <div class="control-button control-down" onclick="handleControlButtonClick('ArrowDown')">‚Üì</div>
        </div>
    </div>

    <!-- Ê∏∏ÊàèËØ¥ÊòéÂºπÁ™ó -->
    <div id="instructionsModal" class="instructions-modal hidden">
        <h2>Ê∏∏ÊàèËØ¥Êòé</h2>
        <p><strong>Âçï‰∫∫Ê®°ÂºèÔºö</strong>80‰∏™Áã¨ÁâπÂÖ≥Âç°ÔºåÈöæÂ∫¶ÈÄíÂ¢û„ÄÇ‰ΩøÁî®ÊñπÂêëÈîÆÁßªÂä®ËßíËâ≤ÔºåÈÅøÂºÄÈô∑Èò±ÔºåÊâæÂà∞Âá∫Âè£„ÄÇ</p>
        <p><strong>Â§ö‰∫∫Ê®°ÂºèÔºö</strong>‰∏éÊúãÂèãÂêà‰ΩúÊàñÁ´û‰∫â„ÄÇÂàõÂª∫ÊàøÈó¥ÊàñÂä†ÂÖ•Â∑≤ÊúâÊàøÈó¥ÔºåÂÖ±ÂêåÂÆåÊàêËø∑ÂÆ´ÊåëÊàò„ÄÇ</p>
        <p><strong>Ëø∑ÂÆ´ÂÖÉÁ¥†Ôºö</strong></p>
        <ul>
            <li>ÁªøËâ≤ÔºöÁé©ÂÆ∂</li>
            <li>Á∫¢Ëâ≤ÔºöÂá∫Âè£</li>
            <li>ÈªÑËâ≤ÔºöÈô∑Èò±ÔºàËß¶Á¢∞ÂêéÂõûÂà∞Ëµ∑ÁÇπÔºâ</li>
            <li>ÈùíËâ≤Ôºö‰º†ÈÄÅÈó®ÔºàÈöèÊú∫‰º†ÈÄÅÂà∞Âè¶‰∏Ä‰∏™‰º†ÈÄÅÈó®Ôºâ</li>
            <li>Á¥´Ëâ≤ÔºöÁßªÂä®Èô∑Èò±Ôºà‰ºöÁßªÂä®ÁöÑÂç±Èô©Âå∫ÂüüÔºâ</li>
            <li><span style="color: #f44336">Á∫¢Ëâ≤Èó™ÁÉÅË≠¶Âëä</span>ÔºöÁßªÂä®Êïå‰∫∫Ê≠£Âú®ËøΩÈÄê‰Ω†ÔºÅ</li>
            <li><span style="color: gold">ÈáëËâ≤</span>ÔºöÈí•ÂåôÔºàÁâπÊÆäÂÖ≥Âç°ÈúÄË¶ÅÈí•ÂåôÊâçËÉΩÂºÄÈó®Ôºâ</li>
            <li><span style="color: #8B4513">Ê£ïËâ≤</span>ÔºöÈó®ÔºàÈúÄË¶ÅÈí•ÂåôÊâçËÉΩÊâìÂºÄÔºâ</li>
        </ul>
        <p><strong>ÁâπÊÆäÂÖ≥Âç°Ôºö</strong></p>
        <ul>
            <li>Á¨¨30ÂÖ≥Âíå60ÂÖ≥‰∏∫Ëû∫ÊóãËø∑ÂÆ´Ôºå‰∏≠ÂøÉÊòØÂá∫Âè£ÔºåÂπ∂ÊúâÁßªÂä®Êïå‰∫∫ËøΩÈÄêÁé©ÂÆ∂ÔºÅ</li>
            <li>ÁâπÊÆäÂÖ≥Âç°ÈúÄË¶ÅÊâæÂà∞Èí•ÂåôÊâçËÉΩÂºÄÈó®ÔºåÊãøÂà∞Èí•ÂåôÂêéÈúÄË¶Å10ÁßíÂÄíËÆ°Êó∂ÊâçËÉΩÂºÄÈó®</li>
        </ul>
        <button onclick="document.getElementById('instructionsModal').classList.add('hidden')">ÂÖ≥Èó≠</button>
    </div>
    
    <!-- UIËÆæÁΩÆÈù¢Êùø -->
    <div id="uiSettingsModal" class="settings-modal hidden">
        <h2>UIËÆæÁΩÆ</h2>
        
        <div class="setting-group">
            <h3>ÊéßÂà∂Èù¢Êùø</h3>
            <label>
                <input type="checkbox" id="showControlsCheckbox"> ÊòæÁ§∫ÊéßÂà∂Èù¢Êùø
            </label>
            
            <div class="setting-row">
                <label>‰ΩçÁΩÆ:</label>
                <select id="controlsPosition">
                    <option value="bottom-left">Â∑¶‰∏ãËßí</option>
                    <option value="bottom-right">Âè≥‰∏ãËßí</option>
                    <option value="top-left">Â∑¶‰∏äËßí</option>
                    <option value="top-right">Âè≥‰∏äËßí</option>
                    <option value="custom">Ëá™ÂÆö‰πâÔºàÂÆûÈ™åÊÄßÂäüËÉΩÔºåÊãñÂä®ÁªøËâ≤Êù°ÁßªÂä®Ôºâ</option>
                </select>
            </div>
            
            <div class="setting-row">
                <label>Â§ßÂ∞è:</label>
                <input type="range" id="controlsSize" min="80" max="150" value="100">
            </div>
            
            <div class="setting-row">
                <label>ÈÄèÊòéÂ∫¶:</label>
                <input type="range" id="controlsOpacity" min="30" max="100" value="60">
            </div>
        </div>
        
        <div class="setting-group">
            <h3>Ê∏∏Êàè‰ø°ÊÅØ</h3>
            <label>
                <input type="checkbox" id="showGameInfoCheckbox" checked> ÊòæÁ§∫Ê∏∏Êàè‰ø°ÊÅØ
            </label>
            
            <div class="info-settings">
                <div class="setting-checkbox">
                    <input type="checkbox" id="showLevelInfo" checked>
                    <label for="showLevelInfo">ÂÖ≥Âç°‰ø°ÊÅØ</label>
                </div>
                <div class="setting-checkbox">
                    <input type="checkbox" id="showTimeInfo" checked>
                    <label for="showTimeInfo">Êó∂Èó¥‰ø°ÊÅØ</label>
                </div>
                <div class="setting-checkbox">
                    <input type="checkbox" id="showMoveInfo" checked>
                    <label for="showMoveInfo">ÁßªÂä®Ê¨°Êï∞</label>
                </div>
                <div class="setting-checkbox">
                    <input type="checkbox" id="showKeyInfo" checked>
                    <label for="showKeyInfo">Èí•ÂåôÁä∂ÊÄÅ</label>
                </div>
                <div class="setting-checkbox">
                    <input type="checkbox" id="showRoomInfo" checked>
                    <label for="showRoomInfo">ÊàøÈó¥‰ª£Á†Å</label>
                </div>
            </div>
        </div>
        <div class="setting-group">
            <h3>Â§ö‰∫∫Ê∏∏ÊàèËÆæÁΩÆ</h3>
            <label>
                <input type="checkbox" id="showPlayerListCheckbox" checked>
                ÊòæÁ§∫Áé©ÂÆ∂ÂàóË°®
            </label>
        </div>

        <div class="buttons">
            <button onclick="saveUISettings()">‰øùÂ≠ò</button>
            <button onclick="document.getElementById('uiSettingsModal').classList.add('hidden')">ÂèñÊ∂à</button>
            <button onclick="versionManager.showVersionModal()">Ê£ÄÊü•ÁâàÊú¨</button>
        </div>
    </div>
    
    <!-- ÂºÄÂèëËÄÖÊéßÂà∂Âè∞ -->
    <div id="console" class="console-container console-hidden">
        <div class="console-header">
            <div class="console-title">ÂºÄÂèëËÄÖÊéßÂà∂Âè∞</div>
            <button class="console-close" onclick="toggleConsole()">√ó</button>
        </div>
        <div class="console-output" id="consoleOutput">> Ê¨¢Ëøé‰ΩøÁî®ÂºÄÂèëËÄÖÊéßÂà∂Âè∞
> ËæìÂÖ• 'help' Êü•ÁúãÂèØÁî®ÂëΩ‰ª§</div>
        <div class="console-input-group">
            <div class="console-prompt">></div>
            <input type="text"class="console-input"id="consoleInput"placeholder="ËæìÂÖ•ÂëΩ‰ª§...">
        </div>
    </div>
    <div id="replayModal" class="modal hidden">
        <div class="modal-content" style="max-width:800px">
            <div class="modal-header">
                <h2>Ê∏∏ÊàèÂõûÊîæÂ∫ì</h2>
                <button class="close-btn" onclick="closeReplayModal()">√ó</button>
            </div>
            
            <div class="replay-controls">
                <div class="filter-group">
                    <select id="replayFilter">
                        <option value="all">ÂÖ®ÈÉ®ÂΩïÂÉè</option>
                        <option value="recent">ÊúÄËøë‰∏ÄÂë®</option>
                        <option value="best">ÊúÄ‰Ω≥ÈÄöÂÖ≥</option>
                    </select>
                </div>
            </div>
            
            <div class="replay-list" id="replayList">
                <!-- Âä®ÊÄÅÁîüÊàêÂΩïÂÉèÂàóË°® -->
            </div>
            
            <div class="player-container hidden" id="playerContainer">
                <div class="player-header">
                    <h3 id="replayTitle">ÂÖ≥Âç°1 - 2023-07-15</h3>
                    <button onclick="exitPlayer()">ËøîÂõûÂàóË°®</button>
                </div>
                
                <div class="video-container">
                    <canvas id="replayCanvas"></canvas>
                    
                    <div class="player-controls">
                        <button onclick="seekBack()">‚è™ 5Áßí</button>
                        <button onclick="togglePlay()" id="playBtn">‚ñ∂Ô∏è Êí≠Êîæ</button>
                        <button onclick="seekForward()">‚è© 5Áßí</button>
                        <span id="timeDisplay">00:00 / 02:30</span>
                        
                        <div class="speed-control">
                            <select id="playbackSpeed">
                                <option value="0.5">0.5√ó</option>
                                <option value="1" selected>1√ó</option>
                                <option value="2">2√ó</option>
                            </select>
                        </div>
                    </div>
                    
                    <div class="progress-container">
                        <progress id="replayProgress" value="0" max="100"></progress>
                    </div>
                </div>
            </div>
        </div>
    </div>
    <div id="event-notifications"></div>
    <div id="versionCheckModal" class="version-modal hidden">
        <div class="version-content">
            <h2>ÁâàÊú¨Êõ¥Êñ∞</h2>
            
            <div class="version-input-group">
                <label for="serverIpInput">ÊúçÂä°Âô®IPÂú∞ÂùÄ:</label>
                <input type="text" id="serverIpInput" placeholder="‰æã: 192.168.1.100:1683" value="localhost:1683">
                <div class="ip-tips">
                    <small>ÊèêÁ§∫: ÊúçÂä°Âô®IPÊ†ºÂºè‰∏∫ IP:Á´ØÂè£ÔºåÂ¶Ç 192.168.1.100:1683</small>
                </div>
            </div>
            
            <div id="versionStatus" class="version-status hidden">
                <h4>ÁâàÊú¨‰ø°ÊÅØ</h4>
                <div class="version-info">
                    <span class="version-label">ÂΩìÂâçÁâàÊú¨:</span>
                    <span class="version-value" id="currentVersion">1.8.3</span>
                </div>
                <div class="version-info">
                    <span class="version-label">ÊúçÂä°Âô®ÁâàÊú¨:</span>
                    <span class="version-value" id="serverVersion">Êú™Ê£ÄÊµã</span>
                </div>
                <div class="version-info">
                    <span class="version-label">Êõ¥Êñ∞Áä∂ÊÄÅ:</span>
                    <span class="version-value" id="updateStatus">
                        <span class="version-indicator checking"></span>Ê£ÄÊµã‰∏≠
                    </span>
                </div>
            </div>
            
            <div class="version-actions">
                <button id="connectServerBtn" onclick="connectToServer()">ËøûÊé•ÊúçÂä°Âô®</button>
                <button onclick="document.getElementById('versionCheckModal').classList.add('hidden')">ÂèñÊ∂à</button>
            </div>
            
            <div id="connectionStatus" class="connection-status-server hidden">
                <div class="spinner"></div>
                <span>ËøûÊé•‰∏≠...</span>
            </div>
            
            <div id="serverResponse" class="server-response hidden">
                <h3>ÊúçÂä°Âô®ÂìçÂ∫î:</h3>
                <div id="responseContent"></div>
            </div>
            
            <div id="updateProgress" class="update-progress" style="display: none;">
                <div class="progress-bar">
                    <div class="progress-fill" id="progressFill"></div>
                </div>
                <div class="progress-text" id="progressText">ÂáÜÂ§á‰∏ãËΩΩ...</div>
            </div>
            
            <div id="updateFiles" class="update-files" style="display: none;">
                <!-- Êñá‰ª∂ÂàóË°®Â∞ÜÈÄöËøáJSÂä®ÊÄÅÁîüÊàê -->
            </div>
        </div>
    </div>
<!-- ÊàøÈó¥ÊµèËßàÂô®ÁïåÈù¢ -->
<div id="roomBrowser" class="room-browser hidden">
    <div class="room-browser-container">
        <div class="browser-header">
            <h2 class="browser-title">üè† Â±ÄÂüüÁΩëÊàøÈó¥</h2>
            <button class="browser-close" onclick="closeRoomBrowser()">√ó</button>
        </div>
        
        <div class="browser-controls">
            <div class="search-box">
                <input type="text" id="roomSearch" class="search-input" 
                       placeholder="ÊêúÁ¥¢ÊàøÈó¥ÂêçÁß∞ÊàñÊàø‰∏ª..." 
                       onkeyup="filterRooms()">
                <span class="search-icon">üîç</span>
            </div>
            
            <div class="filter-group">
                <label for="roomFilter">Á≠õÈÄâÔºö</label>
                <select id="roomFilter" class="filter-select" onchange="filterRooms()">
                    <option value="all">ÊâÄÊúâÊàøÈó¥</option>
                    <option value="available">ÂèØÂä†ÂÖ•</option>
                    <option value="public">ÂÖ¨ÂºÄ</option>
                    <option value="private">ÁßÅÂØÜ</option>
                </select>
            </div>
            
            <button class="refresh-button" onclick="refreshRooms()">
                <span id="refreshIcon">üîÑ</span>
                <span>Âà∑Êñ∞</span>
            </button>
        </div>
        
        <div class="connection-status">
            <div class="status-dot" id="statusDot"></div>
            <span id="statusText">ËøûÊé•‰∏≠...</span>
        </div>
        
        <div class="room-list" id="roomList">
            <div class="loading-indicator">Ê≠£Âú®ÊêúÁ¥¢ÊàøÈó¥...</div>
        </div>
        
        <div class="browser-footer">
            <button class="menu-button" onclick="createRoom()">‚ûï ÂàõÂª∫Êñ∞ÊàøÈó¥</button>
            <button class="menu-button" onclick="closeRoomBrowser()">ËøîÂõû</button>
        </div>
    </div>
</div>
    <script>

const CLIENT_VERSION = "1.8.3";
const GAME_SERVER_URL = '/'; // ÊúçÂä°Âô®URLÔºåÊ†πÊçÆÂÆûÈôÖÊÉÖÂÜµ‰øÆÊîπ
async function checkServerVersion() {
    const button = event.target; // Ëé∑ÂèñË¢´ÁÇπÂáªÁöÑÊåâÈíÆÊú¨Ë∫´
    const originalText = button.textContent;
    
    // Á¶ÅÁî®ÊåâÈíÆÂπ∂ÊòæÁ§∫Âä†ËΩΩÁä∂ÊÄÅ
    button.disabled = true;
    button.textContent = 'Ê£ÄÊü•‰∏≠...';
    
    showNotification('Ê≠£Âú®Ê£ÄÊü•ÊúçÂä°Âô®ËøûÊé•...', 5000);

    try {
        const fullUrl = window.location.origin + GAME_SERVER_URL + 'api/version-check';

        // ===== ‰øÆÊîπÁÇπÔºöÂú® fetch ËØ∑Ê±Ç‰∏≠Ê∑ªÂä†Ëá™ÂÆö‰πâÂ§¥‰ø°ÊÅØ =====
        const response = await fetch(fullUrl, {
            method: 'GET', // GET ËØ∑Ê±Ç‰πüÂèØ‰ª•Â∏¶ headers
            headers: {
                // 'Content-Type': 'application/json', // GET ËØ∑Ê±ÇÈÄöÂ∏∏‰∏çÈúÄË¶ÅËøô‰∏™
                'Client-Version': CLIENT_VERSION // Ëá™ÂÆö‰πâÁöÑËØ∑Ê±ÇÂ§¥ÔºåÈîÆ‰∏∫ 'Client-Version', ÂÄº‰∏∫Êàë‰ª¨ÁöÑÁâàÊú¨Âè∑
            }
        });

        if (!response.ok) {
            throw new Error(`ÊúçÂä°Âô®ËøîÂõûÈîôËØØ: ${response.status} ${response.statusText}`);
        }

        const data = await response.json();
        console.log('ÊúçÂä°Âô®ÁâàÊú¨Ê£ÄÊü•ÁªìÊûú:', data);

        // Ê†πÊçÆËøîÂõûÁöÑÁä∂ÊÄÅÂ§ÑÁêÜÁªìÊûú
        switch(data.status) {
            case 'ok':
                showNotification(`‚úÖ ÁâàÊú¨Ê£ÄÊü•ÊàêÂäüÔºÅÂΩìÂâçÁâàÊú¨: ${data.version}`, 5000);
                break;
            case 'outdated':
                 // Â¶ÇÊûúÈúÄË¶ÅÔºåÂèØ‰ª•Âú®ËøôÈáåÊòæÁ§∫Êõ¥ËØ¶ÁªÜÁöÑÊúçÂä°Âô®ÁâàÊú¨
                 const serverVerMsg = data.version ? `\nÊúçÂä°Âô®ÊúÄÊñ∞ÁâàÊú¨: ${data.version}` : '';
                 const message = `‚ö†Ô∏è ÊèêÁ§∫: ÊÇ®ÁöÑÊ∏∏ÊàèÁâàÊú¨Â∑≤ËøáÊó∂ÔºÅ${serverVerMsg}\n\nËØ∑ËÅîÁ≥ªÁÆ°ÁêÜÂëòÊõ¥Êñ∞Ê∏∏Êàè„ÄÇ`;
                 alert(message);
                 showNotification('ËØ∑Á´ãÂç≥Êõ¥Êñ∞Ê∏∏Êàè‰ª•‰øùËØÅ‰ΩìÈ™åÔºÅ', 7000);
                 break;
            case 'warning':
                 showNotification(`‚ö†Ô∏è Ë≠¶Âëä: ‰Ω†ÁöÑÊ∏∏ÊàèÁâàÊú¨È´ò‰∫éÊúçÂä°Âô®ÁâàÊú¨${data.message || 'ÊúçÂä°Âô®ËøîÂõû‰∫ÜË≠¶Âëä‰ø°ÊÅØ'}`, 5000);
                 break;
            default:
                 showNotification(`‚ùå ÈîôËØØ: ${data.message || 'ÊúçÂä°Âô®ËøîÂõû‰∫ÜÈîôËØØ‰ø°ÊÅØ'}`, 5000);
        }

    } catch (error) {
        console.error('ÁâàÊú¨Ê£ÄÊü•ËØ∑Ê±ÇÂ§±Ë¥•:', error);
        showNotification(`‚ùå Êó†Ê≥ïËøûÊé•Âà∞ÊúçÂä°Âô®ÔºÅ\nËØ∑Á°Æ‰øùÊúçÂä°Âô®Ê≠£Âú®ËøêË°å‰∏îIPÂú∞ÂùÄÊ≠£Á°Æ„ÄÇ`, 6000);
    } finally {
        button.disabled = false;
        button.textContent = originalText;
    }
}
let teleportSelectionMode = false;
const modal = document.createElement('div');
window.addEventListener('load', function() {
    const levelContainer = document.getElementById('levelContainer');
    let startY = 0;
    let isScrolling = false;
    // Ëß¶Êë∏ÂºÄÂßã‰∫ã‰ª∂
    levelContainer.addEventListener('touchstart', function(e) {
        startY = e.touches[0].clientY;
        isScrolling = true;
    }, { passive: true }); // ‰ΩøÁî®passiveÊîπÂñÑÊªöÂä®ÊÄßËÉΩ
    // Ëß¶Êë∏ÁßªÂä®‰∫ã‰ª∂
    levelContainer.addEventListener('touchmove', function(e) {
        if (!isScrolling) return;
        
        const y = e.touches[0].clientY;
        const scrollTop = levelContainer.scrollTop;
        const scrollerHeight = levelContainer.scrollHeight;
        const containerHeight = levelContainer.clientHeight;
        
        // Èò≤Ê≠¢Âú®È°∂ÈÉ®‰∏ãÊãâÊàñÂ∫ïÈÉ®‰∏äÊãâ
        if ((scrollTop <= 0 && y > startY) || 
            (scrollTop >= scrollerHeight - containerHeight && y < startY)) {
            e.preventDefault();
        }
        
        startY = y;
    }, { passive: false });
    // Ëß¶Êë∏ÁªìÊùü‰∫ã‰ª∂
    levelContainer.addEventListener('touchend', function() {
        isScrolling = false;
    }, { passive: true });
});
        let singlePlayerGame = {
            canvas: null,
            ctx: null,
            maze: [],
            player: { x: 1, y: 1 },
            exit: { x: 0, y: 0 },
            cellSize: 30,
            startTime: 0,
            timerInterval: null,
            moveCount: 0,
            teleporters: [],
            movingTraps: [],
            movingEnemies: [],
            difficultySettings: [
                { size: 7, wallDensity: 0.3, traps: 0, movingTraps: 0, oneWayPaths: 0 },
                { size: 9, wallDensity: 0.35, traps: 1, movingTraps: 0, oneWayPaths: 0 },
                { size: 11, wallDensity: 0.4, traps: 2, movingTraps: 1, oneWayPaths: 0 },
                { size: 13, wallDensity: 0.45, traps: 4, movingTraps: 1, oneWayPaths: 1 },
                { size: 15, wallDensity: 0.5, traps: 6, movingTraps: 2, oneWayPaths: 1 },
                { size: 17, wallDensity: 0.55, traps: 8, movingTraps: 3, oneWayPaths: 2 },
                { size: 19, wallDensity: 0.6, traps: 10, movingTraps: 4, oneWayPaths: 3 },
                { size: 21, wallDensity: 0.65, traps: 12, movingTraps: 5, oneWayPaths: 4 },
                { size: 23, wallDensity: 0.7, traps: 14, movingTraps: 6, oneWayPaths: 5 },
                { size: 25, wallDensity: 0.75, traps: 16, movingTraps: 7, oneWayPaths: 6 }
            ],
            hasKey: false,
            doorPosition: null,
            keyPosition: null,
            isUnlocking: false,
            unlockTimeLeft: 0,
            unlockTimer: null
        };

        class Random {
            constructor(seed) {
                this.seed = seed;
            }
            
            next() {
                this.seed = (this.seed * 9301 + 49297) % 233280;
                return this.seed / 233280;
            }
        }
let consoleVisible = false;
let consoleHistory = [];
let historyIndex = -1;
        // Ê∏∏ÊàèÁä∂ÊÄÅÁÆ°ÁêÜ
        const gameState = {
            coins: 0, // Áé©ÂÆ∂ÊåÅÊúâÁöÑÈáëÂ∏ÅÊï∞Èáè
            currentScreen: 'mainMenu',
            unlockedLevel: parseInt(localStorage.getItem('unlockedLevel')) || 1,
            completedLevels: JSON.parse(localStorage.getItem('completedLevels')) || [],
            currentLevel: 1,
            playerName: 'Áé©ÂÆ∂' + Math.floor(Math.random() * 1000),
            unsolvableLevels: [15, 20, 25, 34, 35, 38, 40, 41, 49, 52, 55, 65,73], // Êó†Ëß£ÂÖ≥Âç°ÂàóË°®
            specialLevels: [20, 30, 60], // ÈúÄË¶ÅÈí•ÂåôÁöÑÁâπÊÆäÂÖ≥Âç°
            controlsReversed: false,
            playerData: {
                coins: 0,
            },
            multiplayer: {
                connected: false,
                peer: null,
                connections: {},
                players: {},
                currentPlayerId: null,
                roomCode: null,
                isHost: false,
                maze: [],
                startTime: 0,
                timerInterval: null,
                moveCount: 0,
                maxPlayers: 2, // ÈªòËÆ§ÊúÄÂ§ß‰∫∫Êï∞
                protectedPlayers: {}, // Âèó‰øùÊä§Áé©ÂÆ∂ÂàóË°®
                showPlayerList: true,
                unlockTimeLeft:10
            },
            devMode: false,
            uiSettings: JSON.parse(localStorage.getItem('uiSettings')) || {
                showControls: true,
                controlsPosition: 'bottom-left',
                controlsSize: 100,
                controlsOpacity: 60,
                showGameInfo: true,
                showLevelInfo: true,
                showTimeInfo: true,
                showMoveInfo: true,
                showKeyInfo: true,
                showRoomInfo: true,
                // Ê∑ªÂä†Ëá™ÂÆö‰πâ‰ΩçÁΩÆÁöÑxÂíåyÂùêÊ†á
                customX: null,
                customY: null
            },
            // Êñ∞ÂäüËÉΩÁä∂ÊÄÅ
            achievements: JSON.parse(localStorage.getItem('achievements')) || {
                allLevelsCompleted: false,
                multiplayerWins: 0,
                trapHits: 0
            },
            
            gameStats: JSON.parse(localStorage.getItem('gameStats')) || {
                timeChallengeBest: 0,
                puzzleLevelsCompleted: 0,
                totalLevelsCompleted: 0
            },
            
            settings: JSON.parse(localStorage.getItem('gameSettings')) || {
                autoSave: true
            },
            
            currentChallenge: null, // 'time' Êàñ 'puzzle'
            saveSlots: JSON.parse(localStorage.getItem('saveSlots')) || [{}, {}, {}],
            currentSaveSlot: 0,
            autoSave: false
            
        };
// Â¢ôÂ£ÅÊ∂àÂ§±Ê®°Âºè
let wallRemovalMode = false;
function startWallRemovalMode() {
    if (gameState.currentScreen !== 'singlePlayerGame') {
        showNotification('ËØ∑Âú®Âçï‰∫∫Ê∏∏Êàè‰∏≠‰ΩøÁî®Ê≠§ÈÅìÂÖ∑ÔºÅ');
        return;
    }
    wallRemovalMode = true;
    showNotification('Â¢ôÂ£ÅÊ∂àÂ§±Ê®°ÂºèÂ∑≤ÊøÄÊ¥ªÔºåÁÇπÂáªÂú∞Âõæ‰∏äÁöÑÂ¢ôÂ£ÅÊù•ÁßªÈô§ÂÆÉ„ÄÇ');
    document.getElementById('singlePlayerCanvas').style.cursor = 'crosshair';
}

// ÊâìÂºÄÂïÜÂ∫ó
function openShop() {
    document.getElementById('shopModal').classList.remove('hidden');
    // ÊâìÂºÄÂïÜÂ∫óÊó∂Êõ¥Êñ∞ÊâÄÊúâÊåâÈíÆÁöÑÁä∂ÊÄÅ
    updateShopButtons();
}

// ÂÖ≥Èó≠ÂïÜÂ∫ó
function closeShop() {
    document.getElementById('shopModal').classList.add('hidden');
}

// Êõ¥Êñ∞ÂïÜÂ∫óÊåâÈíÆÁöÑÂèØÁî®Áä∂ÊÄÅ
function updateShopButtons() {
    const buttons = document.querySelectorAll('.buy-btn');
    buttons.forEach(btn => {
        const itemKey = btn.parentElement.dataset.item;
        const item = SHOP_ITEMS[itemKey];
        if (item && gameState.coins < item.price) {
            btn.disabled = true;
            btn.textContent = 'ÈáëÂ∏Å‰∏çË∂≥';
        } else {
            btn.disabled = false;
            btn.textContent = 'Ë¥≠‰π∞';
        }
    });
}

// ÂïÜÂ∫óÁâ©ÂìÅÈÖçÁΩÆ
const SHOP_ITEMS = {
    'clear-events': { price: 20, name: 'ÊïàÊûúÊ∏ÖÈô§' },
    'remove-wall': { price: 15, name: 'Â¢ôÂ£ÅÊ∂àÂ§±' },
    'teleport': { price: 25, name: '‰º†ÈÄÅÈó®' }
};

// Ë¥≠‰π∞Áâ©ÂìÅ
function buyItem(itemKey) {
    const item = SHOP_ITEMS[itemKey];
    if (!item) return;

    if (gameState.coins >= item.price) {
        gameState.coins -= item.price;
        gameState.playerData.coins = gameState.coins;
        updateCoinDisplay();
        updateShopButtons(); // Êõ¥Êñ∞ÊåâÈíÆÁä∂ÊÄÅ
        showNotification(`ÊàêÂäüË¥≠‰π∞ ${item.name}ÔºÅ`);
        
        // ÈÅìÂÖ∑Ê∑ªÂä†Âà∞ËÉåÂåÖÔºåËøôÈáåÁÆÄÂåñÂ§ÑÁêÜÔºåÁõ¥Êé•ÊøÄÊ¥ªÊïàÊûú
        // Âú®ÂÆûÈôÖ‰∏≠Ôºå‰Ω†ÂèØËÉΩÈúÄË¶Å‰∏Ä‰∏™ËÉåÂåÖÁ≥ªÁªüÊù•Â≠òÂÇ®ÈÅìÂÖ∑
        activateItem(itemKey);
        
    } else {
        showNotification('ÈáëÂ∏Å‰∏çË∂≥ÔºåÊó†Ê≥ïË¥≠‰π∞ÔºÅ');
    }
}

// ÊøÄÊ¥ªÈÅìÂÖ∑ÊïàÊûú
function activateItem(itemKey) {
    switch(itemKey) {
        case 'clear-events':
            if (Object.keys(EventSystem.activeEvents).length > 0) {
                // Ë∞ÉÁî®ÊâÄÊúâ‰∫ã‰ª∂ÁöÑÊ∏ÖÁêÜÂáΩÊï∞
                Object.values(EventSystem.activeEvents).forEach(event => {
                    if (event.cleanup) event.cleanup();
                });
                EventSystem.activeEvents = {}; // Ê∏ÖÁ©∫‰∫ã‰ª∂
                showNotification('ÊâÄÊúâÈöèÊú∫‰∫ã‰ª∂Â∑≤Ê∏ÖÈô§ÔºÅ');
            } else {
                showNotification('ÂΩìÂâçÊ≤°ÊúâËß¶ÂèëÁöÑÈöèÊú∫‰∫ã‰ª∂„ÄÇ');
            }
            break;
            
        case 'remove-wall':
            startWallRemovalMode();
            break;
            
        case 'teleport':
            if (gameState.currentScreen === 'singlePlayerGame') {
                startTeleportSelectionMode();
            } else {
                showNotification('Ê≠§ÈÅìÂÖ∑‰ªÖÂú®Âçï‰∫∫Ê∏∏Êàè‰∏≠ÂèØÁî®ÔºÅ');
            }
            break;
    }
}

function createCoinDisplay() {
    const coinDisplay = document.createElement('div');
    coinDisplay.id = 'coinDisplay';
    coinDisplay.style.cssText = `
        position: fixed;
        top: 50px;
        right: 10px;
        background: rgba(0, 0, 0, 0.7);
        color: gold;
        padding: 10px 15px;
        border-radius: 8px;
        font-family: monospace;
        font-size: 18px;
        font-weight: bold;
        z-index: 100;
        box-shadow: 0 0 10px rgba(255, 215, 0, 0.5);
        display: none; /* ÈªòËÆ§ÈöêËóè */
    `;
    coinDisplay.innerHTML = `
        <span style="color: gold;">ÈáëÂ∏Å:</span>
        <span id="coinCount">0</span>
    `;
    document.body.appendChild(coinDisplay);
}

// ÊòæÁ§∫ÈáëÂ∏ÅUI
function showCoinDisplay() {
    document.getElementById('coinDisplay').style.display = 'block';
}

// ÈöêËóèÈáëÂ∏ÅUI
function hideCoinDisplay() {
    document.getElementById('coinDisplay').style.display = 'none';
}

// Êõ¥Êñ∞ÈáëÂ∏ÅÊï∞Èáè
function updateCoinDisplay() {
    document.getElementById('coinCount').textContent = gameState.coins;
}
function startTeleportSelectionMode(targetPlayerId = null) {
    // ‰øùÂ≠òÂΩìÂâçÊ∏∏ÊàèÁä∂ÊÄÅÂíåÁõÆÊ†áÁé©ÂÆ∂
    gameState.mapSelectionMode = true;
    gameState.mapSelectionTarget = targetPlayerId;
    
    // Ê∑ªÂä†Âú∞ÂõæÁÇπÂáª‰∫ã‰ª∂ÁõëÂê¨
    if (gameState.currentScreen === 'singlePlayerGame') {
        singlePlayerGame.canvas.addEventListener('click', handleMapClick);
        document.getElementById('consoleOutput').innerHTML += 
            '\nÂú∞ÂõæÈÄâÊã©Ê®°ÂºèÂ∑≤ÊøÄÊ¥ªÔºåÁÇπÂáªÂú∞Âõæ‰∏äÁöÑ‰ΩçÁΩÆËøõË°å‰º†ÈÄÅ';
            console.log('Âú∞ÂõæÈÄâÊã©Ê®°ÂºèÂ∑≤ÊøÄÊ¥ª');
            showNotification('Âú∞ÂõæÈÄâÊã©Ê®°ÂºèÂ∑≤ÊøÄÊ¥ªÔºåÁÇπÂáªÂú∞Âõæ‰∏äÁöÑ‰ΩçÁΩÆËøõË°å‰º†ÈÄÅ');
    } else {
        document.getElementById('consoleOutput').innerHTML += 
            '\nÂú∞ÂõæÈÄâÊã©Ê®°ÂºèÂè™ËÉΩÂú®Âçï‰∫∫Ê∏∏Êàè‰∏≠ËøõË°å';
        gameState.mapSelectionMode = false;
    }
}
// Ê∑ªÂä†ÈáëÂ∏Å
function addCoins(amount) {
    gameState.coins += amount;
    // ÂêåÊó∂‰πüÊõ¥Êñ∞ playerData ‰∏≠ÁöÑÔºå‰ª•‰æø‰∫é‰øùÂ≠ò
    gameState.playerData.coins = gameState.coins;
    updateCoinDisplay();
    
    // ÊòæÁ§∫Ëé∑ÂæóÈáëÂ∏ÅÁöÑÊèêÁ§∫
    showNotification(`Ëé∑Âæó ${amount} ‰∏™ÈáëÂ∏ÅÔºÅ`);
}
let serverVersion = "Êú™Áü•";
let needUpdate = false;
let connectedServer = null;

// ÁâàÊú¨ÁÆ°ÁêÜÂô®Á±ª
class VersionManager {
    constructor() {
        this.serverUrl = localStorage.getItem('serverUrl') || 'localhost:1683';
        this.lastCheck = localStorage.getItem('lastVersionCheck') || 0;
        this.isChecking = false;
        this.initialize();
    }

    initialize() {
        // Âª∂ËøüÂàùÂßãÂåñÔºåÁ°Æ‰øùDOMÂÖÉÁ¥†Â∑≤Â≠òÂú®
        setTimeout(() => {
            this.loadSavedVersionInfo();
            this.bindEvents();
            // ÊØèÂ∞èÊó∂Ëá™Âä®Ê£ÄÊü•‰∏ÄÊ¨°ÁâàÊú¨
            setInterval(() => this.autoCheckVersion(), 60 * 60 * 1000);
        }, 100);
    }

    loadSavedVersionInfo() {
        const savedServerVersion = localStorage.getItem('serverVersion');
        const savedNeedUpdate = localStorage.getItem('needUpdate');
        
        serverVersion = savedServerVersion || 'Êú™Áü•';
        needUpdate = savedNeedUpdate === 'true';
        
        this.updateVersionDisplay(needUpdate);
    }

    bindEvents() {
        // ÊúçÂä°Âô®IPËæìÂÖ•ÂèòÂåñÊó∂Ëá™Âä®‰øùÂ≠ò
        const serverIpInput = document.getElementById('serverIpInput');
        if (serverIpInput) {
            serverIpInput.addEventListener('input', (e) => {
                this.serverUrl = e.target.value;
                localStorage.setItem('serverUrl', this.serverUrl);
                this.clearVersionCache();
            });
        }
    }

    clearVersionCache() {
        localStorage.removeItem('serverVersion');
        localStorage.removeItem('needUpdate');
        localStorage.removeItem('lastVersionCheck');
        document.getElementById('serverVersion').textContent = 'Êú™Ê£ÄÊµã';
        document.getElementById('updateStatus').innerHTML = '<span class="version-indicator checking"></span>Ê£ÄÊµã‰∏≠';
    }

    async checkVersion() {
        if (this.isChecking) return;
        
        this.isChecking = true;
        try {
            await this._checkVersionInternal();
        } finally {
            this.isChecking = false;
        }
    }

    async _checkVersionInternal() {
        const btn = document.getElementById('connectServerBtn');
        const connectionStatus = document.getElementById('connectionStatus');
        const serverResponse = document.getElementById('serverResponse');
        
        if (!btn || !connectionStatus || !serverResponse) {
            console.error('ÁâàÊú¨Ê£ÄÊü•ÂÖÉÁ¥†Êú™ÊâæÂà∞');
            return;
        }
        
        try {
            btn.disabled = true;
            btn.textContent = 'Ê£ÄÊü•‰∏≠...';
            connectionStatus.classList.remove('hidden');
            serverResponse.classList.add('hidden');
            
            // ÊòæÁ§∫ÁâàÊú¨Áä∂ÊÄÅ
            const versionStatus = document.getElementById('versionStatus');
            if (versionStatus) {
                versionStatus.classList.remove('hidden');
            }
            
            // ÊòæÁ§∫Ê≠£Âú®Â∞ùËØïÁöÑURL
            connectionStatus.innerHTML = `
                <div class="spinner"></div>
                <span>ËøûÊé•‰∏≠: ${this.serverUrl}</span>
            `;
            
            // ÊûÑÂª∫ÂÆåÊï¥ÁöÑURL
            let baseUrl;
            if (this.serverUrl.startsWith('http://') || this.serverUrl.startsWith('https://')) {
                baseUrl = this.serverUrl;
            } else {
                baseUrl = `http://${this.serverUrl}`;
            }
            
            const checkUrl = `${baseUrl}/api/version-check`;
            
            console.log('Ê≠£Âú®Â∞ùËØïËøûÊé•:', checkUrl);
            
            // ÂàõÂª∫ AbortController Áî®‰∫éË∂ÖÊó∂ÊéßÂà∂
            const controller = new AbortController();
            const timeoutId = setTimeout(() => controller.abort(), 15000);
            
            const response = await fetch(checkUrl, {
                method: 'GET',
                headers: {
                    'Client-Version': CLIENT_VERSION,
                    'Accept': 'application/json',
                },
                signal: controller.signal
            });
            
            clearTimeout(timeoutId);
            
            console.log('ÂìçÂ∫îÁä∂ÊÄÅ:', response.status, response.statusText);
            
            if (!response.ok) {
                throw new Error(`HTTPÈîôËØØ! Áä∂ÊÄÅ: ${response.status} ${response.statusText}`);
                showNotification(`‚ùå ËøûÊé•Â§±Ë¥•: ${error.message}`, 'error');
                
            }
            
            const data = await response.json();
            console.log('ÊúçÂä°Âô®ÂìçÂ∫î:', data);
            
            // Êõ¥Êñ∞ÁâàÊú¨‰ø°ÊÅØÊòæÁ§∫
            this.updateVersionDisplayElements(data);
            
            // ‰øùÂ≠òÊ£ÄÊµãÁªìÊûú
            serverVersion = data.version || "?";
            needUpdate = data.status === 'outdated';
            
            localStorage.setItem('serverUrl', this.serverUrl);
            localStorage.setItem('serverVersion', serverVersion);
            localStorage.setItem('needUpdate', needUpdate);
            localStorage.setItem('lastVersionCheck', Date.now());
            // ÊòæÁ§∫ËØ¶ÁªÜÁöÑÊúçÂä°Âô®ÂìçÂ∫î
            const responseContent = document.getElementById('responseContent');
            if (responseContent) {
                responseContent.textContent = `ÂìçÂ∫îÊó∂Èó¥: ${new Date().toLocaleTimeString()}\n` +
                                            `ÊúçÂä°Âô®Âú∞ÂùÄ: ${baseUrl}\n` +
                                            `ÂÆ¢Êà∑Á´ØÁâàÊú¨: ${CLIENT_VERSION}\n` +
                                            `ÊúçÂä°Âô®ÁâàÊú¨: ${data.version }\n\n` +
                                            JSON.stringify(data, null, 2);
            }
            
            serverResponse.classList.remove('hidden');
            error = null;
            btn.textContent = 'ÈáçÊñ∞ËøûÊé•';
            // ËØ¶ÁªÜÁöÑÈîôËØØ‰ø°ÊÅØ
            let errorMessage = error.message;
            connectionStatus.classList.remove('error');
            
            if (error.name === 'AbortError') {
                errorMessage = 'ËøûÊé•Ë∂ÖÊó∂ÔºåËØ∑Ê£ÄÊü•ÁΩëÁªúÊàñÊúçÂä°Âô®Âú∞ÂùÄ';
            } else if (error.message.includes('Failed to fetch')) {
                errorMessage = 'Êó†Ê≥ïËøûÊé•Âà∞ÊúçÂä°Âô®ÔºåËØ∑Á°ÆËÆ§Ôºö\n1. ÊúçÂä°Âô®Âú∞ÂùÄÊòØÂê¶Ê≠£Á°Æ\n2. ÊúçÂä°Âô®ÊòØÂê¶Ê≠£Âú®ËøêË°å\n3. ÊòØÂê¶ÊúâÈò≤ÁÅ´Â¢ôÈòªÊ≠¢ËøûÊé•';
            } else if (error.message.includes('NetworkError')) {
                errorMessage = 'ÁΩëÁªúÈîôËØØÔºåËØ∑Ê£ÄÊü•ÁΩëÁªúËøûÊé•';
            } else if (error.message.includes('CORS')) {
                errorMessage = 'Ë∑®ÂüüËÆøÈóÆË¢´ÊãíÁªùÔºåËØ∑ÈÖçÁΩÆÊúçÂä°Âô®ÂÖÅËÆ∏Ë∑®ÂüüËÆøÈóÆ';
            }
            
            // ÊòæÁ§∫ËØ¶ÁªÜÁöÑÈîôËØØ‰ø°ÊÅØ
            connectionStatus.innerHTML = `
                <div class="error">ËøûÊé•Â§±Ë¥•</div>
                <div style="text-align: left; font-size: 12px; margin-top: 10px;">
                    <div>ÈîôËØØÁ±ªÂûã: ${error.name}</div>
                    <div>ÈîôËØØËØ¶ÊÉÖ: ${errorMessage}</div>
                    <div>Êó∂Èó¥: ${new Date().toLocaleTimeString()}</div>
                </div>
            `;
            connectionStatus.classList.add('error');
            
            // 3ÁßíÂêéÊÅ¢Â§çÂàùÂßãÁä∂ÊÄÅ
            setTimeout(() => {
                connectionStatus.classList.remove('error');
                connectionStatus.innerHTML = `
                    <div class="spinner"></div>
                    <span>ËøûÊé•‰∏≠...</span>
                `;
            }, 5000);
            
            btn.textContent = 'ÈáçËØï';
        } finally {
            btn.disabled = false;
        }
    }

    updateVersionDisplay(hasUpdate) {
        const updateStatus = document.getElementById('updateStatus');
        const updateBtn = document.getElementById('updateBtn');
        
        if (!updateStatus || !updateBtn) {
            console.log('ÁâàÊú¨Ê£ÄÊü•ÂÖÉÁ¥†Â∞öÊú™Âä†ËΩΩÔºåË∑≥ËøáUIÊõ¥Êñ∞');
            return;
        }

        // Ê∏ÖÈô§‰πãÂâçÁöÑÁ±ª
        updateStatus.className = 'update-status';
        
        if (hasUpdate) {
            updateStatus.innerHTML = '<span class="version-indicator outdated"></span>ÈúÄË¶ÅÊõ¥Êñ∞';
            updateBtn.style.display = 'block';
            updateBtn.textContent = `Á´ãÂç≥Êõ¥Êñ∞Âà∞ ${serverVersion}`;
        } else {
            updateStatus.innerHTML = '<span class="version-indicator up-to-date"></span>Â∑≤ÊòØÊúÄÊñ∞';
            updateBtn.style.display = 'none';
        }
    }

    updateVersionDisplayElements(data) {
        const currentVersionEl = document.getElementById('currentVersion');
        const serverVersionEl = document.getElementById('serverVersion');
        const updateStatusEl = document.getElementById('updateStatus');
        
        if (currentVersionEl) {
            currentVersionEl.textContent = CLIENT_VERSION;
        }
        
        if (serverVersionEl) {
            serverVersionEl.textContent = data.version || 'Êú™Áü•';
        }
        
        if (updateStatusEl) {
            updateStatusEl.className = 'update-status';
            
            if (data.status === 'ok') {
                updateStatusEl.innerHTML = '<span class="version-indicator up-to-date"></span>Â∑≤ÊòØÊúÄÊñ∞';
                updateStatusEl.classList.add('success');
            } else if (data.status === 'outdated') {
                updateStatusEl.innerHTML = '<span class="version-indicator outdated"></span>ÈúÄË¶ÅÊõ¥Êñ∞';
                updateStatusEl.classList.add('error');
            } else {
                updateStatusEl.innerHTML = '<span class="version-indicator checking"></span>Áä∂ÊÄÅÊú™Áü•';
                updateStatusEl.classList.add('checking');
            }
        }
    }

    autoCheckVersion() {
        const now = Date.now();
        const lastCheck = parseInt(localStorage.getItem('lastVersionCheck') || 0);
        
        // Â¶ÇÊûú‰∏äÊ¨°Ê£ÄÊü•Ë∂ÖËøá1Â∞èÊó∂ÔºåËá™Âä®Ê£ÄÊü•
        if (now - lastCheck > 60 * 60 * 1000) {
            console.log('Ëá™Âä®Ê£ÄÊü•ÁâàÊú¨Êõ¥Êñ∞...');
            this.checkVersion().catch(err => {
                console.log('Ëá™Âä®ÁâàÊú¨Ê£ÄÊü•Â§±Ë¥•:', err);
            });
        }
    }

    showVersionModal() {
        const modal = document.getElementById('versionCheckModal');
        if (!modal) {
            console.error('ÁâàÊú¨Ê£ÄÊü•Ê®°ÊÄÅÊ°Ü‰∏çÂ≠òÂú®');
            return;
        }
        
        modal.classList.remove('hidden');
        
        // Ëá™Âä®Â°´ÂÖÖ‰∏äÊ¨°‰øùÂ≠òÁöÑÊúçÂä°Âô®IP
        const serverIpInput = document.getElementById('serverIpInput');
        if (serverIpInput) {
            serverIpInput.value = this.serverUrl;
        }
    }
}

// ÂÖ®Â±ÄÂèòÈáè
versionManager = new VersionManager();

// ËøûÊé•ÊúçÂä°Âô®ÂáΩÊï∞
async function connectToServer() {
    versionManager.checkVersion();
}

// ÊµãËØïËøûÊé•ÂáΩÊï∞
async function testServerConnection() {
    const serverIpInput = document.getElementById('serverIpInput');
    if (!serverIpInput) {
        showNotification('ÁïåÈù¢ÂÖÉÁ¥†Êú™Âä†ËΩΩÂÆåÊàê', 'error');
        return;
    }
    
    const ipValue = serverIpInput.value.trim();
    if (!ipValue) {
        showNotification('ËØ∑ÂÖàËæìÂÖ•ÊúçÂä°Âô®Âú∞ÂùÄ', 'error');
        return;
    }
    
    showNotification('Ê≠£Âú®ÊµãËØïËøûÊé•...');
    
    try {
        // ÊµãËØïÂü∫Êú¨ËøûÊé•
        const testUrl = ipValue.startsWith('http') ? ipValue : `http://${ipValue}`;
        
        // ÊµãËØï 1: Âü∫Êú¨ËøûÊé•
        const response1 = await fetch(testUrl, {
            method: 'HEAD',
            timeout: 5000
        });
        
        showNotification('‚úì ÊúçÂä°Âô®ÂèØËÆøÈóÆ', 'success');
        
        // ÊµãËØï 2: API Á´ØÁÇπ
        const response2 = await fetch(`${testUrl}/api/version-check`, {
            method: 'OPTIONS',
            timeout: 5000
        });
        
        showNotification('‚úì API Á´ØÁÇπÂèØËÆøÈóÆ', 'success');
        
        // ÊµãËØï 3: Ë∑®Âüü
        const response3 = await fetch(`${testUrl}/api/version-check`, {
            method: 'GET',
            headers: {
                'Client-Version': CLIENT_VERSION
            },
            timeout: 5000
        });
        
        if (response3.ok) {
            showNotification('‚úì ËøûÊé•ÊµãËØïÊàêÂäü', 'success');
        } else {
            showNotification('‚ö† API Ë∞ÉÁî®Â§±Ë¥• (Áä∂ÊÄÅÁ†Å: ' + response3.status + ')', 'warning');
        }
        
    } catch (error) {
        console.error('ËøûÊé•ÊµãËØïÂ§±Ë¥•:', error);
        showNotification('‚úó ËøûÊé•ÊµãËØïÂ§±Ë¥•: ' + error.message, 'error');
    }
}

async function startUpdateProcess() {
    const versionModal = document.getElementById('versionCheckModal');
    const serverUrl = localStorage.getItem('serverUrl') || 'localhost:1683';
    const baseUrl = serverUrl.startsWith('http') ? serverUrl : `http://${serverUrl}`;
    
    showNotification('ÂºÄÂßãÊ£ÄÊü•Âπ∂ÂáÜÂ§áÊõ¥Êñ∞...', 'info');

    try {
        // ÊòæÁ§∫Ê®°ÊÄÅÊ°Ü‰ª•ÊòæÁ§∫ËøõÂ∫¶
        versionModal.classList.remove('hidden');

        // 1. Ëé∑ÂèñÊõ¥Êñ∞Êñá‰ª∂ÂàóË°®
        console.log('Ê≠£Âú®‰ªéÊúçÂä°Âô®Ëé∑ÂèñÊñá‰ª∂ÂàóË°®...');
        const response = await fetch(`${baseUrl}/api/update-list`, {
            headers: { 'Client-Version': CLIENT_VERSION }
        });
        const data = await response.json();
        
        if (data.status === 'ok') {
            showNotification('‚úÖ ‰Ω†Â∑≤ÁªèÊòØÊúÄÊñ∞ÁâàÊú¨ÔºÅ', 'success');
            return; // Â¶ÇÊûúÂ∑≤ÁªèÊòØÊúÄÊñ∞ÁöÑÔºåÂàôÈÄÄÂá∫
        }
        
        console.log('ÊúçÂä°Âô®ÈúÄË¶ÅÊõ¥Êñ∞ÁöÑÊñá‰ª∂:', data.files);
        displayUpdateFiles(data.files);

        // 2. Ê∏ÖÁ©∫‰πãÂâçÂèØËÉΩÂ≠òÂú®ÁöÑ‰∏¥Êó∂Êñá‰ª∂
        if ('caches' in window) {
            await caches.delete('game-update-cache');
        }

        // 3. ÂºÄÂßã‰∏ãËΩΩÊñá‰ª∂
        await downloadFiles(data.files, baseUrl);
        
        // 4. Êõ¥Êñ∞ÂÆåÊàê
        showNotification('üéâ ÊâÄÊúâÊñá‰ª∂‰∏ãËΩΩÂÆåÊàêÔºÅ', 'success');
        
        // 5. ËØ¢ÈóÆÊòØÂê¶Â∫îÁî®Êõ¥Êñ∞ÔºàÂà∑Êñ∞È°µÈù¢Ôºâ
        setTimeout(() => {
            if (confirm('Êõ¥Êñ∞Â∑≤‰∏ãËΩΩÂÆåÊàê„ÄÇÊòØÂê¶Âà∑Êñ∞È°µÈù¢‰ª•Â∫îÁî®Êõ¥Êñ∞Ôºü')) {
                // Ê∏ÖÁ©∫Service WorkerÁºìÂ≠òÁ≠âÔºàÂ¶ÇÊûú‰ΩøÁî®ÁöÑËØùÔºâ
                if ('serviceWorker' in navigator) {
                    navigator.serviceWorker.getRegistrations().then(registrations => {
                        registrations.forEach(registration => registration.unregister());
                    });
                }
                location.reload();
            }
        }, 1500);

    } catch (error) {
        console.error('Êõ¥Êñ∞ÊµÅÁ®ãÂ§±Ë¥•:', error);
        showNotification(`‚ùå Êõ¥Êñ∞Â§±Ë¥•: ${error.message}`, 'error');
    }
}

// Ëé∑ÂèñÊõ¥Êñ∞Êñá‰ª∂ÂàóË°®
async function getUpdateFileList() {
    const serverUrl = localStorage.getItem('serverUrl') || 'localhost:1683';
    const baseUrl = serverUrl.startsWith('http') ? serverUrl : `http://${serverUrl}`;
    
    // ÂÆûÈôÖÂ∫îÁî®‰∏≠Â∫îËØ•‰ªéÊúçÂä°Âô®Ëé∑ÂèñÔºåËøôÈáåÊ®°ÊãüÊñá‰ª∂ÂàóË°®
    const mockFileList = [
        { name: 'maze.html', size: 123456 },
        { name: 'maze.css', size: 23456 },
        { name: 'maze.js', size: 345678 },
        { name: 'images/icon.png', size: 5678 }
    ];
    
    return mockFileList;
}

// ÊòæÁ§∫Êõ¥Êñ∞Êñá‰ª∂ÂàóË°®
function displayUpdateFiles(fileList) {
    const updateFiles = document.getElementById('updateFiles');
    if (!updateFiles) return;
    
    updateFiles.innerHTML = '';
    updateFiles.style.display = 'block';
    
    fileList.forEach(file => {
        const fileItem = document.createElement('div');
        fileItem.className = 'file-item';
        fileItem.innerHTML = `
            <span class="file-name">${file.name}</span>
            <span class="file-size">${formatFileSize(file.size)}</span>
            <span class="file-status">Á≠âÂæÖ‰∏ãËΩΩ</span>
        `;
        updateFiles.appendChild(fileItem);
    });
}

// ÁúüÊ≠£‰∏ãËΩΩÊñá‰ª∂
async function downloadFiles(fileList, baseUrl) {
    const totalSize = fileList.reduce((sum, file) => sum + file.size, 0);
    let downloadedSize = 0;

    // ÊòæÁ§∫ËøõÂ∫¶Êù°
    const updateProgress = document.getElementById('updateProgress');
    const progressFill = document.getElementById('progressFill');
    const progressText = document.getElementById('progressText');

    if (updateProgress) {
        updateProgress.style.display = 'block';
    }

    for (const file of fileList) {
        try {
            console.log(`Ê≠£Âú®‰∏ãËΩΩÊñá‰ª∂: ${file.name}...`);
            
            // Êõ¥Êñ∞Áä∂ÊÄÅ
            updateFileStatus(file.name, '‰∏ãËΩΩ‰∏≠...');
            
            // ‰ªéÊúçÂä°Âô®‰∏ãËΩΩÊñá‰ª∂
            const downloadUrl = `${baseUrl}/api/download/${file.name}`;
            const response = await fetch(downloadUrl);

            if (!response.ok) {
                throw new Error(`‰∏ãËΩΩ ${file.name} Â§±Ë¥•: HTTP ${response.status}`);
            }

            // Ëé∑ÂèñÊñá‰ª∂ÂÜÖÂÆπ
            const blob = await response.blob();

            // „ÄêÂÖ≥ÈîÆ„ÄëÂàõÂª∫‰∏Ä‰∏™‰∏ãËΩΩÈìæÊé•Âπ∂Ëß¶ÂèëÁÇπÂáª
            const downloadLink = document.createElement('a');
            const url = URL.createObjectURL(blob);
            
            downloadLink.href = url;
            downloadLink.download = file.name; // ËÆæÁΩÆ‰∏ãËΩΩÁöÑÊñá‰ª∂Âêç
            document.body.appendChild(downloadLink);
            downloadLink.click();
            
            // Ê∏ÖÁêÜ
            setTimeout(() => {
                document.body.removeChild(downloadLink);
                URL.revokeObjectURL(url); // ÈáäÊîæÂÜÖÂ≠ò
            }, 100);

            // Ê®°Êãü‰∏ãËΩΩÂÆåÊàê‰ª•Êõ¥Êñ∞ËøõÂ∫¶
            await new Promise(resolve => setTimeout(resolve, 500)); // ÁªôÊµèËßàÂô®Êó∂Èó¥Â§ÑÁêÜ‰∏ãËΩΩ

            // Êõ¥Êñ∞ËøõÂ∫¶
            downloadedSize += file.size;
            const progress = (downloadedSize / totalSize) * 100;

            if (progressFill) {
                progressFill.style.width = `${progress}%`;
            }

            if (progressText) {
                progressText.textContent = `‰∏ãËΩΩËøõÂ∫¶: ${Math.round(progress)}% (${formatFileSize(downloadedSize)}/${formatFileSize(totalSize)})`;
            }

            // Êõ¥Êñ∞Áä∂ÊÄÅ
            updateFileStatus(file.name, '‰∏ãËΩΩÂÆåÊàê');

        } catch (error) {
            console.error(`‰∏ãËΩΩ ${file.name} Â§±Ë¥•:`, error);
            updateFileStatus(file.name, `‰∏ãËΩΩÂ§±Ë¥•: ${error.message}`);
            throw error; // ÊäõÂá∫ÈîôËØØÂÅúÊ≠¢Êï¥‰∏™ÊµÅÁ®ã
        }
    }
}

// Ê®°ÊãüÊñá‰ª∂‰∏ãËΩΩ
function simulateFileDownload(file) {
    return new Promise((resolve) => {
        // Ê®°Êãü‰∏ãËΩΩÊó∂Èó¥
        const downloadTime = (file.size / 102400); // ÂÅáËÆæÊØèÁßí‰∏ãËΩΩ100KB
        
        let progress = 0;
        const interval = setInterval(() => {
            progress += 10;
            if (progress >= 100) {
                clearInterval(interval);
                resolve();
            }
        }, downloadTime * 10);
    });
}

// Êõ¥Êñ∞Êñá‰ª∂Áä∂ÊÄÅ
function updateFileStatus(fileName, status) {
    const fileItems = document.querySelectorAll('.file-item');
    fileItems.forEach(item => {
        if (item.querySelector('.file-name').textContent === fileName) {
            const statusEl = item.querySelector('.file-status');
            statusEl.textContent = status;
            
            if (status === '‰∏ãËΩΩÂÆåÊàê') {
                statusEl.style.color = '#4CAF50';
            } else if (status === '‰∏ãËΩΩÂ§±Ë¥•') {
                statusEl.style.color = '#f44336';
            } else {
                statusEl.style.color = '#FF9800';
            }
        }
    });
}

// Ê†ºÂºèÂåñÊñá‰ª∂Â§ßÂ∞è
function formatFileSize(bytes) {
    if (bytes === 0) return '0 Bytes';
    
    const k = 1024;
    const sizes = ['Bytes', 'KB', 'MB', 'GB'];
    const i = Math.floor(Math.log(bytes) / Math.log(k));
    
    return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
}


// Âú®È°µÈù¢Âä†ËΩΩÊó∂ÂàùÂßãÂåñÈáëÂ∏ÅÊòæÁ§∫
window.addEventListener('load', () => {
    createCoinDisplay();
    // ‰ªé localStorage Âä†ËΩΩÈáëÂ∏ÅÔºåÂ¶ÇÊûúÊ≤°ÊúâÂàôÂàùÂßãÂåñ‰∏∫0
    gameState.coins = parseInt(localStorage.getItem('playerCoins')) || 0;
    gameState.playerData.coins = gameState.coins;
    updateCoinDisplay();
    // ÂàùÂßãÂåñÂ§ö‰∫∫Ê∏∏ÊàèËÆæÁΩÆ
    initMultiplayerSetup();
    // ÂàùÂßãÂåñÊàøÈó¥ÁÆ°ÁêÜÂô®
    roomManager.init();
});

const EventSystem = {
  events: [],
  activeEvents: {},
  cooldowns: {},

  init() {
    setInterval(() => this.checkEvents(), 5000); // ÊØè5ÁßíÊ£ÄÊü•‰∏ÄÊ¨°
  },

  register(event) {
    this.events.push(event);
  },

  checkEvents() {
    if (gameState.currentScreen !== 'singlePlayerGame') return;

    this.events.forEach(event => {
      if (this.shouldTrigger(event)) {
        this.trigger(event);
      }
    });
  },

  shouldTrigger(event) {
    // Ê£ÄÊü•ÂÜ∑Âç¥
    if (this.cooldowns[event.id] > Date.now()) return false;
    // Ê£ÄÊü•Ê¶ÇÁéá
    return Math.random() < (event.probability || 0.1);
  },

  trigger(event) {
    // ÊâßË°åÊïàÊûú
    const cleanup = event.effect();
    
    // ËÆæÁΩÆÂÜ∑Âç¥
    this.cooldowns[event.id] = Date.now() + (event.cooldown || 60000);
    if (!event || typeof event.effect !== 'function') {
        console.error('ÈîôËØØÁöÑ‰∫ã‰ª∂:', event);
        return; // Áõ¥Êé•ËøîÂõûÔºåÈò≤Ê≠¢Êä•Èîô
    }
    // Â≠òÂÇ®Ê∏ÖÁêÜÂáΩÊï∞
    if (cleanup) {
      this.activeEvents[event.id] = {
        endTime: Date.now() + (event.duration || 10000),
        cleanup
      };
    }

    // ÊòæÁ§∫ÈÄöÁü•
    this.showNotification(event.name, event.description);
  },

  showNotification(title, text) {
    const div = document.createElement('div');
    div.className = 'event-notification';
    div.innerHTML = `<b>${title}</b>: ${text}`;
    document.getElementById('event-notifications').appendChild(div);
    setTimeout(() => div.remove(), 5000);
  },

  update() {
    const now = Date.now();
    Object.keys(this.activeEvents).forEach(id => {
      if (now >= this.activeEvents[id].endTime) {
        this.activeEvents[id].cleanup();
        delete this.activeEvents[id];
      }
    });
  },
  triggerById(eventId) {
    const event = this.events.find(e => 
    e.id.toLowerCase() === eventId.toLowerCase()
    );
    if (!event) {
      console.error(`‰∫ã‰ª∂‰∏çÂ≠òÂú®: ${eventId}`);
      return;
    }
    // ÊâßË°åÊïàÊûú
    const cleanup = event.effect();
    
    // ËÆæÁΩÆÂÜ∑Âç¥ÔºàÂç≥‰ΩøÂº∫Âà∂Ëß¶Âèë‰πü‰ªçÁÑ∂Â∫îÁî®ÂÜ∑Âç¥Ôºâ
    this.cooldowns[event.id] = Date.now() + (event.cooldown || 60000);
    
    // Â≠òÂÇ®Ê∏ÖÁêÜÂáΩÊï∞
    if (cleanup) {
      this.activeEvents[event.id] = {
        endTime: Date.now() + (event.duration || 10000),
        cleanup
      };
    }
    // ÊòæÁ§∫ÈÄöÁü•
    this.showNotification(event.name, `[Âº∫Âà∂Ëß¶Âèë] ${event.description}`);
    }
}
// ÂàùÂßãÂåñ
EventSystem.init();
// ÊéßÂà∂ÂèçËΩ¨‰∫ã‰ª∂
// ‰øÆÊîπÂêéÁöÑÂèçËΩ¨ÊéßÂà∂‰∫ã‰ª∂
EventSystem.register({
  id: 'reverse-controls',
  name: 'ÊñπÂêëÊ∑∑‰π±',
  description: 'ÊéßÂà∂ÊñπÂêëÊöÇÊó∂ÂèçËΩ¨!ÊåÅÁª≠Êó∂Èó¥: 20Áßí',
  probability: 0.1,  // 10%Ê¶ÇÁéáËß¶Âèë
  cooldown: 30000,   // 30ÁßíÂÜ∑Âç¥
  effect: () => {
    const originalHandler = handleSinglePlayerKeyDown;
    
    // ÊòæÁ§∫ÊèêÁ§∫
    const notification = document.createElement('div');
    notification.className = 'event-notification';
    notification.innerHTML = '<b>ÊñπÂêëÊ∑∑‰π±ÔºÅ</b> ÊñπÂêëÊéßÂà∂Â∑≤ÊöÇÊó∂ÂèçËΩ¨';
    document.getElementById('event-notifications').appendChild(notification);
    setTimeout(() => notification.remove(), 5000);
    
    // ÂèçËΩ¨ÊéßÂà∂Áä∂ÊÄÅ
    gameState.controlsReversed = true;
    
    // 50ÁßíÂêéËá™Âä®ÊÅ¢Â§ç
    setTimeout(() => {
      gameState.controlsReversed = false;
      const endNotification = document.createElement('div');
      endNotification.className = 'event-notification';
      endNotification.innerHTML = '<b>ÊñπÂêëÊÅ¢Â§çÊ≠£Â∏∏</b>';
      document.getElementById('event-notifications').appendChild(endNotification);
      setTimeout(() => endNotification.remove(), 3000);
    }, 20000);

    return () => {
      
      gameState.controlsReversed = false;
    };
  }
});

// Ëß£Ë∞úÊ®°ÂºèÁä∂ÊÄÅ
gameState.puzzleMode = {
    buttons: [], // ÊåâÈíÆ‰ΩçÁΩÆÊï∞ÁªÑ [{x, y, id, pressed, color}]
    correctSequence: [], // Ê≠£Á°ÆÈ°∫Â∫è [buttonId1, buttonId2, ...]
    currentSequence: [], // ÂΩìÂâçÁé©ÂÆ∂Êåâ‰∏ãÁöÑÈ°∫Â∫è
    doorPosition: null, // Â§ßÈó®‰ΩçÁΩÆ
    doorOpened: false // Â§ßÈó®ÊòØÂê¶Â∑≤ÊâìÂºÄ
};

// Ê£ÄÊü•ÊòØÂê¶Èù†ËøëÁé©ÂÆ∂Ëµ∑ÁÇπ
function isNearPlayer(x, y) {
    return Math.abs(x - 1) <= 2 && Math.abs(y - 1) <= 2;
}

        // Â∫îÁî®UIËÆæÁΩÆ
        function applyUISettings() {
            const settings = gameState.uiSettings;
            
            // Â∫îÁî®ÊéßÂà∂Èù¢ÊùøËÆæÁΩÆ
            const controlsPanel = document.getElementById('singlePlayerControls') || 
                                 document.getElementById('multiplayerControls');
            
            if (controlsPanel) {
                controlsPanel.classList.toggle('hidden', !settings.showControls);
                
                // ËÆæÁΩÆ‰ΩçÁΩÆ
                controlsPanel.style.position = 'fixed';
                controlsPanel.style.left = '';
                controlsPanel.style.right = '';
                controlsPanel.style.top = '';
                controlsPanel.style.bottom = '';
                
                if (settings.controlsPosition === 'custom' && settings.customX !== null && settings.customY !== null) {
                    controlsPanel.style.left = settings.customX + 'px';
                    controlsPanel.style.top = settings.customY + 'px';
                } else {
                    switch(settings.controlsPosition) {
                        case 'bottom-left':
                            controlsPanel.style.left = '20px';
                            controlsPanel.style.bottom = '20px';
                            break;
                        case 'bottom-right':
                            controlsPanel.style.right = '20px';
                            controlsPanel.style.bottom = '20px';
                            break;
                        case 'top-left':
                            controlsPanel.style.left = '20px';
                            controlsPanel.style.top = '20px';
                            break;
                        case 'top-right':
                            controlsPanel.style.right = '20px';
                            controlsPanel.style.top = '20px';
                            break;
                    }
                }
            }
            
            // Â∫îÁî®Ê∏∏Êàè‰ø°ÊÅØËÆæÁΩÆ
            const gameInfo = document.getElementById('gameInfo');
            const multiplayerGameInfo = document.getElementById('multiplayerGameInfo');
            
            if (gameInfo) {
                gameInfo.style.display = settings.showGameInfo ? 'flex' : 'none';
                // ÈöêËóè/ÊòæÁ§∫ÂêÑ‰∏™‰ø°ÊÅØÈ°π
                const infoItems = ['levelDisplay', 'timeDisplay', 'moveCount', 'keyStatus'];
                infoItems.forEach(id => {
                    const element = document.getElementById(id);
                    if (element) {
                        element.style.display = settings[`show${id.charAt(0).toUpperCase() + id.slice(1).replace('Display', 'Info').replace('Count', 'Info')}`] ? 'flex' : 'none';
                    }
                });
            }
            
            if (multiplayerGameInfo) {
                multiplayerGameInfo.style.display = settings.showGameInfo ? 'flex' : 'none';
                // ÈöêËóè/ÊòæÁ§∫ÂêÑ‰∏™‰ø°ÊÅØÈ°π
                const multiplayerInfoItems = ['multiplayerRoomCode', 'multiplayerTimeDisplay', 'multiplayerMoveCount', 'multiplayerPlayerCount'];
                multiplayerInfoItems.forEach(id => {
                    const element = document.getElementById(id);
                    if (element) {
                        element.style.display = settings[`show${id.includes('Room') ? 'Room' : id.includes('Time') ? 'Time' : id.includes('Move') ? 'Move' : 'Room'}Info`] ? 'flex' : 'none';
                    }
                });
            }
            
            // Â∫îÁî®Áé©ÂÆ∂ÂàóË°®ËÆæÁΩÆ
            const playerList = document.getElementById('playerList');
            if (playerList) {
                playerList.style.display = gameState.uiSettings.showPlayerList ? 'block' : 'none';
            }
        } 
        function showScreen(screenId) {
            // ÈöêËóèÊâÄÊúâÂ±èÂπï
            const screens = [
                'mainMenu', 'singlePlayerLevelSelect', 'singlePlayerGame', 
                'singlePlayerComplete', 'multiplayerSetup', 'multiplayerGame',
                'achievementsScreen', 'moreChallengesScreen'
            ];
            
            screens.forEach(id => {
                const element = document.getElementById(id);
                if (element) {
                    element.classList.add('hidden');
                }
            });
            
            // ÊòæÁ§∫ËØ∑Ê±ÇÁöÑÂ±èÂπï
            const targetScreen = document.getElementById(screenId);
            if (targetScreen) {
                targetScreen.classList.remove('hidden');
            }
            
            gameState.currentScreen = screenId;
            // ÊòæÁ§∫/ÈöêËóèÈáëÂ∏ÅUI
            if (screenId === 'singlePlayerGame' || screenId === 'multiplayerGame') {
                showCoinDisplay();
            } else {
                hideCoinDisplay();
            }
            // ÊâßË°åÂ±èÂπïÁâπÂÆöÁöÑÂàùÂßãÂåñ
            switch(screenId) {
                case 'singlePlayerLevelSelect':
                    generateLevelButtons();
                    break;
                case 'singlePlayerGame':
                    initSinglePlayerGame();
                    EventSystem.init();
                    break;
                case 'multiplayerSetup':
                    document.getElementById('playerName').value = gameState.playerName;
                    break;
                case 'multiplayerGame':
                    break;
                case 'moreChallengesScreen':
                    updateChallengesStats();
                    break;
                case 'achievementsScreen':
                    updateAchievementProgress();
                    break;
            }

            // ÊòæÁ§∫/ÈöêËóèÊéßÂà∂Èù¢Êùø
            const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
            const singlePlayerControls = document.getElementById('singlePlayerControls');
            const multiplayerControls = document.getElementById('multiplayerControls');
            
            if (singlePlayerControls) {
                singlePlayerControls.classList.toggle('hidden', screenId !== 'singlePlayerGame' || !isMobile);
            }
            if (multiplayerControls) {
                multiplayerControls.classList.toggle('hidden', screenId !== 'multiplayerGame' || !isMobile);
            }
            
            // Â∫îÁî®UIËÆæÁΩÆ
            applyUISettings();
        }     
        // ÊòæÁ§∫Ê∏∏ÊàèËØ¥Êòé
        function showInstructions() {
            document.getElementById('instructionsModal').classList.remove('hidden');
        }
        
        // ÊòæÁ§∫UIËÆæÁΩÆÈù¢Êùø
        function showUISettings() {
            // Âä†ËΩΩ‰øùÂ≠òÁöÑËÆæÁΩÆ
            const settings = gameState.uiSettings;
            
            document.getElementById('showControlsCheckbox').checked = settings.showControls;
            document.getElementById('controlsPosition').value = settings.controlsPosition;
            document.getElementById('controlsSize').value = settings.controlsSize;
            document.getElementById('controlsOpacity').value = settings.controlsOpacity;
            
            document.getElementById('showGameInfoCheckbox').checked = settings.showGameInfo;
            document.getElementById('showLevelInfo').checked = settings.showLevelInfo;
            document.getElementById('showTimeInfo').checked = settings.showTimeInfo;
            document.getElementById('showMoveInfo').checked = settings.showMoveInfo;
            document.getElementById('showKeyInfo').checked = settings.showKeyInfo;
            document.getElementById('showRoomInfo').checked = settings.showRoomInfo;
            
            document.getElementById('uiSettingsModal').classList.remove('hidden');
        }
        
        // ‰øùÂ≠òUIËÆæÁΩÆ
        function saveUISettings() {
            gameState.uiSettings = {
                showControls: document.getElementById('showControlsCheckbox').checked,
                controlsPosition: document.getElementById('controlsPosition').value,
                controlsSize: parseInt(document.getElementById('controlsSize').value),
                controlsOpacity: parseInt(document.getElementById('controlsOpacity').value),
                showGameInfo: document.getElementById('showGameInfoCheckbox').checked,
                showLevelInfo: document.getElementById('showLevelInfo').checked,
                showTimeInfo: document.getElementById('showTimeInfo').checked,
                showMoveInfo: document.getElementById('showMoveInfo').checked,
                showKeyInfo: document.getElementById('showKeyInfo').checked,
                showRoomInfo: document.getElementById('showRoomInfo').checked,
                showPlayerList: document.getElementById('showPlayerListCheckbox').checked,
                // ‰øùÁïôËá™ÂÆö‰πâ‰ΩçÁΩÆÂùêÊ†á
                customX: gameState.uiSettings.customX,
                customY: gameState.uiSettings.customY
            };
            localStorage.setItem('uiSettings', JSON.stringify(gameState.uiSettings));
            document.getElementById('uiSettingsModal').classList.add('hidden');
            applyUISettings();
        }

// ÊàøÈó¥ÁÆ°ÁêÜÂô®Á±ª
class RoomManager {
    constructor() {
        this.rooms = new Map();
        this.serverUrl = localStorage.getItem('serverUrl') || 'localhost:1683';
        this.pollInterval = null;
        this.autoRefresh = true;
        this.sortBy = 'created';
        this.sortOrder = 'desc';
        this.connected = false;
    }

    // ÂàùÂßãÂåñÊàøÈó¥ÁÆ°ÁêÜÂô®
    init() {
        this.checkServerConnection();
        
        // Â¶ÇÊûúËá™Âä®Âà∑Êñ∞ÔºåÂêØÂä®ËΩÆËØ¢
        if (this.autoRefresh) {
            this.startPolling();
        }
    }
    // Ê∑ªÂä†ÂàõÂª∫Êú¨Âú∞ÊàøÈó¥ÁöÑÊñπÊ≥ï
    async createLocalRoom() {
        try {
            const playerName = document.getElementById('playerName')?.value.trim() || 'Áé©ÂÆ∂';
            const maxPlayers = parseInt(document.getElementById('maxPlayers')?.value) || 4;
            
            // ÁîüÊàêÊú¨Âú∞ÊàøÈó¥ID
            const roomId = `LOCAL-${Date.now()}`;
            
            // ÂàõÂª∫Êú¨Âú∞Ê∏∏ÊàèÁä∂ÊÄÅ
            gameState.playerName = playerName;
            gameState.multiplayer.isHost = true;
            gameState.multiplayer.roomCode = roomId;
            gameState.multiplayer.maxPlayers = maxPlayers;
            
            // ÂàùÂßãÂåñÊú¨Âú∞Â§ö‰∫∫Ê∏∏Êàè
            showNotification('Êú¨Âú∞ÊàøÈó¥ÂàõÂª∫ÊàêÂäüÔºÅ', 'success');
            
            // Á´ãÂç≥ÂºÄÂßãÊú¨Âú∞Ê∏∏Êàè
            setTimeout(() => {
                showScreen('multiplayerGame');
                startMultiplayerGame();
            }, 1000);
            
        } catch (error) {
            console.error('ÂàõÂª∫Êú¨Âú∞ÊàøÈó¥Â§±Ë¥•:', error);
            showNotification(`ÂàõÂª∫ÊàøÈó¥Â§±Ë¥•: ${error.message}`, 'error');
        }
    }

    getApiUrl(endpoint) {
        return `http://${this.serverUrl}/api/${endpoint}`;
        console.log(`getapiÂú∞ÂùÄ: http://${this.serverUrl}/api/${endpoint}`);
    }
    // ÂàõÂª∫Êñ∞ÊàøÈó¥ÔºàÊ∑ªÂä†ÁöÑÊñπÊ≥ïÔºâ
    async createRoom(roomData) {
        try {
            // ÊûÑÂª∫ËØ∑Ê±Ç‰Ωì
            const requestBody = {
                playerName: roomData.playerName,
                maxPlayers: roomData.maxPlayers || 4,
                roomName: roomData.roomName || `ÊàøÈó¥_${Date.now()}`,
                isPrivate: roomData.isPrivate || false
            };
            
            // ÂèëÈÄÅÂàõÂª∫ÊàøÈó¥ËØ∑Ê±Ç
            const response = await fetch(this.getApiUrl('/api/create-room'), {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify(requestBody)
            });

            if (!response.ok) {
                throw new Error(`HTTP ${response.status}`);
            }

            const result = await response.json();
            
            if (result.success) {
                // ÂàõÂª∫ÊàêÂäüÔºåÊòæÁ§∫ÊàêÂäü‰ø°ÊÅØ
                showNotification(`ÊàøÈó¥ÂàõÂª∫ÊàêÂäüÔºÅÊàøÈó¥Á†Å: ${result.roomId}`, 'success');
                
                // Â¶ÇÊûúÈúÄË¶ÅÔºåÂèØ‰ª•Á´ãÂç≥Âä†ÂÖ•ÊàøÈó¥
                // Âú®ËøôÈáåÊàë‰ª¨Âè™ÊòØËøîÂõûÊàøÈó¥IDÔºåËÆ©Ë∞ÉÁî®ËÄÖÂÜ≥ÂÆöÊòØÂê¶Âä†ÂÖ•
                return result.roomId;
            } else {
                throw new Error(result.message || 'ÂàõÂª∫ÊàøÈó¥Â§±Ë¥•');
            }
        } catch (error) {
            console.error('ÂàõÂª∫ÊàøÈó¥Â§±Ë¥•:', error);
            showNotification(`ÂàõÂª∫ÊàøÈó¥Â§±Ë¥•: ${error.message}`, 'error');
            return null;
        }
    }

    // Ê£ÄÊü•ÊúçÂä°Âô®ËøûÊé•Áä∂ÊÄÅÔºàÊ∑ªÂä†ÁöÑÊñπÊ≥ïÔºâ
    async checkServerConnection() {
        try {
            const statusDot = document.getElementById('statusDot');
            const statusText = document.getElementById('statusText');
            
            // Êõ¥Êñ∞UIÁä∂ÊÄÅ
            if (statusDot) statusDot.className = 'status-dot';
            if (statusText) statusText.textContent = 'Ê£ÄÊµã‰∏≠...';
            
            // Â∞ùËØïËøûÊé•ÊúçÂä°Âô®
            const response = await fetch(this.getApiUrl('/api/server-status'), {
                timeout: 5000
            });
            
            if (response.ok) {
                const data = await response.json();
                this.connected = true;
                
                // Êõ¥Êñ∞ËøûÊé•Áä∂ÊÄÅUI
                if (statusDot) statusDot.className = 'status-dot';
                if (statusText) statusText.textContent = 'Â∑≤ËøûÊé•';
                
                console.log('ÊúçÂä°Âô®ËøûÊé•Ê≠£Â∏∏');
            } else {
                throw new Error(`HTTP ${response.status}`);
            }
            
        } catch (error) {
            this.connected = false;
            
            // Êõ¥Êñ∞ËøûÊé•Áä∂ÊÄÅUI
            if (statusDot) statusDot.className = 'status-dot error';
            if (statusText) statusText.textContent = 'ËøûÊé•Â§±Ë¥•';
            
            console.error('ÊúçÂä°Âô®ËøûÊé•Â§±Ë¥•:', error);
        }
    }

    // ‰øÆÊîπ startPolling ÊñπÊ≥ïÔºåÂè™Âú®ËøûÊé•ÊàêÂäüÊó∂ËΩÆËØ¢
    startPolling() {
        if (this.pollInterval) {
            clearInterval(this.pollInterval);
        }
        
        // ÂÖàÊ£ÄÊü•ËøûÊé•Áä∂ÊÄÅ
        this.checkServerConnection().then(() => {
            // Âè™ÊúâÂú®ËøûÊé•ÊàêÂäüÊó∂ÊâçÂêØÂä®ËΩÆËØ¢
            if (this.connected && this.autoRefresh) {
                this.pollInterval = setInterval(async () => {
                    if (this.autoRefresh && this.connected) {
                        await this.fetchRooms();
                    }
                }, 5000); // ÊØè5ÁßíÊõ¥Êñ∞‰∏ÄÊ¨°
            }
        });
    }


    // ÂÅúÊ≠¢ËΩÆËØ¢
    stopPolling() {
        if (this.pollInterval) {
            clearInterval(this.pollInterval);
            this.pollInterval = null;
        }
    }

    async fetchRooms() {
        const roomList = document.getElementById('roomList');
        
        try {
            // Ê£ÄÊü• serverUrl ÊòØÂê¶ÈÖçÁΩÆ
            if (!this.serverUrl) {
                this.showError('ËØ∑ÂÖàÂú®Â§ö‰∫∫Ê∏∏ÊàèËÆæÁΩÆ‰∏≠ÈÖçÁΩÆÊúçÂä°Âô®IPÂú∞ÂùÄ');
                return;
            }
            
            // ÊòæÁ§∫Âä†ËΩΩÁä∂ÊÄÅ
            if (roomList) {
                roomList.innerHTML = '<div class="loading-indicator">Ê≠£Âú®ÊêúÁ¥¢ÊàøÈó¥...</div>';
            }
            
            // ÊûÑÂª∫ÂÆåÊï¥ÁöÑURLÂπ∂Ê∑ªÂä†Êó∂Èó¥Êà≥Èò≤Ê≠¢ÁºìÂ≠ò
            const url = this.getApiUrl('/api/rooms') + '?t=' + Date.now();
            
            // ËÆæÁΩÆËØ∑Ê±ÇË∂ÖÊó∂
            const controller = new AbortController();
            const timeoutId = setTimeout(() => controller.abort(), 10000); // 10ÁßíË∂ÖÊó∂
            
            console.log('Ê≠£Âú®ËØ∑Ê±ÇÊàøÈó¥ÂàóË°®:', url);
            
            const response = await fetch(url, {
                method: 'GET',
                headers: {
                    'Content-Type': 'application/json',
                },
                signal: controller.signal
            });
            
            clearTimeout(timeoutId);
            
            console.log('ÊúçÂä°Âô®ÂìçÂ∫îÁä∂ÊÄÅ:', response.status, response.statusText);
            
            if (!response.ok) {
                const errorText = await response.text();
                console.error('ÊúçÂä°Âô®ËøîÂõûÈîôËØØ:', response.status, response.statusText, errorText);
                throw new Error(`ÊúçÂä°Âô®ËøîÂõûÈîôËØØ: ${response.status} ${response.statusText}`);
            }
            
            const data = await response.json();
            console.log('ÊàøÈó¥ÂàóË°®Êï∞ÊçÆ:', data);
            
            if (data.success && Array.isArray(data.rooms)) {
                this.updateRooms(data.rooms);
            } else {
                throw new Error(data.message || 'ÊúçÂä°Âô®ËøîÂõûÁöÑÊï∞ÊçÆÊ†ºÂºè‰∏çÊ≠£Á°Æ');
            }
            
        } catch (error) {
            console.error('Ëé∑ÂèñÊàøÈó¥ÂàóË°®Â§±Ë¥•:', error);
            
            // Ê†πÊçÆÈîôËØØÁ±ªÂûãÊòæÁ§∫‰∏çÂêåÁöÑÈîôËØØ‰ø°ÊÅØ
            let errorMessage = 'Êó†Ê≥ïËé∑ÂèñÊàøÈó¥ÂàóË°®';
            
            if (error.name === 'AbortError') {
                errorMessage = 'ËøûÊé•Ë∂ÖÊó∂ÔºåËØ∑Ê£ÄÊü•ÁΩëÁªúËøûÊé•ÊàñÊúçÂä°Âô®Âú∞ÂùÄ';
            } else if (error.message.includes('Failed to fetch')) {
                errorMessage = 'Êó†Ê≥ïËøûÊé•Âà∞ÊúçÂä°Âô®ÔºåËØ∑Á°Æ‰øùÊúçÂä°Âô®Ê≠£Âú®ËøêË°å‰∏îÂú∞ÂùÄÊ≠£Á°Æ';
            } else if (error.message.includes('CORS')) {
                errorMessage = 'Ë∑®ÂüüËÆøÈóÆË¢´ÊãíÁªùÔºåËØ∑Ê£ÄÊü•ÊúçÂä°Âô®ÈÖçÁΩÆ';
            } else {
                errorMessage = error.message;
            }
            
            this.showError(errorMessage);
        }
    }

    // ‰øÆÊîπ showError ÊñπÊ≥ï
    showError(message) {
        const roomList = document.getElementById('roomList');
        if (!roomList) return;
        
        roomList.innerHTML = `
            <div class="error-message">
                <div class="error-icon">‚ö†Ô∏è</div>
                <div class="error-text">${message}</div>
                <div style="margin-top: 15px; font-size: 14px; color: #888;">
                    <p>ÂèØËÉΩÁöÑÂéüÂõ†:</p>
                    <ul style="text-align: left; margin: 10px 0;">
                        <li>ÊúçÂä°Âô®Êú™ÂêØÂä®ÊàñÂú∞ÂùÄÈîôËØØ</li>
                        <li>ÁΩëÁªúËøûÊé•ÈóÆÈ¢ò</li>
                        <li>ÊúçÂä°Âô®APIÊú™Ê≠£Á°ÆÈÖçÁΩÆ</li>
                    </ul>
                </div>
                <div style="margin-top: 15px;">
                    <button onclick="versionManager.showVersionModal()" style="margin-right: 10px;">
                        üîß Ê£ÄÊü•ÊúçÂä°Âô®ËÆæÁΩÆ
                    </button>
                    <button onclick="createRoom()">
                        ‚ûï ÂàõÂª∫Êú¨Âú∞ÊàøÈó¥
                    </button>
                </div>
            </div>
        `;
    }

    // Êõ¥Êñ∞ÊàøÈó¥ÂàóË°®
    updateRooms(rooms) {
        this.rooms.clear();
        
        // ËΩ¨Êç¢Êï∞ÊçÆÊ†ºÂºèÂπ∂Â≠òÂÇ®
        rooms.forEach(room => {
            this.rooms.set(room.id, {
                id: room.id,
                name: room.name,
                players: room.players,
                maxPlayers: room.maxPlayers,
                hostName: room.hostName,
                private: room.private || false,
                created: room.created || Date.now(),
                status: 'waiting' // ÂÅáËÆæÊâÄÊúâÊàøÈó¥ÈÉΩÊòØÁ≠âÂæÖÁä∂ÊÄÅ
            });
        });
        
        renderRooms(this.getSortedRooms());
    }

    // Ëé∑ÂèñÊéíÂ∫èÂêéÁöÑÊàøÈó¥
    getSortedRooms() {
        const rooms = Array.from(this.rooms.values());
        
        rooms.sort((a, b) => {
            let comparison = 0;
            
            switch (this.sortBy) {
                case 'name':
                    comparison = a.name.localeCompare(b.name);
                    break;
                case 'players':
                    comparison = a.players - b.players;
                    break;
                case 'created':
                    comparison = b.created - a.created; // Êñ∞ÁöÑÂú®ÂâçÈù¢
                    break;
            }
            
            return this.sortOrder === 'asc' ? comparison : -comparison;
        });
        
        return rooms;
    }

    // ÊòæÁ§∫ÈîôËØØ‰ø°ÊÅØ
    showError(message) {
        const roomList = document.getElementById('roomList');
        roomList.innerHTML = `
            <div class="error-message">
                <div class="error-icon">‚ö†Ô∏è</div>
                <div class="error-text">${message}</div>
                <button onclick="createRoom()" class="retry-button">
                    ÂàõÂª∫ÊàøÈó¥
                </button>
            </div>
        `;
    }
}


// ÊàøÈó¥ÁÆ°ÁêÜÂô®ÂÆû‰æã
const roomManager = new RoomManager();
// Âú® getApiUrl ÊñπÊ≥ïÂâçÊ∑ªÂä†Ëøô‰∏™ËæÖÂä©ÂáΩÊï∞
RoomManager.prototype.getApiUrl = function(path) {
    if (this.serverUrl.startsWith('http://') || this.serverUrl.startsWith('https://')) {
        return `${this.serverUrl}${path}`;
    } else {
        return `http://${this.serverUrl}${path}`;
    }
};
// Ê∏≤ÊüìÊàøÈó¥ÂàóË°®
function renderRooms(rooms) {
    const roomList = document.getElementById('roomList');
    
    if (rooms.length === 0) {
        roomList.innerHTML = `
            <div class="empty-state">
                <div class="empty-icon">üè†</div>
                <div class="empty-text">ÊöÇÊó†ÂèØÁî®ÊàøÈó¥</div>
                <button onclick="createRoom()" class="create-button">
                    ÂàõÂª∫Á¨¨‰∏Ä‰∏™ÊàøÈó¥
                </button>
            </div>
        `;
        return;
    }
    
    const searchTerm = document.getElementById('roomSearch').value.toLowerCase();
    const filterValue = document.getElementById('roomFilter').value;
    
    // ËøáÊª§ÊàøÈó¥
    const filteredRooms = rooms.filter(room => {
        // ÊêúÁ¥¢ËøáÊª§
        const matchesSearch = !searchTerm || 
            room.name.toLowerCase().includes(searchTerm) ||
            room.hostName.toLowerCase().includes(searchTerm);
        
        // Á±ªÂûãËøáÊª§
        let matchesFilter = true;
        switch (filterValue) {
            case 'available':
                matchesFilter = room.players < room.maxPlayers;
                break;
            case 'public':
                matchesFilter = !room.private;
                break;
            case 'private':
                matchesFilter = room.private;
                break;
        }
        
        return matchesSearch && matchesFilter;
    });
    
    if (filteredRooms.length === 0) {
        roomList.innerHTML = `
            <div class="no-results">
                <div class="no-results-icon">üîç</div>
                <div class="no-results-text">Ê≤°ÊúâÊâæÂà∞ÂåπÈÖçÁöÑÊàøÈó¥</div>
            </div>
        `;
        return;
    }
    
    // Ê∏≤ÊüìÊàøÈó¥
    roomList.innerHTML = filteredRooms.map(room => `
        <div class="room-item" onclick="selectRoom('${room.id}')">
            ${room.private ? '<div class="room-private">üîí ÁßÅÂØÜ</div>' : ''}
            
            <div class="room-header">
                <h3 class="room-name">${room.name}</h3>
                <span class="room-code">#${room.id}</span>
            </div>
            
            <div class="room-info">
                <div class="room-host">
                    üë§ Êàø‰∏ª: ${room.hostName}
                </div>
                
                <div class="room-players">
                    ${Array(room.players).fill().map((_, i) => 
                        `<div class="player-dot"></div>`
                    ).join('')}
                </div>
            </div>
            
            <div class="room-footer">
                <div class="player-count">
                    ${room.players}/${room.maxPlayers} Áé©ÂÆ∂
                </div>
                
                <button class="join-button" 
                        ${room.players >= room.maxPlayers ? 'disabled' : ''}
                        onclick="event.stopPropagation(); joinSelectedRoom('${room.id}')">
                    ${room.players >= room.maxPlayers ? 'Â∑≤Êª°' : 'Âä†ÂÖ•ÊàøÈó¥'}
                </button>
            </div>
        </div>
    `).join('');
}

// ËøáÊª§ÊàøÈó¥
function filterRooms() {
    const rooms = roomManager.getSortedRooms();
    renderRooms(rooms);
}

// ÊéíÂ∫èÊàøÈó¥
function sortRooms(sortBy) {
    roomManager.sortBy = sortBy;
    
    // Êõ¥Êñ∞ÊéíÂ∫èÊåâÈíÆÁä∂ÊÄÅ
    document.querySelectorAll('.sort-button').forEach(btn => {
        btn.classList.remove('active');
    });
    event.target.classList.add('active');
    
    const rooms = roomManager.getSortedRooms();
    renderRooms(rooms);
}

// Âà∑Êñ∞ÊàøÈó¥ÂàóË°®
async function refreshRooms() {
    await roomManager.fetchRooms();
}

// ÂÖ≥Èó≠ÊàøÈó¥ÊµèËßàÂô®
function closeRoomBrowser() {
    document.getElementById('roomBrowser').classList.add('hidden');
    roomManager.stopPolling();
}

function openRoomBrowser() {
    const browser = document.getElementById('roomBrowser');
    if (!browser) {
        console.error('ÊàøÈó¥ÊµèËßàÂô®ÂÖÉÁ¥†Êú™ÊâæÂà∞');
        return;
    }
    
    browser.classList.remove('hidden');
    
    try {
        // ÂàùÂßãÂåñÊàøÈó¥ÁÆ°ÁêÜÂô®
        roomManager.init();
    } catch (error) {
        console.error('ÂàùÂßãÂåñÊàøÈó¥ÁÆ°ÁêÜÂô®Â§±Ë¥•:', error);
        
        // Â¶ÇÊûúÂàùÂßãÂåñÂ§±Ë¥•ÔºåËá≥Â∞ëÊòæÁ§∫ÊàøÈó¥ÂàóË°®
        const roomList = document.getElementById('roomList');
        if (roomList) {
            roomList.innerHTML = `
                <div class="error-message">
                    <div class="error-icon">‚ö†Ô∏è</div>
                    <div class="error-text">ÊàøÈó¥ÁÆ°ÁêÜÂô®ÂàùÂßãÂåñÂ§±Ë¥•</div>
                    <button onclick="createRoom()" class="retry-button">
                        ÂàõÂª∫ÊàøÈó¥
                    </button>
                </div>
            `;
        }
    }
}


// Âä†ÂÖ•ÊàøÈó¥
async function joinRoom(roomId) {
    const room = roomManager.rooms.get(roomId);
    if (!room || room.players >= room.maxPlayers) {
        return;
    }
    
    const playerName = document.getElementById('playerName').value.trim() || 'Áé©ÂÆ∂';
    if (!confirm(`Á°ÆÂÆöË¶ÅÂä†ÂÖ•ÊàøÈó¥ "${room.name}" ÂêóÔºü`)) {
        return;
    }
    
    roomManager.joinRoom(roomId);
}
// ÈÄâÊã©ÊàøÈó¥
function selectRoom(roomId) {
    // È´ò‰∫ÆÈÄâ‰∏≠ÁöÑÊàøÈó¥
    document.querySelectorAll('.room-item').forEach(item => {
        item.classList.remove('selected');
    });
    event.currentTarget.classList.add('selected');
    
    // ‰øùÂ≠òÈÄâ‰∏≠ÁöÑÊàøÈó¥ID
    gameState.selectedRoomId = roomId;
}

// Âä†ÂÖ•ÈÄâ‰∏≠ÁöÑÊàøÈó¥
async function joinSelectedRoom(roomId) {
    const room = roomManager.rooms.get(roomId);
    if (!room) return;
    
    if (room.players >= room.maxPlayers) {
        showNotification('ÊàøÈó¥Â∑≤Êª°', 'error');
        return;
    }
    
    const playerName = document.getElementById('playerName').value.trim() || 'Áé©ÂÆ∂';
    
    // ËøûÊé•Âà∞ÊàøÈó¥
    try {
        closeRoomBrowser(); // ÂÖ≥Èó≠ÊàøÈó¥ÊµèËßàÂô®
        
        showNotification('Ê≠£Âú®ËøûÊé•...', 'info');
        
        // ‰ΩøÁî®ÂéüÊúâÁöÑËøûÊé•ÈÄªËæë
        gameState.playerName = playerName;
        gameState.multiplayer.roomCode = roomId;
        gameState.multiplayer.isHost = false;
        
        // ÂàùÂßãÂåñPeerËøûÊé•
        gameState.multiplayer.peer = new Peer({
            debug: 2,
            config: {
                'iceServers': [
                    { urls: 'stun:stun.l.google.com:19302' },
                    { urls: 'stun:stun1.l.google.com:19302' }
                ]
            }
        });
        
        gameState.multiplayer.peer.on('open', (id) => {
            console.log('PeerËøûÊé•Âª∫Á´ãÔºåID:', id);
            gameState.multiplayer.currentPlayerId = id;
            
            // ËøûÊé•Âà∞‰∏ªÊú∫
            connectToHost(roomId, playerName);
        });
        
        gameState.multiplayer.peer.on('error', (err) => {
            console.error('PeerÈîôËØØ:', err);
            showNotification('ËøûÊé•Â§±Ë¥•: ' + err.message, 'error');
            showScreen('multiplayerSetup');
        });
        
    } catch (error) {
        showNotification('Âä†ÂÖ•ÊàøÈó¥Â§±Ë¥•', 'error');
        console.error('Âä†ÂÖ•ÊàøÈó¥Â§±Ë¥•:', error);
    }
}

// ÂàõÂª∫ÊàøÈó¥
function createRoom() {
    closeRoomBrowser();
    
    // ÂØºËà™Âà∞ÂàõÂª∫ÊàøÈó¥ÁïåÈù¢
    showScreen('multiplayerSetup');
    
    // ËÆæÁΩÆÈªòËÆ§ÊàøÈó¥ÂêçÁß∞
    setTimeout(() => {
        const roomNameInput = document.querySelector('input[placeholder="ÊàøÈó¥‰ª£Á†Å (ÁïôÁ©∫ÂàõÂª∫Êñ∞ÊàøÈó¥)"]');
        if (roomNameInput) {
            roomNameInput.value = '';
        }
    }, 100);
}

// Êõ¥Êñ∞Â§ö‰∫∫Ê∏∏ÊàèÂºÄÂßãÂáΩÊï∞‰ª•ÈÄÇÈÖçÂä†ÂÖ•ÊàøÈó¥ÁöÑÊñπÂºè
function startMultiplayerGameWithHost(roomId, playerName, connection) {
    // ËÆæÁΩÆÂΩìÂâçÁé©ÂÆ∂‰ø°ÊÅØ
    gameState.multiplayer.isHost = false;
    gameState.multiplayer.roomCode = roomId;
    gameState.multiplayer.currentPlayerId = connection.peer;
    gameState.multiplayer.connected = true;
    gameState.multiplayer.connections[roomId] = connection;
    
    // Ê∑ªÂä†ÂΩìÂâçÁé©ÂÆ∂
    gameState.multiplayer.players = {
        [connection.peer]: {
            id: connection.peer,
            name: playerName,
            x: 1,
            y: 1,
            color: getRandomColor(),
            reachedExit: false,
            isHost: false
        }
    };
    
    // Â§ÑÁêÜËøûÊé•‰∫ã‰ª∂
    connection.on('data', (data) => {
        handleMultiplayerData(data, connection.peer);
    });
    
    // ËÆæÁΩÆÊàøÈó¥‰ø°ÊÅØÊòæÁ§∫
    document.getElementById('multiplayerRoomCode').textContent = `ÊàøÈó¥: ${roomId}`;
    document.getElementById('multiplayerGameInfo').style.display = 'flex';
    document.getElementById('multiplayerMoveCount').textContent = `ÁßªÂä®: 0`;
    updatePlayerList();
    
    // ÂºÄÂßãÊ∏∏Êàè
    startMultiplayerGame();
}
// ‰øÆÊîπ initMultiplayerSetup ÂáΩÊï∞
function initMultiplayerSetup() {
    const setupContainer = document.querySelector('.multiplayer-setup');
    if (setupContainer) {
        // Âú®ÊàøÈó¥ËÆæÁΩÆÂâçÊ∑ªÂä†ÊúçÂä°Âô®ÈÖçÁΩÆ
        const serverConfig = document.createElement('div');
        serverConfig.className = 'room-settings';
        serverConfig.innerHTML = `
            <h4>ÊúçÂä°Âô®ËÆæÁΩÆ</h4>
            <div class="setting-row">
                <label for="serverUrl">ÊúçÂä°Âô®Âú∞ÂùÄ:</label>
                <input type="text" id="serverUrl" class="setup-input" 
                       placeholder="‰æã: localhost:1683"
                       value="${localStorage.getItem('serverUrl') || 'localhost:1683'}">
            </div>
        `;
        
        const roomSettings = setupContainer.querySelector('.room-settings');
        if (roomSettings) {
            setupContainer.insertBefore(serverConfig, roomSettings);
        } else {
            setupContainer.appendChild(serverConfig);
        }
        
        // ‰øùÂ≠òÊúçÂä°Âô®ÈÖçÁΩÆÂèòÂåñ
        document.getElementById('serverUrl')?.addEventListener('input', function(e) {
            localStorage.setItem('serverUrl', e.target.value);
            roomManager.serverUrl = e.target.value;
        });
        
        // Âú®ÂéüÊúâÊåâÈíÆÂâçÊ∑ªÂä†ÊêúÁ¥¢ÊàøÈó¥ÊåâÈíÆ
        const buttonContainer = setupContainer.querySelector('.button-container') || setupContainer;
        const searchButton = document.createElement('button');
        searchButton.className = 'small-menu-button';
        searchButton.style.marginTop = '10px';
        searchButton.style.width = '100%';
        searchButton.innerHTML = 'üîç ÊêúÁ¥¢Â±ÄÂüüÁΩëÊàøÈó¥';
        searchButton.onclick = () => openRoomBrowser();
        
        // ÊèíÂÖ•Âà∞Áé∞ÊúâÊåâÈíÆ‰πãÂâç
        const startButton = buttonContainer.querySelector('button:last-child');
        if (startButton) {
            buttonContainer.insertBefore(searchButton, startButton);
        } else {
            buttonContainer.appendChild(searchButton);
        }
        
        // Â¶ÇÊûúÊ≤°ÊúâÊåâÈíÆÂÆπÂô®ÔºåÂàõÂª∫‰∏Ä‰∏™
        if (!setupContainer.querySelector('.button-container')) {
            const container = document.createElement('div');
            container.className = 'button-container';
            setupContainer.appendChild(container);
        }
    }
}


class LevelEditor {
    constructor() {
        this.currentLevel = null;
        this.isTesting = false;
        this.initEditor();
    }
    
    initEditor() {
        // ÂàõÂª∫Canvas
        this.canvas = document.createElement('canvas');
        this.canvas.width = 800;
        this.canvas.height = 600;
        document.getElementById('editorContainer').appendChild(this.canvas);
        this.ctx = this.canvas.getContext('2d');
        
        // ÁΩëÊ†ºÁªòÂà∂
        this.cellSize = 32;
        this.drawGrid();
        
        // Â∑•ÂÖ∑ÈÄâÊã©
        this.selectedTool = 'wall';
        document.querySelectorAll('.tool-btn').forEach(btn => {
            btn.addEventListener('click', () => {
                this.selectedTool = btn.dataset.tool;
            });
        });
        
        // ÁîªÂ∏É‰∫§‰∫í
        this.canvas.addEventListener('mousedown', this.handleCanvasClick.bind(this));
    }
    
    startNewLevel() {
        const creator = prompt("ËæìÂÖ•‰Ω†ÁöÑÂàõ‰ΩúËÄÖÂêçÁß∞:");
        if(!creator || creator.length < 2) {
            alert("Âàõ‰ΩúËÄÖÂêçÁß∞Ëá≥Â∞ëÈúÄË¶Å2‰∏™Â≠óÁ¨¶");
            return;
        }
        
        const levelName = prompt("ËæìÂÖ•ÂÖ≥Âç°ÂêçÁß∞:");
        if(!levelName) {
            alert("ÂøÖÈ°ªËæìÂÖ•ÂÖ≥Âç°ÂêçÁß∞");
            return;
        }
        
        this.currentLevel = {
            meta: {
                version: 2,
                creator: creator,
                name: levelName,
                created: Date.now(),
                verified: false
            },
            data: {
                tiles: Array(20).fill().map(() => Array(20).fill(0)), // 20x20Á©∫ÁΩëÊ†º
                entities: [],
                start: { x: 1, y: 1 },
                end: { x: 15, y: 15 }
            }
        };
        
        this.renderMap();
    }
    
    handleCanvasClick(e) {
        if(!this.currentLevel || this.isTesting) return;
        
        const rect = this.canvas.getBoundingClientRect();
        const x = Math.floor((e.clientX - rect.left) / this.cellSize);
        const y = Math.floor((e.clientY - rect.top) / this.cellSize);
        
        // ËæπÁïåÊ£ÄÊü•
        if(x < 0 || y < 0 || x >= 20 || y >= 20) return;
        
        switch(this.selectedTool) {
            case 'wall':
                this.currentLevel.data.tiles[y][x] = 1;
                break;
            case 'start':
                this.currentLevel.data.start = { x, y };
                break;
            case 'spike':
                this.currentLevel.data.entities.push({
                    type: 'spike',
                    x, y,
                    damage: 1
                });
                break;
            // ÂÖ∂‰ªñÂ∑•ÂÖ∑...
        }
        
        this.renderMap();
    }
    
    renderMap() {
        this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
        
        // ÁªòÂà∂ÁΩëÊ†º
        this.drawGrid();
        
        // ÁªòÂà∂Âú∞Âùó
        for(let y = 0; y < 20; y++) {
            for(let x = 0; x < 20; x++) {
                if(this.currentLevel.data.tiles[y][x] === 1) {
                    this.ctx.fillStyle = '#886644';
                    this.ctx.fillRect(
                        x * this.cellSize, 
                        y * this.cellSize, 
                        this.cellSize, 
                        this.cellSize
                    );
                }
            }
        }
        
        // ÁªòÂà∂ÂÆû‰Ωì
        this.currentLevel.data.entities.forEach(entity => {
            switch(entity.type) {
                case 'spike':
                    this.drawSpike(entity.x, entity.y);
                    break;
                // ÂÖ∂‰ªñÂÆû‰Ωì...
            }
        });
        
        // ÁªòÂà∂Ëµ∑ÁÇπÁªàÁÇπ
        this.drawStartEnd();
    }
    
    async testLevel() {
        if(!this.currentLevel) return;
        this.isTesting = true;
        
        // ÂøÖÈ°ªÈÄöËøáÈ™åËØÅÊâçËÉΩÂàÜ‰∫´
        const success = await simulateGameTest(this.currentLevel);
        
        if(success) {
            this.currentLevel.meta.verified = true;
            const zzshareCode = LevelEncryptor.encrypt(
                this.currentLevel,
                this.currentLevel.meta.creator
            );
            
            alert(`ÊµãËØïÊàêÂäüÔºÅ‰Ω†ÁöÑÂàÜ‰∫´Á†Å: ${shareCode}`);
        } else {
            alert("ÊµãËØïÂ§±Ë¥•ÔºåÂøÖÈ°ª‰∫≤Ëá™ÈÄöÂÖ≥ÊâçËÉΩÂàÜ‰∫´");
        }
        
        this.isTesting = false;
    }
}
class LevelLoader {
    static loadFromCode(shareCode, creatorName) {
        // 1. Ëß£ÂØÜÊï∞ÊçÆ
        const levelData = LevelEncryptor.decrypt(shareCode, creatorName);
        if(!levelData) {
            throw new Error("Êó†ÊïàÁöÑÂàÜ‰∫´Á†ÅÊàñÂàõ‰ΩúËÄÖÂêç");
        }
        
        // 2. È™åËØÅÊï∞ÊçÆÁªìÊûÑ
        if(!this.validateLevel(levelData)) {
            throw new Error("ÂÖ≥Âç°Êï∞ÊçÆÊçüÂùè");
        }
        
        // 3. È™åËØÅÂàõ‰ΩúËÄÖÊòØÂê¶ÂÆåÊàêËøáÂÖ≥
        if(!levelData.meta.verified) {
            throw new Error("ËØ•ÂÖ≥Âç°Êú™ÈÄöËøáÂàõ‰ΩúËÄÖÈ™åËØÅ");
        }
        
        return levelData;
    }
    
    static validateLevel(levelData) {
        return levelData.meta &&
               levelData.meta.version >= 2 &&
               levelData.data &&
               Array.isArray(levelData.data.tiles) &&
               levelData.data.start &&
               levelData.data.end;
    }
}
class LocalLevelManager {
    static STORAGE_KEY = 'savedLevels_v2';
    
    static saveLevel(levelData) {
        const levels = this.getSavedLevels();
        levels.push({
            name: levelData.meta.name,
            code: LevelEncryptor.encrypt(
                levelData, 
                levelData.meta.creator
            ),
            creator: levelData.meta.creator,
            timestamp: Date.now()
        });
        localStorage.setItem(this.STORAGE_KEY, JSON.stringify(levels));
    }
    
    static getSavedLevels() {
        return JSON.parse(localStorage.getItem(this.STORAGE_KEY) || '[]');
    }
    
    static deleteLevel(code) {
        const levels = this.getSavedLevels()
            .filter(l => l.code !== code);
        localStorage.setItem(this.STORAGE_KEY, JSON.stringify(levels));
    }
    
    static exportAllLevels() {
        const levels = this.getSavedLevels();
        const blob = new Blob([JSON.stringify(levels)], { type: 'application/json' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = 'my_levels_backup.json';
        a.click();
    }
}


const ENCRYPTION_CONFIG = {
    salt: "GAME_LEVEL_SALT_V1", // ‰øÆÊîπÊ≠§ÂÄº‰ΩøÊóßÂàÜ‰∫´Á†ÅÂ§±Êïà
    iv: CryptoJS.enc.Hex.parse("0102030405060708")
};

class LevelEncryptor {
    static encrypt(levelData, creatorName) {
        // 1. ÂáÜÂ§áÊï∞ÊçÆ
        const jsonStr = JSON.stringify(levelData);
        
        // 2. ÁîüÊàêÂü∫‰∫éÂàõ‰ΩúËÄÖÂêçÁöÑÂØÜÈí•
        const key = this._generateKey(creatorName);
        
        // 3. AES-CBCÂä†ÂØÜ
        const encrypted = CryptoJS.AES.encrypt(jsonStr, key, {
            iv: ENCRYPTION_CONFIG.iv,
            padding: CryptoJS.pad.Pkcs7,
            mode: CryptoJS.mode.CBC
        });
        
        // 4. ËΩ¨‰∏∫URLÂÆâÂÖ®ÁöÑBase64
        return encrypted.toString()
            .replace(/\+/g, '-')
            .replace(/\//g, '_')
            .replace(/=+$/, '');
    }
    
    static decrypt(encryptedCode, creatorName) {
        try {
            // 1. ËøòÂéüÊ†áÂáÜBase64
            const standardB64 = encryptedCode
                .replace(/-/g, '+')
                .replace(/_/g, '/') + 
                '='.repeat((4 - encryptedCode.length % 4) % 4);
                
            // 2. ÁîüÊàêÂØÜÈí•
            const key = this._generateKey(creatorName);
            
            // 3. Ëß£ÂØÜ
            const decrypted = CryptoJS.AES.decrypt(standardB64, key, {
                iv: ENCRYPTION_CONFIG.iv,
                padding: CryptoJS.pad.Pkcs7,
                mode: CryptoJS.mode.CBC
            });
            
            // 4. ËΩ¨‰∏∫JSONÂØπË±°
            return JSON.parse(decrypted.toString(CryptoJS.enc.Utf8));
        } catch(e) {
            console.error("Ëß£ÂØÜÂ§±Ë¥•:", e);
            return null;
        }
    }
    
    static _generateKey(creatorName) {
        return CryptoJS.PBKDF2(
            creatorName + ENCRYPTION_CONFIG.salt,
            CryptoJS.enc.Hex.parse("0102030405060708"),
            { keySize: 256/32, iterations: 100 }
        );
    }
}
// Â∫îÁî®UIËÆæÁΩÆ
function makeDraggable(element, handle) {
    let isDragging = false;
    let offsetX, offsetY;

    const startDrag = (clientX, clientY) => {
        isDragging = true;
        const rect = element.getBoundingClientRect();
        offsetX = clientX - rect.left;
        offsetY = clientY - rect.top;
        element.style.transition = 'none';
        document.body.style.userSelect = 'none';
    };

    const moveDrag = (clientX, clientY) => {
        if (!isDragging) return;
        
        let newLeft = clientX - offsetX;
        let newTop = clientY - offsetY;
        
        // ËæπÁïåÊ£ÄÊü•
        newLeft = Math.max(0, Math.min(newLeft, window.innerWidth - element.offsetWidth));
        newTop = Math.max(0, Math.min(newTop, window.innerHeight - element.offsetHeight));
        
        element.style.left = `${newLeft}px`;
        element.style.top = `${newTop}px`;
    };

    const endDrag = () => {
        if (!isDragging) return;
        isDragging = false;
        document.body.style.userSelect = '';
        
        // ‰øùÂ≠òÊñ∞‰ΩçÁΩÆ
        gameState.uiSettings.customX = parseInt(element.style.left);
        gameState.uiSettings.customY = parseInt(element.style.top);
        localStorage.setItem('uiSettings', JSON.stringify(gameState.uiSettings));
    };

    // Èº†Ê†á‰∫ã‰ª∂
    handle.addEventListener('mousedown', (e) => {
        startDrag(e.clientX, e.clientY);
    });

    document.addEventListener('mousemove', (e) => moveDrag(e.clientX, e.clientY));
    document.addEventListener('mouseup', endDrag);

    // Ëß¶Êë∏‰∫ã‰ª∂
    handle.addEventListener('touchstart', (e) => {
        if (e.touches.length === 1) {
            startDrag(e.touches[0].clientX, e.touches[0].clientY);
        }
    }, { passive: false });

    document.addEventListener('touchmove', (e) => {
        if (isDragging) moveDrag(e.touches[0].clientX, e.touches[0].clientY);
        e.preventDefault();
    }, { passive: false });

    document.addEventListener('touchend', endDrag);
}

        // Â§ÑÁêÜÊéßÂà∂ÊåâÈíÆÁÇπÂáª


// =============== ÊéßÂà∂ÊåâÈíÆÁÇπÂáªÂ§ÑÁêÜ ===============
function handleControlButtonClick(key) {
    // Ê£ÄÊü•ÊòØÂê¶ÊòØÊúâÊïàÁöÑÊñπÂêëÈîÆ
    if(['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight'].includes(key)) {
        // „Äê‰øÆÂ§çÁÇπ„ÄëÁõ¥Êé•Ë∞ÉÁî®Ê†∏ÂøÉÁßªÂä®ÂáΩÊï∞Ôºå‰º†ÂÖ•ÂéüÂßãÊåâÈîÆ
        // movePlayer ÂÜÖÈÉ®‰ºöÂ§ÑÁêÜÂèçËΩ¨ÈÄªËæëÔºåÂπ∂Ëá™Âä®Âå∫ÂàÜÂçï‰∫∫/Â§ö‰∫∫Ê®°Âºè
        movePlayer(key);
    }
}

        // =============== ÊéßÂà∂Âè∞ÂäüËÉΩ ===============
        function toggleConsole() {
            consoleVisible = !consoleVisible;
            const consoleDiv = document.getElementById('console');
            
            if (consoleVisible) {
                consoleDiv.classList.remove('console-hidden');
                document.getElementById('consoleInput').focus();
            } else {
                consoleDiv.classList.add('console-hidden');
            }
        }

        function handleConsoleInput(e) {
            // Âè™ÈòªÊ≠¢ÁâπÂÆöÈîÆÁöÑÈªòËÆ§Ë°å‰∏∫
            if (e.key === 'Enter') {
                const input = document.getElementById('consoleInput');
                const command = input.value.trim();
                input.value = '';
                    
                if (command) {
                    consoleHistory.push(command);
                    historyIndex = consoleHistory.length;
                    executeCommand(command);
                }
            } else if (e.key === 'ArrowUp') {
                e.preventDefault();
                if (consoleHistory.length > 0) {
                    if (historyIndex > 0) historyIndex--;
                    document.getElementById('consoleInput').value = consoleHistory[historyIndex] || '';
                }
            } else if (e.key === 'ArrowDown') {
                e.preventDefault();
                if (consoleHistory.length > 0) {
                    if (historyIndex < consoleHistory.length - 1) historyIndex++;
                    document.getElementById('consoleInput').value = consoleHistory[historyIndex] || '';
                } else {
                    document.getElementById('consoleInput').value = '';
                }
            }
            // ÂÖ∂‰ªñÊåâÈîÆ‰∏çÈòªÊ≠¢ÈªòËÆ§Ë°å‰∏∫ÔºåÂÖÅËÆ∏Ê≠£Â∏∏ËæìÂÖ•
        }
function sendKickRequest(playerId, reason) {
    // ÊâæÂà∞Êàø‰∏ªËøûÊé•
    let hostConnection = null;
    for (const id in gameState.multiplayer.players) {
        if (gameState.multiplayer.players[id].isHost) {
            hostConnection = gameState.multiplayer.connections[id];
            break;
        }
    }
    
    if (hostConnection) {
        hostConnection.send({
            type: 'kick-request',
            playerId: playerId,
            requestorId: gameState.multiplayer.currentPlayerId,
            reason: reason
        });
    }
}
function sendPrivateMessage(playerId, message) {
    if (gameState.multiplayer.connections[playerId]) {
        try {
            gameState.multiplayer.connections[playerId].send({
                type: 'private-message',
                from: gameState.multiplayer.currentPlayerId,
                message: message,
                timestamp: Date.now()
            });
            
            // ÁªôËá™Â∑±‰πüÊòæÁ§∫‰∏ÄÊù°ÂèëÈÄÅÊàêÂäüÁöÑÊ∂àÊÅØ
            // showMessageToSelf(`‰Ω† ‚Üí ${gameState.multiplayer.players[playerId].name}: ${message}`);
        } catch (err) {
            console.error('ÂèëÈÄÅÊ∂àÊÅØÂ§±Ë¥•:', err);
            showNotification(`‚ùå ÂèëÈÄÅÊ∂àÊÅØÂ§±Ë¥•: ${err.message}`, 'error');
        }
    }
}
// ÁªôËá™Â∑±ÊòæÁ§∫Ê∂àÊÅØ
function showMessageToSelf(message) {
    const consoleOutput = document.getElementById('consoleOutput');
    consoleOutput.innerHTML += `\n[ÁßÅËÅä] ${message}`;
    consoleOutput.scrollTop = consoleOutput.scrollHeight;
    
    // Â¶ÇÊûúÊòØÂºπÁ™óÂΩ¢Âºè
    alert(message);
}


        function executeCommand(command) {
            const output = document.getElementById('consoleOutput');
            output.innerHTML += `\n> ${command}`;
            output.scrollTop = output.scrollHeight;
            
            const parts = command.split(' ');
            const cmd = parts[0].toLowerCase();
            const args = parts.slice(1);
            
            switch(cmd) {
                case 'help':
                    output.innerHTML += '\nÂèØÁî®ÂëΩ‰ª§:';
                    output.innerHTML += '\n- help: ÊòæÁ§∫Â∏ÆÂä©‰ø°ÊÅØ';
                    output.innerHTML += '\n- dev [password]: ËøõÂÖ•ÂºÄÂèëËÄÖÊ®°Âºè';
                    output.innerHTML += '\n- win: Á´ãÂç≥ÂÆåÊàêÂΩìÂâçÂÖ≥Âç°';
                    output.innerHTML += '\n- level [n]: Ë∑≥ËΩ¨Âà∞Á¨¨nÂÖ≥ (1-80)';
                    output.innerHTML += '\n- unlockall: Ëß£ÈîÅÊâÄÊúâÂÖ≥Âç°';
                    output.innerHTML += '\n- reset: ÈáçÁΩÆÂΩìÂâçÂÖ≥Âç°';
                    output.innerHTML += '\n- clear: Ê∏ÖÁ©∫ÊéßÂà∂Âè∞ËæìÂá∫';
                    output.innerHTML += '\n- twoplayer: ËøõÂÖ•Â§ö‰∫∫Ê∏∏ÊàèÈ°µÈù¢';
                    output.innerHTML += '\n- tp [x] [y]: ‰º†ÈÄÅËá≥‰∏Ä‰∏™‰ΩçÁΩÆ';
                    output.innerHTML += '\n- tp select: ‰º†ÈÄÅËá≥‰∏Ä‰∏™‰ΩçÁΩÆÔºàÂú∞ÂõæÈÄâÊã©Ôºâ';
                    output.innerHTML += '\n- tp [playername] select: ‰º†ÈÄÅÁé©ÂÆ∂Âà∞ÈÄâÊã©ÁöÑ‰ΩçÁΩÆ';
                    output.innerHTML += '\n- kick [playername]: Ë∏¢Âá∫Áé©ÂÆ∂ÔºàÊàø‰∏ªÊùÉÈôêÔºâ';
                    output.innerHTML += '\n- protect [playername]: ‰øùÊä§Áé©ÂÆ∂ÔºàÊó†ÊïåÁä∂ÊÄÅÔºåÊó†Ê≥ïË¢´Ë∏¢Âá∫Ôºâ';
                    output.innerHTML += '\n- unprotect [playername]: ÂèñÊ∂à‰øùÊä§Áé©ÂÆ∂';
                    output.innerHTML += '\n- players: ÊòæÁ§∫Áé©ÂÆ∂ÂàóË°®';
                    output.innerHTML += '\n- msg: ÂêëÁé©ÂÆ∂ÂèëÂá∫‰ø°ÊÅØ';
                    break;
                    
                case 'dev':
                    if (args.length > 0 && args[0] === 'dev') {
                        gameState.devMode = true;
                        output.innerHTML += '\nÂºÄÂèëËÄÖÊ®°ÂºèÂ∑≤ÊøÄÊ¥ªÔºÅ';
                    } else {
                        output.innerHTML += '\nÈúÄË¶ÅÂØÜÁ†ÅÔºÅËæìÂÖ• "dev [password]" ÊøÄÊ¥ªÂºÄÂèëËÄÖÊ®°Âºè';
                    }
                    break;
                   
                case 'tp':
                    if (!gameState.devMode) {
                        output.innerHTML += '\nËØ∑ÂÖàÊøÄÊ¥ªÂºÄÂèëËÄÖÊ®°Âºè (ËæìÂÖ• "dev [password]")';
                        break;
                    }
            
                    if (args.length === 0) {
                        output.innerHTML += '\nÁî®Ê≥ï: tp [Áé©ÂÆ∂] [x] [y] Êàñ tp [Áé©ÂÆ∂] select';
                        output.innerHTML += '\nÁ§∫‰æã: tp 5 10 - ‰º†ÈÄÅÂà∞ÂùêÊ†á(5,10)';
                        output.innerHTML += '\n       tp player1 5 10 - ‰º†ÈÄÅplayer1Âà∞ÂùêÊ†á(5,10)';
                        output.innerHTML += '\n       tp select - ËøõÂÖ•Âú∞ÂõæÈÄâÊã©Ê®°Âºè';
                        output.innerHTML += '\n       tp player1 select - ‰∏∫player1ËøõÂÖ•Âú∞ÂõæÈÄâÊã©Ê®°Âºè';
                        output.innerHTML += '\n‰ΩøÁî® "players" ÂëΩ‰ª§Êü•ÁúãÊâÄÊúâÁé©ÂÆ∂';
                        break;
                    }
            
                    // Ëß£ÊûêÁé©ÂÆ∂ÂèÇÊï∞
                    let targetPlayerId = null;
                    let coordArgs = args;
                    
                    // Ê£ÄÊü•Á¨¨‰∏Ä‰∏™ÂèÇÊï∞ÊòØÂê¶ÊòØÁé©ÂÆ∂ÂêçÊàñID
                    if (args.length >= 3 || (args.length === 2 && args[1] === 'select')) {
                        const playerIdentifier = args[0];
                        
                        // Êü•ÊâæÁé©ÂÆ∂
                        if (gameState.currentScreen === 'singlePlayerGame') {
                            // Âçï‰∫∫Ê∏∏ÊàèÂè™ÊúâËá™Â∑±
                            if (playerIdentifier === 'me' || playerIdentifier === 'self') {
                                targetPlayerId = 'singleplayer';
                            } else {
                                output.innerHTML += '\nÂçï‰∫∫Ê®°Âºè‰∏ãÂè™ËÉΩ‰º†ÈÄÅËá™Â∑±Ôºå‰ΩøÁî® "me" ÊàñÁúÅÁï•Áé©ÂÆ∂ÂèÇÊï∞';
                                break;
                            }
                        } else if (gameState.currentScreen === 'multiplayerGame') {
                            // Âú®Â§ö‰∫∫Ê∏∏Êàè‰∏≠Êü•ÊâæÁé©ÂÆ∂
                            const players = gameState.multiplayer.players;
                            for (const id in players) {
                                if (players[id].name === playerIdentifier || id === playerIdentifier) {
                                    targetPlayerId = id;
                                    break;
                                }
                            }
                            
                            if (!targetPlayerId) {
                                output.innerHTML += `\nÊú™ÊâæÂà∞Áé©ÂÆ∂: ${playerIdentifier}`;
                                output.innerHTML += '\n‰ΩøÁî® "players" ÂëΩ‰ª§Êü•ÁúãÊâÄÊúâÁé©ÂÆ∂';
                                break;
                            }
                        }
                        
                        // ÁßªÈô§Áé©ÂÆ∂ÂèÇÊï∞Ôºå‰øùÁïôÂùêÊ†áÂèÇÊï∞
                        coordArgs = args.slice(1);
                    }
            
                    if (coordArgs[0] === 'select') {
                        // ËøõÂÖ•Âú∞ÂõæÈÄâÊã©Ê®°Âºè
                        startMapSelection(targetPlayerId);
                        output.innerHTML += `\nÂ∑≤ËøõÂÖ•Âú∞ÂõæÈÄâÊã©Ê®°ÂºèÔºåÁÇπÂáªÂú∞Âõæ‰∏äÁöÑ‰ΩçÁΩÆËøõË°å‰º†ÈÄÅ${targetPlayerId ? ' ÁõÆÊ†áÁé©ÂÆ∂: ' + targetPlayerId : ''}`;
                    } else if (coordArgs.length === 2) {
                        // Áõ¥Êé•‰º†ÈÄÅÂà∞ÊåáÂÆöÂùêÊ†á
                        const x = parseInt(coordArgs[0]);
                        const y = parseInt(coordArgs[1]);
                
                        if (isNaN(x) || isNaN(y)) {
                            output.innerHTML += '\nÂùêÊ†áÂøÖÈ°ªÊòØÊï∞Â≠ó';
                            break;
                        }
                    
                        const success = teleportPlayer(x, y, targetPlayerId);
                        if (success) {
                            output.innerHTML += `\nÂ∑≤‰º†ÈÄÅ${targetPlayerId ? 'Áé©ÂÆ∂ ' + targetPlayerId : 'Ëá™Â∑±'}Âà∞ÂùêÊ†á(${x},${y})`;
                        }
                    } else {
                        output.innerHTML += '\nÁî®Ê≥ï: tp [Áé©ÂÆ∂] [x] [y] Êàñ tp [Áé©ÂÆ∂] select';
                    }
                    break;
                case 'msg':
                case 'message':
                    if (!gameState.devMode) {
                        output.innerHTML += '\nËØ∑ÂÖàÊøÄÊ¥ªÂºÄÂèëËÄÖÊ®°Âºè (ËæìÂÖ• "dev [password]")';
                        break;
                    }
                    
                    if (args.length < 2) {
                        output.innerHTML += '\nÁî®Ê≥ï: msg [Áé©ÂÆ∂ÂêçÊàñID] [Ê∂àÊÅØÂÜÖÂÆπ]';
                        output.innerHTML += '\nÁ§∫‰æã: msg player1 ‰Ω†Â•ΩÔºÅ';
                        output.innerHTML += '\n‰ΩøÁî® "players" ÂëΩ‰ª§Êü•ÁúãÊâÄÊúâÁé©ÂÆ∂';
                        break;
                    }
                    
                    const recipient = args[0];
                    const message = args.slice(1).join(' ');
                    
                    if (gameState.currentScreen === 'multiplayerGame') {
                        // Êü•ÊâæÁé©ÂÆ∂
                        let playerId = null;
                        const players = gameState.multiplayer.players;
                        for (const id in players) {
                            if (players[id].name === recipient || id === recipient) {
                                playerId = id;
                                break;
                            }
                        }
                        
                        if (playerId) {
                            // ÂèëÈÄÅÊ∂àÊÅØ
                            sendPrivateMessage(playerId, message);
                            output.innerHTML += `\nÂ∑≤Âêë ${recipient} ÂèëÈÄÅÊ∂àÊÅØ: ${message}`;
                        } else {
                            output.innerHTML += `\nÊú™ÊâæÂà∞Áé©ÂÆ∂: ${recipient}`;
                        }
                    } else {
                        output.innerHTML += '\nÊ≠§ÂëΩ‰ª§Âè™ËÉΩÂú®Â§ö‰∫∫Ê∏∏Êàè‰∏≠‰ΩøÁî®';
                    }
                    break;                    
                case 'players':
                    if (!gameState.devMode) {
                        output.innerHTML += '\nËØ∑ÂÖàÊøÄÊ¥ªÂºÄÂèëËÄÖÊ®°Âºè (ËæìÂÖ• "dev [password]")';
                        break;
                    }
                    
                    if (gameState.currentScreen === 'singlePlayerGame') {
                        output.innerHTML += '\nÂΩìÂâçÁé©ÂÆ∂: Ëá™Â∑± (Âçï‰∫∫Ê®°Âºè)';
                    } else if (gameState.currentScreen === 'multiplayerGame') {
                        output.innerHTML += '\nÁé©ÂÆ∂ÂàóË°®:';
                        const players = gameState.multiplayer.players;
                        for (const id in players) {
                            const player = players[id];
                            const isCurrent = id === gameState.multiplayer.currentPlayerId;
                            const isProtected = gameState.multiplayer.protectedPlayers[id];
                            output.innerHTML += `\n- ${player.name} (ID: ${id})${isCurrent ? ' [ÂΩìÂâçÁé©ÂÆ∂]' : ''}${isProtected ? ' [Âèó‰øùÊä§]' : ''}`;
                        }
                    } else {
                        output.innerHTML += '\nÊ≠§ÂëΩ‰ª§Âè™ËÉΩÂú®Ê∏∏Êàè‰∏≠‰ΩøÁî®';
                    }
                    break;
                    
                case 'twoplayer':
                    if (!gameState.devMode) {
                        output.innerHTML += '\nËØ∑ÊøÄÊ¥ªÂºÄÂèëËÄÖÊ®°Âºè';
                        break;
                    }
                    showScreen('multiplayerSetup');
                    output.innerHTML += '\nÂ∑≤ËøõÂÖ•Â§ö‰∫∫Ê∏∏ÊàèËÆæÁΩÆ';
                    break;
                    
                case 'kick':
                    if (!gameState.devMode) {
                        output.innerHTML += '\nËØ∑ÂÖàÊøÄÊ¥ªÂºÄÂèëËÄÖÊ®°Âºè (ËæìÂÖ• "dev [password]")';
                        break;
                    }
                    
                    if (args.length === 0) {
                        output.innerHTML += '\nÁî®Ê≥ï: kick [Áé©ÂÆ∂ÂêçÊàñID] [force]';
                        output.innerHTML += '\nÁ§∫‰æã: kick player1 - ÂêëÊàø‰∏ªÂèëÈÄÅË∏¢Âá∫ËØ∑Ê±Ç';
                        output.innerHTML += '\n       kick player1 force - Âº∫Âà∂Ë∏¢Âá∫(Êó†ÈúÄÊàø‰∏ªÁ°ÆËÆ§)';
                        output.innerHTML += '\n‰ΩøÁî® "players" ÂëΩ‰ª§Êü•ÁúãÊâÄÊúâÁé©ÂÆ∂';
                        break;
                    }
            
                    const playerToKick = args[0];
                    const forceKick = args[1] === 'force'; // ÊòØÂê¶Âº∫Âà∂Ë∏¢Âá∫
                    if (gameState.currentScreen === 'multiplayerGame') {
                        // Êü•ÊâæÁé©ÂÆ∂
                        let playerId = null;
                        const players = gameState.multiplayer.players;
                        for (const id in players) {
                            if (players[id].name === playerToKick || id === playerToKick) {
                                playerId = id;
                                break;
                            }
                        }
                
                        if (playerId) {
                            // Ê£ÄÊü•Áé©ÂÆ∂ÊòØÂê¶Âèó‰øùÊä§
                            if (gameState.multiplayer.protectedPlayers[playerId]) {
                                output.innerHTML += '\nË∏¢Âá∫Â§±Ë¥•Ôºöerr75937 (Áé©ÂÆ∂Âèó‰øùÊä§)';
                            } else {
                                if (forceKick || !gameState.multiplayer.isHost) {
                                    // Âº∫Âà∂Ë∏¢Âá∫ÊàñÈùûÊàø‰∏ªÁõ¥Êé•ÂèëÈÄÅË∏¢Âá∫ËØ∑Ê±Ç
                                    sendKickRequest(playerId, 'ÊéßÂà∂Âè∞Ë∏¢Âá∫' + (forceKick ? '(Âº∫Âà∂)' : ''));
                                    output.innerHTML += `\nÂ∑≤ÂèëÈÄÅË∏¢Âá∫ ${playerToKick} ÁöÑËØ∑Ê±Ç` + (forceKick ? ' (Âº∫Âà∂)' : '');
                                } else {
                                    // Êàø‰∏ªÁõ¥Êé•Ë∏¢‰∫∫
                                    kickPlayer(playerId, 'ÊéßÂà∂Âè∞Ë∏¢Âá∫');
                                    output.innerHTML += `\nÂ∑≤Ë∏¢Âá∫Áé©ÂÆ∂: ${playerToKick}`;
                                }
                            }
                        } else {
                            output.innerHTML += `\nÊú™ÊâæÂà∞Áé©ÂÆ∂: ${playerToKick}`;
                        }
                    } else {
                        output.innerHTML += '\nÊ≠§ÂëΩ‰ª§Âè™ËÉΩÂú®Â§ö‰∫∫Ê∏∏Êàè‰∏≠‰ΩøÁî®';
                    }
                    break;
                case 'protect':
                    if (!gameState.devMode) {
                        output.innerHTML += '\nËØ∑ÂÖàÊøÄÊ¥ªÂºÄÂèëËÄÖÊ®°Âºè (ËæìÂÖ• "dev [password]")';
                        break;
                    }
                    
                    if (args.length === 0) {
                        output.innerHTML += '\nÁî®Ê≥ï: protect [Áé©ÂÆ∂ÂêçÊàñID]';
                        output.innerHTML += '\nÁ§∫‰æã: protect player1';
                        output.innerHTML += '\n‰ΩøÁî® "players" ÂëΩ‰ª§Êü•ÁúãÊâÄÊúâÁé©ÂÆ∂';
                        break;
                    }
                    
                    const playerToProtect = args[0];
                    if (gameState.currentScreen === 'multiplayerGame') {
                        // Êü•ÊâæÁé©ÂÆ∂
                        let playerId = null;
                        const players = gameState.multiplayer.players;
                        for (const id in players) {
                            if (players[id].name === playerToProtect || id === playerToProtect) {
                                playerId = id;
                                break;
                            }
                        }
                        
                        if (playerId) {
                            gameState.multiplayer.protectedPlayers[playerId] = true;
                            output.innerHTML += `\nÂ∑≤‰øùÊä§Áé©ÂÆ∂: ${playerToProtect}`;
                            
                            // ÂπøÊí≠‰øùÊä§Áä∂ÊÄÅ
                            broadcast({
                                type: 'player-protected',
                                playerId: playerId,
                                protected: true
                            });
                        } else {
                            output.innerHTML += `\nÊú™ÊâæÂà∞Áé©ÂÆ∂: ${playerToProtect}`;
                        }
                    } else {
                        output.innerHTML += '\nÊ≠§ÂëΩ‰ª§Âè™ËÉΩÂú®Â§ö‰∫∫Ê∏∏Êàè‰∏≠‰ΩøÁî®';
                    }
                    break;
                    
                case 'unprotect':
                    if (!gameState.devMode) {
                        output.innerHTML += '\nËØ∑ÂÖàÊøÄÊ¥ªÂºÄÂèëËÄÖÊ®°Âºè (ËæìÂÖ• "dev [password]")';
                        break;
                    }
                    
                    if (args.length === 0) {
                        output.innerHTML += '\nÁî®Ê≥ï: unprotect [Áé©ÂÆ∂ÂêçÊàñID]';
                        output.innerHTML += '\nÁ§∫‰æã: unprotect player1';
                        output.innerHTML += '\n‰ΩøÁî® "players" ÂëΩ‰ª§Êü•ÁúãÊâÄÊúâÁé©ÂÆ∂';
                        break;
                    }
                    
                    const playerToUnprotect = args[0];
                    if (gameState.currentScreen === 'multiplayerGame') {
                        // Êü•ÊâæÁé©ÂÆ∂
                        let playerId = null;
                        const players = gameState.multiplayer.players;
                        for (const id in players) {
                            if (players[id].name === playerToUnprotect || id === playerToUnprotect) {
                                playerId = id;
                                break;
                            }
                        }
                        
                        if (playerId) {
                            delete gameState.multiplayer.protectedPlayers[playerId];
                            output.innerHTML += `\nÂ∑≤ÂèñÊ∂à‰øùÊä§Áé©ÂÆ∂: ${playerToUnprotect}`;
                            
                            // ÂπøÊí≠‰øùÊä§Áä∂ÊÄÅ
                            broadcast({
                                type: 'player-protected',
                                playerId: playerId,
                                protected: false
                            });
                        } else {
                            output.innerHTML += `\nÊú™ÊâæÂà∞Áé©ÂÆ∂: ${playerToUnprotect}`;
                        }
                    } else {
                        output.innerHTML += '\nÊ≠§ÂëΩ‰ª§Âè™ËÉΩÂú®Â§ö‰∫∫Ê∏∏Êàè‰∏≠‰ΩøÁî®';
                    }
                    break;
                    
                case 'win':
                    if (!gameState.devMode) {
                        output.innerHTML += '\nËØ∑ÂÖàÊøÄÊ¥ªÂºÄÂèëËÄÖÊ®°Âºè (ËæìÂÖ• "dev [password]")';
                        break;
                    }
                    
                    if (gameState.currentScreen === 'singlePlayerGame') {
                        // ÂÆåÊàêÂΩìÂâçÂÖ≥Âç°
                        singlePlayerGame.player.x = singlePlayerGame.exit.x;
                        singlePlayerGame.player.y = singlePlayerGame.exit.y;
                        checkSinglePlayerExit();
                        output.innerHTML += '\nÂΩìÂâçÂÖ≥Âç°Â∑≤ÈÄöÂÖ≥ÔºÅ';
                    } else {
                        output.innerHTML += '\nÂè™ËÉΩÂú®Ê∏∏ÊàèÂÖ≥Âç°‰∏≠‰ΩøÁî®Ê≠§ÂëΩ‰ª§';
                    }
                    break;
                    
                case 'level':
                    if (!gameState.devMode) {
                        output.innerHTML += '\nËØ∑ÂÖàÊøÄÊ¥ªÂºÄÂèëËÄÖÊ®°Âºè (ËæìÂÖ• "dev [password]")';
                        break;
                    }
                    
                    if (args.length === 0) {
                        output.innerHTML += '\nÈúÄË¶ÅÂÖ≥Âç°Âè∑ (1-80)';
                        break;
                    }
                    
                    const levelNum = parseInt(args[0]);
                    if (isNaN(levelNum) || levelNum < 1 || levelNum > 80) {
                        output.innerHTML += '\nÊó†ÊïàÁöÑÂÖ≥Âç°Âè∑ (ÂøÖÈ°ª‰ªã‰∫é1-80)';
                        break;
                    }
                    
                    gameState.currentLevel = levelNum;
                    if (gameState.currentScreen === 'singlePlayerGame') {
                        initSinglePlayerGame();
                        output.innerHTML += `\nÂ∑≤Ë∑≥ËΩ¨Âà∞Á¨¨ ${levelNum} ÂÖ≥`;
                    } else {
                        showScreen('singlePlayerGame');
                        output.innerHTML += `\nÂ∑≤ÂºÄÂßãÁ¨¨ ${levelNum} ÂÖ≥`;
                    }
                    break;
                    
                case 'unlockall':
                    if (!gameState.devMode) {
                        output.innerHTML += '\nËØ∑ÂÖàÊøÄÊ¥ªÂºÄÂèëËÄÖÊ®°Âºè (ËæìÂÖ• "dev [password]")';
                        break;
                    }
                    
                    gameState.unlockedLevel = 80;
                    localStorage.setItem('unlockedLevel', 80);
                    output.innerHTML += '\nÊâÄÊúâÂÖ≥Âç°Â∑≤Ëß£ÈîÅÔºÅ';
                    if (gameState.currentScreen === 'singlePlayerLevelSelect') {
                        generateLevelButtons();
                    }
                    break;
                    
                case 'reset':
                    if (!gameState.devMode) {
                        output.innerHTML += '\nËØ∑ÂÖàÊøÄÊ¥ªÂºÄÂèëËÄÖÊ®°Âºè (ËæìÂÖ• "dev [password]")';
                        break;
                    }
                    
                    if (gameState.currentScreen === 'singlePlayerGame') {
                        resetSinglePlayerLevel();
                        output.innerHTML += '\nÂΩìÂâçÂÖ≥Âç°Â∑≤ÈáçÁΩÆ';
                    } else {
                        output.innerHTML += '\nÂè™ËÉΩÂú®Ê∏∏ÊàèÂÖ≥Âç°‰∏≠‰ΩøÁî®Ê≠§ÂëΩ‰ª§';
                    }
                    break;
                    
                case 'clear':
                    output.innerHTML = '> ÊéßÂà∂Âè∞Â∑≤Ê∏ÖÁ©∫';
                    break;
                case 'kick-request':
                        console.log(data);
                        // Âè™ÊúâÊàø‰∏ªËÉΩÂ§ÑÁêÜË∏¢‰∫∫ËØ∑Ê±Ç
                        if (gameState.multiplayer.isHost) {
                            const playerId = data.playerId;
                            const requestorId = data.requestorId;
                            const reason = data.reason || 'Êú™Áü•ÂéüÂõ†';
                            
                            // Ê£ÄÊü•Áé©ÂÆ∂ÊòØÂê¶Âèó‰øùÊä§
                            if (gameState.multiplayer.protectedPlayers[playerId]) {
                                // ÂèëÈÄÅË∏¢Âá∫Â§±Ë¥•Ê∂àÊÅØÁªôËØ∑Ê±ÇËÄÖ
                                if (gameState.multiplayer.connections[requestorId]) {
                                    gameState.multiplayer.connections[requestorId].send({
                                        type: 'kick-failed',
                                        playerId: playerId,
                                        reason: 'err75937'
                                    });
                                }
                            } else {
                                // Ë∏¢Âá∫Áé©ÂÆ∂
                                kickPlayer(playerId, reason + ' (Áî±Áé©ÂÆ∂ËØ∑Ê±Ç)');
                                
                                // ÈÄöÁü•ËØ∑Ê±ÇËÄÖË∏¢Âá∫ÊàêÂäü
                                if (gameState.multiplayer.connections[requestorId]) {
                                    gameState.multiplayer.connections[requestorId].send({
                                        type: 'kick-success',
                                        playerId: playerId
                                    });
                                }
                            }
                        }
                        break;
                        
                    case 'kick-success':
                        console.log(data);
                        document.getElementById('consoleOutput').innerHTML += `\nÁé©ÂÆ∂ ${data.playerId} Â∑≤Ë¢´Êàø‰∏ªË∏¢Âá∫`;
                        break;
                    case 'eventsystem':
                        if (args.length > 0) {
                            EventSystem.triggerById(args[0]);
                            output.innerHTML += `\nÂΩìÂâçËß¶Âèë‰∫Ü‰∫ã‰ª∂: ${args[0]}`;
                        }
                        break;
                        default:
                            output.innerHTML += `\nÊú™Áü•ÂëΩ‰ª§: ${command}\nËæìÂÖ• "help" Êü•ÁúãÂèØÁî®ÂëΩ‰ª§`;
                    }
            
            output.scrollTop = output.scrollHeight;
        }

function startMapSelection(targetPlayerId = null) {
    // ‰øùÂ≠òÂΩìÂâçÊ∏∏ÊàèÁä∂ÊÄÅÂíåÁõÆÊ†áÁé©ÂÆ∂
    gameState.mapSelectionMode = true;
    gameState.mapSelectionTarget = targetPlayerId;
    
    // Ê∑ªÂä†Âú∞ÂõæÁÇπÂáª‰∫ã‰ª∂ÁõëÂê¨
    if (gameState.currentScreen === 'singlePlayerGame') {
        singlePlayerGame.canvas.addEventListener('click', handleMapClick);
        document.getElementById('consoleOutput').innerHTML += 
            '\nÂú∞ÂõæÈÄâÊã©Ê®°ÂºèÂ∑≤ÊøÄÊ¥ªÔºåÁÇπÂáªÂú∞Âõæ‰∏äÁöÑ‰ΩçÁΩÆËøõË°å‰º†ÈÄÅ';
        console.log('Âú∞ÂõæÈÄâÊã©Ê®°ÂºèÂ∑≤ÊøÄÊ¥ª');
        showNotification('Âú∞ÂõæÈÄâÊã©Ê®°ÂºèÂ∑≤ÊøÄÊ¥ªÔºåÁÇπÂáªÂú∞Âõæ‰∏äÁöÑ‰ΩçÁΩÆËøõË°å‰º†ÈÄÅ');
    } else if (gameState.currentScreen === 'multiplayerGame') {
        multiplayerCanvas.addEventListener('click', handleMapClick);
        document.getElementById('consoleOutput').innerHTML += 
            `\nÂú∞ÂõæÈÄâÊã©Ê®°ÂºèÂ∑≤ÊøÄÊ¥ªÔºåÁÇπÂáªÂú∞Âõæ‰∏äÁöÑ‰ΩçÁΩÆËøõË°å‰º†ÈÄÅ${targetPlayerId ? ' ÁõÆÊ†áÁé©ÂÆ∂: ' + targetPlayerId : ''}`;
    } else {
        document.getElementById('consoleOutput').innerHTML += 
            '\nÂú∞ÂõæÈÄâÊã©Ê®°ÂºèÂè™ËÉΩÂú®Ê∏∏Êàè‰∏≠ËøõË°å';
        gameState.mapSelectionMode = false;
    }
}

function handleMapClick(e) {
    if (!gameState.mapSelectionMode) return;
    
    let canvas, cellSize, maze;
    
    // Ê†πÊçÆÂΩìÂâçÊ∏∏ÊàèÊ®°ÂºèËé∑ÂèñÊ≠£Á°ÆÁöÑÁîªÂ∏ÉÂíåÂèÇÊï∞
    if (gameState.currentScreen === 'singlePlayerGame') {
        canvas = singlePlayerGame.canvas;
        cellSize = singlePlayerGame.cellSize;
        maze = singlePlayerGame.maze;
    } else if (gameState.currentScreen === 'multiplayerGame') {
        canvas = document.getElementById('multiplayerCanvas');
        // ËÆ°ÁÆóÂ§ö‰∫∫Ê∏∏ÊàèÁöÑÂçïÂÖÉÊ†ºÂ§ßÂ∞è
        const mazeWidth = gameState.multiplayer.maze[0].length;
        cellSize = canvas.width / mazeWidth;
        maze = gameState.multiplayer.maze;
    } else {
        return;
    }
    
    // Ëé∑ÂèñÁîªÂ∏ÉÁõ∏ÂØπ‰∫éËßÜÂè£ÁöÑ‰ΩçÁΩÆ
    const rect = canvas.getBoundingClientRect();
    
    // ËÆ°ÁÆóÁÇπÂáª‰ΩçÁΩÆÁõ∏ÂØπ‰∫éÁîªÂ∏ÉÁöÑÂùêÊ†á
    const clickX = e.clientX - rect.left;
    const clickY = e.clientY - rect.top;
    
    // ËΩ¨Êç¢‰∏∫Ëø∑ÂÆ´ÂùêÊ†á
    const x = Math.floor(clickX / cellSize);
    const y = Math.floor(clickY / cellSize);
    
    // È™åËØÅÂùêÊ†áÊòØÂê¶ÊúâÊïà
    if (x < 0 || x >= maze[0].length || y < 0 || y >= maze.length) {
        document.getElementById('consoleOutput').innerHTML += 
            `\nÈîôËØØ: ÂùêÊ†á(${x},${y})Ë∂ÖÂá∫Ëø∑ÂÆ´ËåÉÂõ¥`;
        return;
    }
    
    // Ê£ÄÊü•ÊòØÂê¶ÊòØÂ¢ô
    if (maze[y][x] === 1) {
        document.getElementById('consoleOutput').innerHTML += 
            `\nÈîôËØØ: ÂùêÊ†á(${x},${y})ÊòØÂ¢ôÔºåÊó†Ê≥ï‰º†ÈÄÅ`;
        return;
    }
    
    // ‰º†ÈÄÅÁé©ÂÆ∂
    const success = teleportPlayer(x, y, gameState.mapSelectionTarget);
    
    if (success) {
        document.getElementById('consoleOutput').innerHTML += 
            `\nÂ∑≤‰º†ÈÄÅÂà∞ÂùêÊ†á(${x},${y})`;
    }
    
    // ÈÄÄÂá∫Âú∞ÂõæÈÄâÊã©Ê®°Âºè
    gameState.mapSelectionMode = false;
    gameState.mapSelectionTarget = null;
    showNotification(`‰º†ÈÄÅÊàêÂäüÔºÅ‰Ω†Â∑≤Âà∞ËææÂùêÊ†á(${x},${y})„ÄÇ`);
    
    
    // ÁßªÈô§ÁÇπÂáª‰∫ã‰ª∂ÁõëÂê¨
    canvas.removeEventListener('click', handleMapClick);
    
    document.getElementById('consoleOutput').innerHTML += 
        `\nÂú∞ÂõæÈÄâÊã©Ê®°ÂºèÂ∑≤ÂÖ≥Èó≠`;
}

// =============== Áé©ÂÆ∂‰º†ÈÄÅÂäüËÉΩ ===============
function teleportPlayer(x, y, targetPlayerId = null) {
    // Ê£ÄÊü•ÂùêÊ†áÊòØÂê¶ÊúâÊïà
    if (!isValidPosition(x, y)) {
        document.getElementById('consoleOutput').innerHTML += 
            `\nÈîôËØØ: ÂùêÊ†á(${x},${y})Êó†ÊïàÊàñ‰∏çÂèØÂà∞Ëææ`;
        return false;
    }
    
    if (gameState.currentScreen === 'singlePlayerGame') {
        // Âçï‰∫∫Ê∏∏ÊàèÂè™ËÉΩ‰º†ÈÄÅËá™Â∑±
        if (targetPlayerId && targetPlayerId !== 'singleplayer') {
            document.getElementById('consoleOutput').innerHTML += 
                '\nÂçï‰∫∫Ê®°Âºè‰∏ãÂè™ËÉΩ‰º†ÈÄÅËá™Â∑±';
            return false;
        }
        
        singlePlayerGame.player.x = x;
        singlePlayerGame.player.y = y;
        drawSinglePlayerMaze();
        
        // Ê£ÄÊü•ÊòØÂê¶Âà∞ËææÂá∫Âè£
        checkSinglePlayerExit();
        
    } else if (gameState.currentScreen === 'multiplayerGame') {
        // Á°ÆÂÆöË¶Å‰º†ÈÄÅÁöÑÁé©ÂÆ∂
        let playerId;
        if (targetPlayerId) {
            playerId = targetPlayerId;
        } else {
            playerId = gameState.multiplayer.currentPlayerId;
        }
        
        const player = gameState.multiplayer.players[playerId];
        
        if (!player) {
            document.getElementById('consoleOutput').innerHTML += 
                `\nÈîôËØØ: Êâæ‰∏çÂà∞Áé©ÂÆ∂ ID ${playerId}`;
            return false;
        }
           
        player.x = x;
        player.y = y;
        
        // ÂπøÊí≠
        broadcast({
            type: 'player-teleport',
            playerId: playerId,
            x: x,
            y: y
        });
        
        drawMultiplayerMaze();
        updatePlayerList();
        
        // Ê£ÄÊü•ÊòØÂê¶Âà∞ËææÂá∫Âè£
        if (x === gameState.multiplayer.exit.x && y === gameState.multiplayer.exit.y) {
            player.reachedExit = true;
            
            // ÂπøÊí≠Âà∞ËææÂá∫Âè£
            broadcast({
                type: 'player-reached-exit',
                playerId: playerId
            });
            
            // Ê£ÄÊü•ÊòØÂê¶ÊâÄÊúâÁé©ÂÆ∂ÈÉΩÂà∞ËææÂá∫Âè£
            checkAllPlayersReachedExit();
        }
    }
    
    return true;
}

// =============== ‰ΩçÁΩÆÈ™åËØÅ ===============
function isValidPosition(x, y) {
    let maze;
    
    if (gameState.currentScreen === 'singlePlayerGame') {
        maze = singlePlayerGame.maze;
    } else if (gameState.currentScreen === 'multiplayerGame') {
        maze = gameState.multiplayer.maze;
    } else {
        return false;
    }
    
    // Ê£ÄÊü•Ëø∑ÂÆ´ÊòØÂê¶ÊúâÊïà
    if (!maze || maze.length === 0) {
        return false;
    }
    
    // Ê£ÄÊü•ÂùêÊ†áÊòØÂê¶Âú®Ëø∑ÂÆ´ËåÉÂõ¥ÂÜÖ
    if (x < 0 || x >= maze[0].length || y < 0 || y >= maze.length) {
        return false;
    }
    
    // Ê£ÄÊü•ÊòØÂê¶ÊòØÂ¢ô
    if (maze[y][x] === 1) {
        return false;
    }
    
    return true;
}

        // =============== Âçï‰∫∫Ê∏∏ÊàèÈÄªËæë ===============

        function generateLevelButtons() {
            const container = document.getElementById('levelContainer');
            container.innerHTML = '';
            container.style.touchAction = 'pan-y'; // Á°Æ‰øùËß¶Êë∏Ë°å‰∏∫‰ºòÂåñ
            for (let i = 1; i <= 80; i++) {
                const button = document.createElement('button');
                button.className = 'level-button';
                if (i > gameState.unlockedLevel) {
                    button.classList.add('locked');
                    button.disabled = true;
                } else if (gameState.completedLevels.includes(i)) {
                    button.classList.add('completed');
                }
                
                // Ê†áËÆ∞Êó†Ëß£ÂÖ≥Âç°
                if (gameState.unsolvableLevels.includes(i)) {
                    button.classList.add('unsolvable');
                }
                
                button.textContent = i;
                button.onclick = () => {
                    gameState.currentLevel = i;
                    showScreen('singlePlayerGame');
                };
                container.appendChild(button);
            }
        }

function initSinglePlayerGame(isLoadingSave = false) {
    window.removeEventListener('keydown', handleSinglePlayerKeyDown);
    singlePlayerGame.canvas = document.getElementById('singlePlayerCanvas');
    singlePlayerGame.ctx = singlePlayerGame.canvas.getContext('2d');
    singlePlayerGame.moveCount = 0;
    singlePlayerGame.movingEnemies = [];
    singlePlayerGame.doorPosition = null;
    singlePlayerGame.keyPosition = null;
    singlePlayerGame.isUnlocking = false;
    singlePlayerGame.unlockTimeLeft = 10;
    singlePlayerGame.hasKey = false;
    clearInterval(singlePlayerGame.unlockTimer);
    if (!isLoadingSave) {
        const difficulty = Math.min(
            Math.floor(gameState.currentLevel / 7), 
            singlePlayerGame.difficultySettings.length - 1
        );
        const settings = singlePlayerGame.difficultySettings[difficulty];
        singlePlayerGame.maze = generateDifficultMaze(gameState.currentLevel, settings);
        singlePlayerGame.player = findStartPosition(singlePlayerGame.maze);
        singlePlayerGame.hasKey = false;
    }
    if (!window.EventSystemInitialized) {
        EventSystem.init();
        window.EventSystemInitialized = true;
    }
    document.getElementById('regularNextButton').style.display = 'none';
    document.getElementById('unsolvableNextButton').style.display = 'none';
    document.getElementById('levelDisplay').textContent = `ÂÖ≥Âç°: ${gameState.currentLevel}`;
    document.getElementById('moveCount').textContent = `ÁßªÂä®: 0`;
    document.getElementById('keyStatus').textContent = `Èí•Âåô: Êú™Ëé∑Âæó`;
    
    // ÈöêËóèÁâπÊÆäÂÖÉÁ¥†ÊèêÁ§∫
    document.getElementById('keyInfo').classList.add('hidden');
    document.getElementById('unlockTimer').classList.add('hidden');
    document.getElementById('enemyInfo').classList.add('hidden');
    
    // Ê†πÊçÆÂÖ≥Âç°ÈöæÂ∫¶ËÆæÁΩÆÁîüÊàêËø∑ÂÆ´
    const difficulty = Math.min(
        Math.floor(gameState.currentLevel / 7), 
        singlePlayerGame.difficultySettings.length - 1
    );
    const settings = singlePlayerGame.difficultySettings[difficulty];
    if (gameState.autoSave) {
        loadGame(); // Â∞ùËØïÂä†ËΩΩ‰∏äÊ¨°ÁöÑÂ≠òÊ°£
    }
    // ÁâπÊÆäÂÖ≥Âç°Â§ÑÁêÜ
    if (gameState.currentLevel === 20) {
        let validMaze = false;
        let attempts = 0;
        while (!validMaze && attempts < 10) {
            singlePlayerGame.maze = generateDifficultMaze(gameState.currentLevel, settings);
            validMaze = validateMaze(singlePlayerGame.maze);
            attempts++;
        }
        if (!validMaze) {
            console.log("ÂÖ≥Âç°ÁîüÊàêÂ§±Ë¥•Ôºå‰ΩøÁî®Â§áÁî®Ëø∑ÂÆ´");
            singlePlayerGame.maze = generateBackupMaze(settings.size);
        }
    } 
    // ÁâπÊÆäËû∫ÊóãÂÖ≥Âç°Ôºö30Âíå60ÂÖ≥
    else if (gameState.specialLevels.includes(gameState.currentLevel)) {
        singlePlayerGame.maze = generateSpiralMaze(settings.size);
        // ËÆæÁΩÆËµ∑ÁÇπÂíåÁªàÁÇπ
        const size = settings.size;
        singlePlayerGame.player = { x: 1, y: size - 2 };
        singlePlayerGame.exit = { x: Math.floor(size/2), y: Math.floor(size/2) };
        // Ê∑ªÂä†ÁßªÂä®Êïå‰∫∫
        addMovingEnemies(settings.size, gameState.currentLevel === 60 ? 5 : 3);
        // ÊòæÁ§∫Êïå‰∫∫Ë≠¶Âëä
        document.getElementById('enemyInfo').classList.remove('hidden');
        
        // Ê∑ªÂä†Èí•ÂåôÂíåÈó®
        addKeyAndDoor(size);
        document.getElementById('keyInfo').classList.remove('hidden');
    } 
    else {
        singlePlayerGame.maze = generateDifficultMaze(gameState.currentLevel, settings);
    }
    
    // ËÆæÁΩÆÁé©ÂÆ∂ÂíåÂá∫Âè£‰ΩçÁΩÆÔºàÈùûÁâπÊÆäÂÖ≥Âç°Ôºâ
    if (!gameState.specialLevels.includes(gameState.currentLevel)) {
        singlePlayerGame.player = findStartPosition(singlePlayerGame.maze);
        singlePlayerGame.exit = findExitPosition(singlePlayerGame.maze);
    }
    
    // Ë∞ÉÊï¥ÁîªÂ∏ÉÂ§ßÂ∞è
    resizeSinglePlayerCanvas();
    
    // ÂºÄÂßãÊ∏∏Êàè
    startSinglePlayerTimer();
    drawSinglePlayerMaze();
    
    // Ê∑ªÂä†ÈîÆÁõò‰∫ã‰ª∂ÁõëÂê¨
    window.addEventListener('keydown', handleSinglePlayerKeyDown);
    
    // ÂêØÂä®ÁßªÂä®Èô∑Èò±
    if (settings.movingTraps > 0 || 
        gameState.specialLevels.includes(gameState.currentLevel)) {
        startMovingTraps();
    }
    updateNextLevelButtons();
    // Â∫îÁî®UIËÆæÁΩÆ
    applyUISettings();
    if (gameState.specialLevels.includes(gameState.currentLevel)) {
        document.getElementById('enemyInfo').classList.remove('hidden');
    }
}
class GameRecorder {
    constructor() {
        this.frames = [];
        this.startTime = 0;
        this.isRecording = false;
    }

    startRecording(canvas) {
        this.frames = [];
        this.startTime = Date.now();
        this.isRecording = true;
        
        // ‰ΩøÁî®requestAnimationFrameÊçïËé∑ÁîªÈù¢
        const captureFrame = () => {
            if(!this.isRecording) return;
            this.frames.push({
                timestamp: Date.now() - this.startTime,
                imageData: canvas.toDataURL('image/webp', 0.8)
            });
            requestAnimationFrame(captureFrame);
        };
        captureFrame();
    }
    static getAllRecords() {
        return JSON.parse(localStorage.getItem('gameRecords') || "[]")
            .map((record, index) => ({ ...record, id: index }))
            .sort((a,b) => new Date(b.metadata.timestamp) - new Date(a.metadata.timestamp));
    }
    static deleteRecord(id) {
        const records = this.getAllRecords();
        const newRecords = records.filter(r => r.id !== id);
        localStorage.setItem('gameRecords', JSON.stringify(newRecords));
    }
    static getStorageUsage() {
        const records = this.getAllRecords();
        const used = JSON.stringify(records).length / (1024 * 1024);
        const max = parseInt(localStorage.getItem('maxRecordStorage') || "300");
        return { used: used.toFixed(1), max, percent: (used/max*100).toFixed(1) };
    }
    stopRecording() {
        this.isRecording = false;
        this.saveToLocalStorage();
    }

    saveToLocalStorage() {
        const recordData = {
            version: 1.0,
            metadata: {
                level: gameState.currentLevel,
                timestamp: new Date().toISOString(),
                duration: Date.now() - this.startTime,
                playerName: gameState.playerName
            },
            frames: this.frames
        };
        
        // Â≠òÂÇ®ÁÆ°ÁêÜ
        const records = JSON.parse(localStorage.getItem('gameRecords') || "[]");
        records.push(recordData);
        
        // Ëá™Âä®Ê∏ÖÁêÜÊóßÂΩïÂÉè
        let totalSize = 0;
        const cleanRecords = records.reverse().filter(record => {
            totalSize += JSON.stringify(record).length;
            return totalSize < document.getElementById('maxStorage').value * 1024 * 1024;
        }).reverse();
        
        localStorage.setItem('gameRecords', JSON.stringify(cleanRecords));
    }

    replay(recordId) {
        const record = JSON.parse(localStorage.getItem('gameRecords'))[recordId];
        const replayCanvas = document.createElement('canvas');
        // ÂÆûÁé∞ÂõûÊîæÈÄªËæë...
    }
}
class ReplayPlayer {
    constructor() {
        this.currentFrame = 0;
        this.isPlaying = false;
        this.playbackSpeed = 1;
        this.animationFrame = null;
    }
    load(replayData) {
        this.replayData = replayData;
        this.canvas = document.getElementById('replayCanvas');
        this.ctx = this.canvas.getContext('2d');
        this.canvas.width = replayData.metadata.width || 800;
        this.canvas.height = replayData.metadata.height || 600;
        
        document.getElementById('replayTitle').textContent = 
            `ÂÖ≥Âç°${replayData.metadata.level} - ${new Date(replayData.metadata.timestamp).toLocaleString()}`;
        
        this.showFrame(0);
    }
    showFrame(index) {
        this.currentFrame = Math.max(0, Math.min(index, this.replayData.frames.length-1));
        const frame = this.replayData.frames[this.currentFrame];
        
        const img = new Image();
        img.onload = () => {
            this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
            this.ctx.drawImage(img, 0, 0);
            this.updateProgress();
        };
        img.src = frame.imageData;
    }
    play() {
        if(this.isPlaying) return;
        this.isPlaying = true;
        document.getElementById('playBtn').textContent = '‚è∏Ô∏è ÊöÇÂÅú';
        
        const startTime = Date.now() - (this.currentFrame * 1000 / this.playbackSpeed);
        
        const playLoop = () => {
            if(!this.isPlaying) return;
            
            const elapsed = (Date.now() - startTime) * this.playbackSpeed;
            const targetFrame = Math.floor(elapsed / 1000 * 60); // ÂÅáËÆæ60fps
            
            if(targetFrame < this.replayData.frames.length) {
                this.showFrame(targetFrame);
                this.animationFrame = requestAnimationFrame(playLoop);
            } else {
                this.stop();
            }
        };
        
        playLoop();
    }
    stop() {
        this.isPlaying = false;
        cancelAnimationFrame(this.animationFrame);
        document.getElementById('playBtn').textContent = '‚ñ∂Ô∏è Êí≠Êîæ';
    }
    updateProgress() {
        const progress = (this.currentFrame / this.replayData.frames.length) * 100;
        document.getElementById('replayProgress').value = progress;
        
        const currentTime = (this.currentFrame / 60).toFixed(1);
        const totalTime = (this.replayData.frames.length / 60).toFixed(1);
        document.getElementById('timeDisplay').textContent = 
            `${formatTime(currentTime)} / ${formatTime(totalTime)}`;
    }
}
// ÂÖ®Â±ÄÊí≠ÊîæÂô®ÂÆû‰æã
const replayPlayer = new ReplayPlayer();
// ÊâìÂºÄÂõûÊîæÁïåÈù¢
function showReplayModal() {
    document.getElementById('replayModal').classList.remove('hidden');
    renderReplayList();
    updateStorageInfo();
}
function closeReplayModal() {
    document.getElementById('replayModal').classList.add('hidden');
    replayPlayer.stop();
}
function renderReplayList(filter = 'all') {
    const listEl = document.getElementById('replayList');
    listEl.innerHTML = '';
    
    const records = GameRecorder.getAllRecords();
    
    // Â∫îÁî®Á≠õÈÄâ
    const filteredRecords = filter === 'recent' 
        ? records.filter(r => new Date(r.metadata.timestamp) > Date.now() - 7*86400000)
        : records;
    
    if(filteredRecords.length === 0) {
        listEl.innerHTML = '<div class="no-records">ÊöÇÊó†ÂΩïÂÉèËÆ∞ÂΩï</div>';
        return;
    }
    
    filteredRecords.forEach(record => {
        const item = document.createElement('div');
        item.className = 'replay-item';
        item.innerHTML = `
            <div class="replay-meta">
                <strong>ÂÖ≥Âç° ${record.metadata.level}</strong>
                <span>${new Date(record.metadata.timestamp).toLocaleString()}</span>
            </div>
            <div>
                Êó∂ÈïøÔºö${formatTime(record.metadata.duration/1000)} | 
                Áé©ÂÆ∂Ôºö${record.metadata.playerName || 'ÂåøÂêç'}
            </div>
            <div class="replay-actions">
                <button onclick="playReplay(${record.id})">Êí≠Êîæ</button>
                <button onclick="deleteReplay(${record.id})">Âà†Èô§</button>
            </div>
        `;
        listEl.appendChild(item);
    });
}
function playReplay(id) {
    const records = GameRecorder.getAllRecords();
    const record = records.find(r => r.id === id);
    if(!record) return;
    
    document.getElementById('replayList').classList.add('hidden');
    document.getElementById('playerContainer').classList.remove('hidden');
    
    replayPlayer.load(record);
}
function exitPlayer() {
    replayPlayer.stop();
    document.getElementById('replayList').classList.remove('hidden');
    document.getElementById('playerContainer').classList.add('hidden');
}
function togglePlay() {
    if(replayPlayer.isPlaying) {
        replayPlayer.stop();
    } else {
        replayPlayer.play();
    }
}
function seekForward() {
    replayPlayer.showFrame(replayPlayer.currentFrame + 5*60); // ÂâçËøõ5Áßí(ÂÅáËÆæ60fps)
}
function seekBack() {
    replayPlayer.showFrame(replayPlayer.currentFrame - 5*60); // ÂêéÈÄÄ5Áßí
}
function deleteReplay(id) {
    if(confirm('Á°ÆÂÆöÂà†Èô§Ê≠§ÂΩïÂÉèÂêóÔºü')) {
        GameRecorder.deleteRecord(id);
        renderReplayList(document.getElementById('replayFilter').value);
        updateStorageInfo();
    }
}
function updateStorageInfo() {
    const usage = GameRecorder.getStorageUsage();
    document.getElementById('storageInfo').textContent = 
        `Â∑≤‰ΩøÁî®Ôºö${usage.used}MB/${usage.max}MB (${usage.percent}%)`;
}
// Â∑•ÂÖ∑ÂáΩÊï∞
function formatTime(seconds) {
    const mins = Math.floor(seconds / 60);
    const secs = Math.floor(seconds % 60);
    return `${mins}:${secs.toString().padStart(2, '0')}`;
}
// Âú®ÂÖ≥Âç°ÁîüÊàêÈÄªËæë‰∏≠Ê∑ªÂä†
function generateMovingPlatforms(level) {
    const platformCount = Math.min(Math.floor(level/5), 5);
    singlePlayerGame.movingPlatforms = [];
    
    for(let i=0; i<platformCount; i++) {
        singlePlayerGame.movingPlatforms.push({
            id: i,
            x: Math.floor(Math.random() * (mazeWidth-4)) + 2,
            y: Math.floor(Math.random() * (mazeHeight-4)) + 2,
            path: generatePlatformPath(),
            speed: 0.5 + Math.random(),
            passengers: []
        });
    }
}

function generatePlatformPath() {
    // ÁîüÊàêÁßªÂä®Ë∑ØÂæÑÔºöÁõ¥Á∫ø/ÊñπÂΩ¢/ÂúÜÂΩ¢
    const pathType = Math.floor(Math.random() * 3);
    const centerX = Math.floor(Math.random() * mazeWidth);
    const centerY = Math.floor(Math.random() * mazeHeight);
    
    switch(pathType) {
        case 0: // Ê∞¥Âπ≥
            return { type: 'horizontal', start: centerX-3, end: centerX+3, y: centerY };
        case 1: // Á´ñÁõ¥
            return { type: 'vertical', start: centerY-3, end: centerY+3, x: centerX };
        case 2: // ÂúÜÂΩ¢
            return { type: 'circular', centerX, centerY, radius: 2 };
    }
}
// Âú®drawSinglePlayerMaze‰∏≠Ê∑ªÂä†
function drawMovingPlatforms() {
    const ctx = singlePlayerGame.ctx;
    singlePlayerGame.movingPlatforms.forEach(platform => {
        // Êõ¥Êñ∞‰ΩçÁΩÆ
        updatePlatformPosition(platform);
        
        // ÁªòÂà∂Âπ≥Âè∞
        ctx.fillStyle = '#8BC34A';
        ctx.fillRect(
            platform.x * singlePlayerGame.cellSize,
            platform.y * singlePlayerGame.cellSize,
            singlePlayerGame.cellSize * 2,
            singlePlayerGame.cellSize
        );
        
        // Ê£ÄÊµãÁé©ÂÆ∂Á¢∞Êíû
        checkPlayerOnPlatform(platform);
    });
}

function updatePlatformPosition(platform) {
    switch(platform.path.type) {
        case 'horizontal':
            platform.x += platform.speed * (platform.movingForward ? 1 : -1);
            if(platform.x > platform.path.end) platform.movingForward = false;
            if(platform.x < platform.path.start) platform.movingForward = true;
            break;
        case 'vertical':
            platform.y += platform.speed * (platform.movingForward ? 1 : -1);
            if(platform.y > platform.path.end) platform.movingForward = false;
            if(platform.y < platform.path.start) platform.movingForward = true;
            break;
        case 'circular':
            const angle = Date.now()/1000 * platform.speed;
            platform.x = platform.path.centerX + Math.cos(angle) * platform.path.radius;
            platform.y = platform.path.centerY + Math.sin(angle) * platform.path.radius;
            break;
    }
}


        // Ê∑ªÂä†Èí•ÂåôÂíåÈó®ÔºàÁî®‰∫éÁâπÊÆäÂÖ≥Âç°Ôºâ
        function addKeyAndDoor(size) {
            // ÈöèÊú∫ÊîæÁΩÆÈí•ÂåôÔºàÈÅøÂºÄËµ∑ÁÇπÂíåÁªàÁÇπÔºâ
            let keyX, keyY;
            do {
                keyX = Math.floor(Math.random() * (size - 4)) + 2;
                keyY = Math.floor(Math.random() * (size - 4)) + 2;
            } while (singlePlayerGame.maze[keyY][keyX] === 1 || 
                     (keyX === 1 && keyY === size - 2) || 
                     (keyX === Math.floor(size/2) && keyY === Math.floor(size/2)));
            
            // Âú®Èí•Âåô‰ΩçÁΩÆÊîæÁΩÆÈí•ÂåôÔºàÂÖÉÁ¥†ÂÄº8Ôºâ
            singlePlayerGame.maze[keyY][keyX] = 8;
            singlePlayerGame.keyPosition = {x: keyX, y: keyY};
            
            // Âú®Âá∫Âè£ÂâçÊîæÁΩÆÈó®ÔºàÂÖÉÁ¥†ÂÄº9Ôºâ
            let doorX = singlePlayerGame.exit.x;
            let doorY = singlePlayerGame.exit.y;
            
            // Á°ÆÂÆöÈó®ÁöÑ‰ΩçÁΩÆÔºàÂú®Âá∫Âè£ÊóÅËæπÔºâ
            if (doorX < size-1 && singlePlayerGame.maze[doorY][doorX+1] === 0) {
                doorX++;
            } else if (doorX > 0 && singlePlayerGame.maze[doorY][doorX-1] === 0) {
                doorX--;
            } else if (doorY < size-1 && singlePlayerGame.maze[doorY+1][doorX] === 0) {
                doorY++;
            } else if (doorY > 0 && singlePlayerGame.maze[doorY-1][doorX] === 0) {
                doorY--;
            }
            
            singlePlayerGame.maze[doorY][doorX] = 9;
            singlePlayerGame.doorPosition = {x: doorX, y: doorY};
        }

        // ÁîüÊàêËû∫ÊóãËø∑ÂÆ´ÔºàÁî®‰∫éÁ¨¨30Âíå60ÂÖ≥Ôºâ
        function generateSpiralMaze(size) {
            // Á°Æ‰øùÂ•áÊï∞Â∞∫ÂØ∏
            if (size % 2 === 0) size++;
            
            const maze = Array(size).fill().map(() => Array(size).fill(1));
            
            // ÂàõÂª∫Ëû∫ÊóãË∑ØÂæÑ
            let x = 0, y = 0;
            let dx = 0, dy = 1;
            let steps = size - 1;
            let currentSteps = 0;
            let stepCount = 0;
            let turnCount = 0;
            
            for (let i = 0; i < size * size; i++) {
                maze[y][x] = 0;
                
                // Ê£ÄÊü•ÊòØÂê¶Âà∞Ëææ‰∏≠ÂøÉ
                if (steps <= 0) break;
                
                currentSteps++;
                if (currentSteps === steps) {
                    currentSteps = 0;
                    turnCount++;
                    
                    // ÊØè‰∏§Ê¨°ËΩ¨ÂêëÂáèÂ∞ëÊ≠•Èïø
                    if (turnCount % 2 === 0) {
                        steps--;
                    }
                    
                    // ËΩ¨Âêë
                    const temp = dx;
                    dx = dy;
                    dy = -temp;
                }
                
                x += dx;
                y += dy;
            }
            
            // Á°Æ‰øùÂá∫Âè£Âú®‰∏≠ÂøÉ
            const center = Math.floor(size / 2);
            maze[center][center] = 0;
            
            // Á°Æ‰øùËµ∑ÁÇπÂú®Â∑¶‰∏ãËßí
            maze[size - 2][1] = 0;
            
            return maze;
        }
        
        // Ê∑ªÂä†ÁßªÂä®Êïå‰∫∫ÔºàÁî®‰∫éËû∫ÊóãÂÖ≥Âç°Ôºâ
        function addMovingEnemies(size, count) {
            singlePlayerGame.movingEnemies = [];
            
            for (let i = 0; i < count; i++) {
                // ÈöèÊú∫‰ΩçÁΩÆÔºàÈÅøÂºÄËµ∑ÁÇπÂíåÁªàÁÇπÔºâ
                let x, y;
                do {
                    x = Math.floor(Math.random() * (size - 4)) + 2;
                    y = Math.floor(Math.random() * (size - 4)) + 2;
                } while (singlePlayerGame.maze[y][x] === 1 || 
                         (x === 1 && y === size - 2) || 
                         (x === Math.floor(size/2) && y === Math.floor(size/2)));
                
                singlePlayerGame.movingEnemies.push({
                    x, y,
                    dx: Math.random() > 0.5 ? 1 : -1,
                    dy: Math.random() > 0.5 ? 1 : -1,
                    speed: 0.3 + Math.random() * 0.4,
                    color: `hsl(${Math.random() * 360}, 80%, 60%)`,
                    lastMove: 0
                });
            }
        }

        // È™åËØÅËø∑ÂÆ´ÊòØÂê¶ÊúâËß£
        function validateMaze(maze) {
            // ÂàõÂª∫ËÆøÈóÆÊ†áËÆ∞Êï∞ÁªÑ
            const visited = Array(maze.length).fill().map(() => Array(maze[0].length).fill(false));
            const queue = [{x: 1, y: 1}];
            visited[1][1] = true;
            
            const exit = findExitPosition(maze);
            
            while (queue.length > 0) {
                const cell = queue.shift();
                
                // Â¶ÇÊûúÂà∞ËææÂá∫Âè£ÔºåËøîÂõûtrue
                if (cell.x === exit.x && cell.y === exit.y) {
                    return true;
                }
                
                // Ê£ÄÊü•ÊâÄÊúâÊñπÂêë
                const directions = [
                    {dx: 1, dy: 0}, {dx: -1, dy: 0}, 
                    {dx: 0, dy: 1}, {dx: 0, dy: -1}
                ];
                
                for (const dir of directions) {
                    const nx = cell.x + dir.dx;
                    const ny = cell.y + dir.dy;
                    
                    // Ê£ÄÊü•ÊòØÂê¶Âú®ËæπÁïåÂÜÖ
                    if (nx >= 0 && nx < maze[0].length && ny >= 0 && ny < maze.length) {
                        // Ê£ÄÊü•ÊòØÂê¶ÊòØÂ¢ôÊàñÊú™Ë¢´ËÆøÈóÆ
                        if (maze[ny][nx] !== 1 && !visited[ny][nx]) {
                            visited[ny][nx] = true;
                            queue.push({x: nx, y: ny});
                        }
                    }
                }
            }
            
            return false;
        }
        
        // Â§áÁî®Ëø∑ÂÆ´ÁîüÊàêÔºàÁ°Æ‰øùÊúâËß£Ôºâ
        function generateBackupMaze(size) {
            const maze = Array(size).fill().map(() => Array(size).fill(1));
            
            // ÂàõÂª∫‰∏ÄÊù°‰ªéËµ∑ÁÇπÂà∞ÁªàÁÇπÁöÑË∑ØÂæÑ
            for (let y = 1; y < size - 1; y++) {
                for (let x = 1; x < size - 1; x++) {
                    // ÂàõÂª∫ÂçÅÂ≠ó‰∫§ÂèâË∑ØÂæÑ
                    if (x === Math.floor(size/2) || y === Math.floor(size/2)) {
                        maze[y][x] = 0;
                    }
                }
            }
            
            // Á°Æ‰øùËµ∑ÁÇπÂíåÁªàÁÇπ
            maze[1][1] = 0;
            maze[size-2][size-1] = 0;
            
            return maze;
        }

function generateDifficultMaze(level, settings) {
    const size = settings.size;
    const seed = level;
    const random = new Random(seed);
    
    // ÂàõÂª∫Ëø∑ÂÆ´ (1=Â¢ô, 0=Ë∑Ø, 2=Èô∑Èò±, 3=‰º†ÈÄÅÈó®, 4=ÁßªÂä®Èô∑Èò±, 5=ÂçïÂêëÈÄöÈÅì, 8=Èí•Âåô, 9=Èó®)
    const maze = Array(size).fill().map(() => Array(size).fill(1));
    
    // ‰ΩøÁî®ÊîπËøõÁöÑÈöèÊú∫PrimÁÆóÊ≥ïÁîüÊàêËø∑ÂÆ´
    const walls = [];
    maze[1][1] = 0;
    walls.push(...getCellWalls(1, 1, maze));
    
    while (walls.length > 0) {
        const wallIndex = Math.floor(random.next() * walls.length);
        const wall = walls[wallIndex];
        walls.splice(wallIndex, 1);
        
        const opposite = getOppositeCell(wall, maze);
        
        if (opposite.x > 0 && opposite.x < size-1 && 
            opposite.y > 0 && opposite.y < size-1 && 
            maze[opposite.y][opposite.x] === 1) {
            
            maze[wall.y][wall.x] = 0;
            maze[opposite.y][opposite.x] = 0;
            walls.push(...getCellWalls(opposite.x, opposite.y, maze));
        }
    }
    
    // Á°Æ‰øùÂá∫Âè£ÂèØËææ
    ensureExitPath(maze, random);
    
    // Ê∑ªÂä†Èô∑Èò±ÔºàÈÅøÂºÄÂÖ≥ÈîÆË∑ØÂæÑÔºâ
    const criticalPath = findCriticalPath(maze);
    for (let i = 0; i < settings.traps; i++) {
        let x, y;
        let attempts = 0;
        do {
            x = Math.floor(random.next() * (size-2)) + 1;
            y = Math.floor(random.next() * (size-2)) + 1;
            attempts++;
        } while ((maze[y][x] !== 0 || criticalPath.some(p => p.x === x && p.y === y)) && attempts < 50);
        
        if (attempts < 50) {
            maze[y][x] = 2;
        }
    }
    
    // Ê∑ªÂä†‰º†ÈÄÅÈó®
    if (level > 10) {
        addTeleporters(maze, random, Math.min(4, Math.floor(level/10)));
    }
    
    // Ê∑ªÂä†ÁßªÂä®Èô∑Èò±
    singlePlayerGame.movingTraps = [];
    for (let i = 0; i < settings.movingTraps; i++) {
        let x, y;
        let attempts = 0;
        do {
            x = Math.floor(random.next() * (size-2)) + 1;
            y = Math.floor(random.next() * (size-2)) + 1;
            attempts++;
        } while ((maze[y][x] !== 0 || criticalPath.some(p => p.x === x && p.y === y)) && attempts < 50);
        
        if (attempts < 50) {
            maze[y][x] = 4;
            singlePlayerGame.movingTraps.push({
                x, y, 
                dx: Math.random() > 0.5 ? 1 : -1,
                dy: Math.random() > 0.5 ? 1 : -1,
                speed: 0.5 + Math.random() * 0.5
            });
        }
    }
    
    // Ê∑ªÂä†ÂçïÂêëÈÄöÈÅì
    for (let i = 0; i < settings.oneWayPaths; i++) {
        let x, y;
        let attempts = 0;
        do {
            x = Math.floor(random.next() * (size-2)) + 1;
            y = Math.floor(random.next() * (size-2)) + 1;
            attempts++;
        } while ((maze[y][x] !== 0 || criticalPath.some(p => p.x === x && p.y === y)) && attempts < 50);
        
        if (attempts < 50) {
            // 5Ë°®Á§∫ÂçïÂêëÈÄöÈÅì (1=Âè≥, 2=Â∑¶, 3=‰∏ã, 4=‰∏ä)
            maze[y][x] = 50 + Math.floor(random.next() * 4) + 1;
        }
    }
    
    // Â¶ÇÊûúÊòØÊó†Ëß£ÂÖ≥Âç°ÔºåÂ∞ÅÈó≠Âá∫Âè£Ë∑ØÂæÑ
    if (gameState.unsolvableLevels.includes(level)) {
        const exit = findExitPosition(maze);
        // Â∞ÅÈó≠Âá∫Âè£Âë®Âõ¥ÁöÑË∑ØÂæÑ
        const directions = [
            {dx: 1, dy: 0}, {dx: -1, dy: 0}, 
            {dx: 0, dy: 1}, {dx: 0, dy: -1}
        ];
        for (const dir of directions) {
            const nx = exit.x + dir.dx;
            const ny = exit.y + dir.dy;
            if (nx >= 0 && nx < size && ny >= 0 && ny < size && maze[ny][nx] === 0) {
                maze[ny][nx] = 1;
            }
        }
    }
    
    return maze;
    
    // ËæÖÂä©ÂáΩÊï∞ÔºöËé∑ÂèñÂçïÂÖÉÊ†ºÁöÑÂ¢ô
    function getCellWalls(x, y, maze) {
        const walls = [];
        const directions = [
            {dx: 1, dy: 0}, {dx: -1, dy: 0}, 
            {dx: 0, dy: 1}, {dx: 0, dy: -1}
        ];
        
        for (const dir of directions) {
            const nx = x + dir.dx;
            const ny = y + dir.dy;
            
            if (nx >= 0 && nx < maze[0].length && 
                ny >= 0 && ny < maze.length && 
                maze[ny][nx] === 1) {
                walls.push({x: nx, y: ny});
            }
        }
        
        return walls;
    }
    
    // ËæÖÂä©ÂáΩÊï∞ÔºöËé∑ÂèñÂØπÈù¢ÁöÑÂçïÂÖÉÊ†º
    function getOppositeCell(wall, maze) {
        const directions = [
            {dx: 1, dy: 0}, {dx: -1, dy: 0}, 
            {dx: 0, dy: 1}, {dx: 0, dy: -1}
        ];
        
        for (const dir of directions) {
            const nx = wall.x + dir.dx;
            const ny = wall.y + dir.dy;
            
            if (nx >= 0 && nx < maze[0].length && 
                ny >= 0 && ny < maze.length && 
                maze[ny][nx] === 0) {
                return {x: wall.x - dir.dx, y: wall.y - dir.dy};
            }
        }
        
        return {x: -1, y: -1};
    }
}
        
        // ÊâæÂà∞ÂÖ≥ÈîÆË∑ØÂæÑÔºà‰ªéËµ∑ÁÇπÂà∞ÁªàÁÇπÁöÑÊúÄÁü≠Ë∑ØÂæÑÔºâ
        function findCriticalPath(maze) {
            const start = {x: 1, y: 1};
            const exit = findExitPosition(maze);
            
            // BFSÂØªÊâæÊúÄÁü≠Ë∑ØÂæÑ
            const visited = Array(maze.length).fill().map(() => Array(maze[0].length).fill(false));
            const queue = [{...start, path: []}];
            visited[start.y][start.x] = true;
            
            while (queue.length > 0) {
                const cell = queue.shift();
                const newPath = [...cell.path, {x: cell.x, y: cell.y}];
                
                if (cell.x === exit.x && cell.y === exit.y) {
                    return newPath;
                }
                
                const directions = [
                    {dx: 1, dy: 0}, {dx: -1, dy: 0}, 
                    {dx: 0, dy: 1}, {dx: 0, dy: -1}
                ];
                
                for (const dir of directions) {
                    const nx = cell.x + dir.dx;
                    const ny = cell.y + dir.dy;
                    
                    if (nx >= 0 && nx < maze[0].length && 
                        ny >= 0 && ny < maze.length && 
                        !visited[ny][nx] && maze[ny][nx] !== 1) {
                        visited[ny][nx] = true;
                        queue.push({x: nx, y: ny, path: newPath});
                    }
                }
            }
            
            return [];
        }
        
        function ensureExitPath(maze, random) {
            const size = maze.length;
            const exit = findExitPosition(maze);
            
            // ‰ΩøÁî®BFSÁ°Æ‰øùËµ∑ÁÇπÂà∞Âá∫Âè£ÊúâË∑ØÂæÑ
            const visited = Array(size).fill().map(() => Array(size).fill(false));
            const queue = [{x: 1, y: 1}];
            visited[1][1] = true;
            
            let found = false;
            
            while (queue.length > 0) {
                const cell = queue.shift();
                
                if (cell.x === exit.x && cell.y === exit.y) {
                    found = true;
                    break;
                }
                
                const directions = [
                    {dx: 1, dy: 0}, {dx: -1, dy: 0}, 
                    {dx: 0, dy: 1}, {dx: 0, dy: -1}
                ];
                
                for (const dir of directions) {
                    const nx = cell.x + dir.dx;
                    const ny = cell.y + dir.dy;
                    
                    if (nx >= 0 && nx < size && ny >= 0 && ny < size && 
                        !visited[ny][nx] && maze[ny][nx] !== 1) {
                        visited[ny][nx] = true;
                        queue.push({x: nx, y: ny});
                    }
                }
            }
            
            // Â¶ÇÊûúË∑ØÂæÑ‰∏çÂ≠òÂú®ÔºåÊâìÂºÄ‰∏ÄÊù°Ë∑ØÂæÑ
            if (!found) {
                let x = 1, y = 1;
                while (x !== exit.x || y !== exit.y) {
                    if (x < exit.x) x++;
                    else if (x > exit.x) x--;
                    else if (y < exit.y) y++;
                    else if (y > exit.y) y--;
                    
                    maze[y][x] = 0;
                }
            }
        }
        
        function addTeleporters(maze, random, count) {
            const size = maze.length;
            singlePlayerGame.teleporters = [];
            
            for (let i = 0; i < count * 2; i++) {
                let x, y;
                do {
                    x = Math.floor(random.next() * (size-2)) + 1;
                    y = Math.floor(random.next() * (size-2)) + 1;
                } while (maze[y][x] !== 0 || singlePlayerGame.teleporters.some(t => t.x === x && t.y === y));
                
                maze[y][x] = 3;
                singlePlayerGame.teleporters.push({x, y, id: Math.floor(i/2)});
            }
        }

        function findStartPosition(maze) {
            return { x: 1, y: 1 };
        }

        function findExitPosition(maze) {
            const size = maze.length;
            const random = new Random(gameState.currentLevel);
            
            // Âú®ËæπÁºòÂØªÊâæÂêàÈÄÇÁöÑ‰ΩçÁΩÆ‰Ωú‰∏∫Âá∫Âè£
            const edgePositions = [];
            
            // Âè≥‰æßËæπÁºò (x = size-1)
            for (let y = 1; y < size-1; y++) {
                if (maze[y][size-2] === 0) {
                    edgePositions.push({x: size-1, y});
                }
            }
            
            // ‰∏ã‰æßËæπÁºò (y = size-1)
            for (let x = 1; x < size-1; x++) {
                if (maze[size-2][x] === 0) {
                    edgePositions.push({x, y: size-1});
                }
            }
            
            if (edgePositions.length > 0) {
                const exit = edgePositions[Math.floor(random.next() * edgePositions.length)];
                maze[exit.y][exit.x] = 0;
                return exit;
            }
            
            // Â¶ÇÊûúÊ≤°ÊúâÂêàÈÄÇ‰ΩçÁΩÆÔºå‰ΩøÁî®Âè≥‰∏ãËßí
            maze[size-2][size-1] = 0;
            return {x: size-1, y: size-2};
        }

function resizeSinglePlayerCanvas() {
    // Ê£ÄÊü•mazeÊòØÂê¶Â∑≤Ê≠£Á°ÆÂàùÂßãÂåñ
    if (!singlePlayerGame.maze || singlePlayerGame.maze.length === 0) {
        console.error("Maze not initialized in resizeSinglePlayerCanvas");
        
        // ËÆæÁΩÆÈªòËÆ§ÁîªÂ∏ÉÂ§ßÂ∞è
        singlePlayerGame.canvas.width = 300;
        singlePlayerGame.canvas.height = 300;
        return;
    }
    
    const maxWidth = window.innerWidth - 40;
    const maxHeight = window.innerHeight - 180;
    
    const mazeWidth = singlePlayerGame.maze[0].length;
    const mazeHeight = singlePlayerGame.maze.length;
    
    singlePlayerGame.cellSize = Math.min(
        40,
        Math.floor(maxWidth / mazeWidth),
        Math.floor(maxHeight / mazeHeight)
    );
    
    singlePlayerGame.canvas.width = mazeWidth * singlePlayerGame.cellSize;
    singlePlayerGame.canvas.height = mazeHeight * singlePlayerGame.cellSize;
}

        function drawSinglePlayerMaze() {
            const ctx = singlePlayerGame.ctx;
            ctx.clearRect(0, 0, singlePlayerGame.canvas.width, singlePlayerGame.canvas.height);
            
            // ÁªòÂà∂Ëø∑ÂÆ´
            for (let y = 0; y < singlePlayerGame.maze.length; y++) {
                for (let x = 0; x < singlePlayerGame.maze[y].length; x++) {
                    const cellValue = singlePlayerGame.maze[y][x];
                    
                    // Ê†πÊçÆÂçïÂÖÉÊ†ºÂÄºËÆæÁΩÆÈ¢úËâ≤
                    switch(cellValue) {
                        case 1: // Â¢ô
                            ctx.fillStyle = '#333';
                            break;
                        case 2: // Èô∑Èò±
                            ctx.fillStyle = '#FF0';
                            break;
                        case 3: // ‰º†ÈÄÅÈó®
                            ctx.fillStyle = '#0FF';
                            break;
                        case 4: // ÁßªÂä®Èô∑Èò±
                            ctx.fillStyle = '#F0F';
                            break;
                        case 8: // Èí•Âåô
                            ctx.fillStyle = 'gold';
                            break;
                        case 9: // Èó®
                            ctx.fillStyle = '#8B4513';
                            break;
                        default: // Ë∑Ø
                            if (cellValue >= 50 && cellValue <= 54) {
                                ctx.fillStyle = '#F90'; // ÂçïÂêëÈÄöÈÅì
                            } else {
                                ctx.fillStyle = '#111';
                            }
                    }
                    
                    ctx.fillRect(x * singlePlayerGame.cellSize, y * singlePlayerGame.cellSize, 
                                singlePlayerGame.cellSize, singlePlayerGame.cellSize);
                    
                    // ÁªòÂà∂ÁâπÊÆäÂÖÉÁ¥†ÁöÑÂõæÊ°à
                    if (cellValue === 2) { // Èô∑Èò±
                        ctx.fillStyle = '#000';
                        ctx.beginPath();
                        ctx.arc(
                            x * singlePlayerGame.cellSize + singlePlayerGame.cellSize/2,
                            y * singlePlayerGame.cellSize + singlePlayerGame.cellSize/2,
                            singlePlayerGame.cellSize/4,
                            0,
                            Math.PI * 2
                        );
                        ctx.fill();
                    } else if (cellValue === 8) { // Èí•Âåô
                        ctx.fillStyle = '#000';
                        ctx.beginPath();
                        ctx.arc(
                            x * singlePlayerGame.cellSize + singlePlayerGame.cellSize/2,
                            y * singlePlayerGame.cellSize + singlePlayerGame.cellSize/2,
                            singlePlayerGame.cellSize/4,
                            0,
                            Math.PI * 2
                        );
                        ctx.fill();
                        ctx.fillStyle = 'gold';
                        ctx.font = 'bold ' + (singlePlayerGame.cellSize/2) + 'px Arial';
                        ctx.textAlign = 'center';
                        ctx.textBaseline = 'middle';
                        ctx.fillText('üîë', 
                            x * singlePlayerGame.cellSize + singlePlayerGame.cellSize/2,
                            y * singlePlayerGame.cellSize + singlePlayerGame.cellSize/2
                        );
                    } else if (cellValue === 9) { // Èó®
                        ctx.fillStyle = '#5D4037';
                        ctx.fillRect(
                            x * singlePlayerGame.cellSize, 
                            y * singlePlayerGame.cellSize, 
                            singlePlayerGame.cellSize, 
                            singlePlayerGame.cellSize
                        );
                        ctx.fillStyle = '#8B4513';
                        ctx.fillRect(
                            x * singlePlayerGame.cellSize + singlePlayerGame.cellSize/4, 
                            y * singlePlayerGame.cellSize, 
                            singlePlayerGame.cellSize/2, 
                            singlePlayerGame.cellSize
                        );
                    } else if (cellValue >= 50 && cellValue <= 54) { // ÂçïÂêëÈÄöÈÅì
                        ctx.fillStyle = '#FFF';
                        ctx.font = 'bold ' + (singlePlayerGame.cellSize/2) + 'px Arial';
                        ctx.textAlign = 'center';
                        ctx.textBaseline = 'middle';
                        
                        let arrow = '';
                        switch(cellValue) {
                            case 51: arrow = '‚Üí'; break; // Âè≥
                            case 52: arrow = '‚Üê'; break; // Â∑¶
                            case 53: arrow = '‚Üì'; break; // ‰∏ã
                            case 54: arrow = '‚Üë'; break; // ‰∏ä
                        }
                        
                        ctx.fillText(arrow, 
                            x * singlePlayerGame.cellSize + singlePlayerGame.cellSize/2,
                            y * singlePlayerGame.cellSize + singlePlayerGame.cellSize/2
                        );
                    }
                }
            }
            
            // ÁªòÂà∂Âá∫Âè£
            ctx.fillStyle = '#F00';
            ctx.fillRect(singlePlayerGame.exit.x * singlePlayerGame.cellSize, 
                        singlePlayerGame.exit.y * singlePlayerGame.cellSize, 
                        singlePlayerGame.cellSize, singlePlayerGame.cellSize);
            ctx.fillStyle = '#FFF';
            ctx.font = 'bold ' + (singlePlayerGame.cellSize/2) + 'px Arial';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText('Âá∫', 
                singlePlayerGame.exit.x * singlePlayerGame.cellSize + singlePlayerGame.cellSize/2,
                singlePlayerGame.exit.y * singlePlayerGame.cellSize + singlePlayerGame.cellSize/2
            );
            
            // ÁªòÂà∂Áé©ÂÆ∂
            ctx.fillStyle = '#4CAF50';
            ctx.beginPath();
            ctx.arc(
                singlePlayerGame.player.x * singlePlayerGame.cellSize + singlePlayerGame.cellSize/2,
                singlePlayerGame.player.y * singlePlayerGame.cellSize + singlePlayerGame.cellSize/2,
                singlePlayerGame.cellSize/2 - 2,
                0,
                Math.PI * 2
            );
            ctx.fill();
            
            // ÁªòÂà∂ÁßªÂä®Êïå‰∫∫ÔºàÁâπÊÆäÂÖ≥Âç°Ôºâ
            for (const enemy of singlePlayerGame.movingEnemies) {
                ctx.fillStyle = enemy.color;
                ctx.beginPath();
                ctx.arc(
                    enemy.x * singlePlayerGame.cellSize + singlePlayerGame.cellSize/2,
                    enemy.y * singlePlayerGame.cellSize + singlePlayerGame.cellSize/2,
                    singlePlayerGame.cellSize/2 - 2,
                    0,
                    Math.PI * 2
                );
                ctx.fill();
                
                // ÁªòÂà∂Êïå‰∫∫ÁúºÁùõ
                ctx.fillStyle = '#FFF';
                ctx.beginPath();
                ctx.arc(
                    enemy.x * singlePlayerGame.cellSize + singlePlayerGame.cellSize/3,
                    enemy.y * singlePlayerGame.cellSize + singlePlayerGame.cellSize/3,
                    singlePlayerGame.cellSize/8,
                    0,
                    Math.PI * 2
                );
                ctx.fill();
            }
        }

        function startSinglePlayerTimer() {
            clearInterval(singlePlayerGame.timerInterval);
            singlePlayerGame.startTime = Date.now();
            singlePlayerGame.moveCount = 0;
            singlePlayerGame.unlockTimeLeft = 10
            updateSinglePlayerTimer();
            singlePlayerGame.timerInterval = setInterval(updateSinglePlayerTimer, 1000);
        }
function saveGameData() {
    localStorage.setItem('achievements', JSON.stringify(gameState.achievements));
    localStorage.setItem('gameStats', JSON.stringify(gameState.gameStats));
    localStorage.setItem('gameSettings', JSON.stringify(gameState.settings));
}

// ÂÖ®Â±ÄÂèòÈáèË∑üË∏™ÂΩìÂâçÊâìÂºÄÁöÑÊ®°ÊÄÅÊ°Ü
let currentModal = null;
function confirmLoadGame(slot) {
    if (gameState.currentScreen !== 'singlePlayerLevelSelect' && 
        gameState.currentScreen !== 'mainMenu') {
        if (!confirm('ÊòØÂê¶ÊîæÂºÉÂΩìÂâçËøõÂ∫¶Âπ∂Âä†ËΩΩÂ≠òÊ°£Ôºü')) {
            return;
        }
    }
    
    if (loadGame(slot)) {
        const modal = document.getElementById('saveLoadModal');
        if (modal) modal.remove();
        
        // Ê†πÊçÆÂΩìÂâçÁïåÈù¢ÂÅö‰∏çÂêåÂ§ÑÁêÜ
        if (gameState.currentScreen === 'singlePlayerGame') {
            // ÈáçÊñ∞ÂàùÂßãÂåñÊ∏∏Êàè‰ΩÜ‰øùÁïôÂä†ËΩΩÁöÑ‰ΩçÁΩÆ
            initSinglePlayerGame(true); // ‰º†ÂÖ•trueË°®Á§∫ÊòØÂä†ËΩΩÂ≠òÊ°£
        } else {
            showScreen('singlePlayerGame');
        }
    }
}

function showSaveLoadMenu() {
    // ÂÖàÂÖ≥Èó≠‰ªª‰ΩïÁé∞ÊúâÁöÑÂ≠òÊ°£ÂØπËØùÊ°Ü
    const existingModal = document.getElementById('saveLoadModal');
    if (existingModal) {
        document.body.removeChild(existingModal);
    }

    const modal = document.createElement('div');
    modal.id = 'saveLoadModal';
    modal.style.cssText = `
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: rgba(0,0,0,0.7);
        display: flex;
        justify-content: center;
        align-items: center;
        z-index: 1000;
    `;
    
    modal.innerHTML = `
        <div style="background: #333; padding: 20px; border-radius: 10px; max-width: 500px; width: 90%;">
            <h3 style="color: white; margin-top: 0; text-align: center;">Â≠òÊ°£/ËØªÊ°£</h3>
            <div style="display: flex; justify-content: space-between; margin: 20px 0;">
                <button onclick="saveGame(0)" style="padding: 8px 16px; background: #4CAF50; color: white; border: none; border-radius: 5px; flex: 1; margin: 0 5px;">‰øùÂ≠òÂà∞Â≠òÊ°£1</button>
                <button onclick="confirmLoadGame(0)" style="padding: 8px 16px; background: #2196F3; color: white; border: none; border-radius: 5px; flex: 1; margin: 0 5px;">ËØªÂèñÂ≠òÊ°£1</button>
                <button onclick="deleteSave(0)" style="padding: 8px 16px; background: #f44336; color: white; border: none; border-radius: 5px; flex: 1; margin: 0 5px;">Âà†Èô§Â≠òÊ°£1</button>
            </div>
            <div style="display: flex; justify-content: space-between; margin: 20px 0;">
                <button onclick="saveGame(1)" style="padding: 8px 16px; background: #4CAF50; color: white; border: none; border-radius: 5px; flex: 1; margin: 0 5px;">‰øùÂ≠òÂà∞Â≠òÊ°£2</button>
                <button onclick="confirmLoadGame(1)" style="padding: 8px 16px; background: #2196F3; color: white; border: none; border-radius: 5px; flex: 1; margin: 0 5px;">ËØªÂèñÂ≠òÊ°£2</button>
                <button onclick="deleteSave(1)" style="padding: 8px 16px; background: #f44336; color: white; border: none; border-radius: 5px; flex: 1; margin: 0 5px;">Âà†Èô§Â≠òÊ°£2</button>
            </div>
            <div style="display: flex; justify-content: space-between; margin: 20px 0;">
                <button onclick="saveGame(2)" style="padding: 8px 16px; background: #4CAF50; color: white; border: none; border-radius: 5px; flex: 1; margin: 0 5px;">‰øùÂ≠òÂà∞Â≠òÊ°£3</button>
                <button onclick="confirmLoadGame(2)" style="padding: 8px 16px; background: #2196F3; color: white; border: none; border-radius: 5px; flex: 1; margin: 0 5px;">ËØªÂèñÂ≠òÊ°£3</button>
                <button onclick="deleteSave(2)" style="padding: 8px 16px; background: #f44336; color: white; border: none; border-radius: 5px; flex: 1; margin: 0 5px;">Âà†Èô§Â≠òÊ°£3</button>
            </div>
            <button id="saveLoadCloseBtn" style="padding: 8px 16px; background: #666; color: white; border: none; border-radius: 5px; width: 100%;">ÂÖ≥Èó≠</button>
        </div>
    `;
    
    document.body.appendChild(modal);
    
    // Ê∑ªÂä†ÁÇπÂáª‰∫ã‰ª∂ÁõëÂê¨Âô®
    const closeBtn = document.getElementById('saveLoadCloseBtn');
    closeBtn.addEventListener('click', () => {
        modal.remove();
    });
}



function completeLevel() {
    // 1. ÂÅúÊ≠¢ÊâÄÊúâËÆ°Êó∂Âô®ÂíåÂä®Áîª
    clearInterval(singlePlayerGame.timerInterval);
    clearInterval(singlePlayerGame.movingTrapsInterval);
    clearInterval(singlePlayerGame.unlockTimer);
    
    // 2. Âº∫Âà∂ÈöêËóèÊâÄÊúâÊåâÈíÆ
    document.getElementById('regularNextButton').style.display = 'none';
    document.getElementById('unsolvableNextButton').style.display = 'none';
    
    // 3. Êõ¥Êñ∞ÈÄöÂÖ≥‰ø°ÊÅØÊòæÁ§∫
    const elapsed = Math.floor((Date.now() - singlePlayerGame.startTime) / 1000);
    document.getElementById('singlePlayerCompleteTime').textContent = 
        `Áî®Êó∂: ${Math.floor(elapsed/60)}:${(elapsed%60).toString().padStart(2,'0')}`;
    document.getElementById('singlePlayerCompleteMoves').textContent = 
        `ÁßªÂä®Ê¨°Êï∞: ${singlePlayerGame.moveCount}`;
    
    // 4. Êõ¥Êñ∞Ê∏∏ÊàèËøõÂ∫¶
    if (gameState.currentLevel === gameState.unlockedLevel) {
        gameState.unlockedLevel++;
        while (gameState.unsolvableLevels.includes(gameState.unlockedLevel)) {
            gameState.unlockedLevel++;
        }
        localStorage.setItem('unlockedLevel', gameState.unlockedLevel);
    }
    
    if (!gameState.completedLevels.includes(gameState.currentLevel)) {
        gameState.completedLevels.push(gameState.currentLevel);
        localStorage.setItem('completedLevels', JSON.stringify(gameState.completedLevels));
    }
    
    // 5. ÊòæÁ§∫ÈÄöÂÖ≥Èù¢Êùø
    document.getElementById('singlePlayerComplete').classList.remove('hidden');
    
    // 6. Ëß£Èô§ÈîÆÁõòÊéßÂà∂
    window.removeEventListener('keydown', handleSinglePlayerKeyDown);
    
    // 7. ‰øùÂ≠òÊï∞ÊçÆ
    recordAchievement('levelComplete', 1);
    if (gameState.currentLevel === 30 || gameState.currentLevel === 60) {
        addCoins(12)
    } else {
        addCoins(5);
    }
        

    // ‰øùÂ≠òÈáëÂ∏ÅÂà∞ localStorage
    localStorage.setItem('playerCoins', gameState.coins);
}

function loadNextLevel() {
    if (gameState.currentLevel < 80) {
        gameState.currentLevel++;
        
        // Âº∫Âà∂ÈáçÁΩÆÊâÄÊúâÁä∂ÊÄÅ
        document.getElementById('singlePlayerComplete').classList.add('hidden');
        document.getElementById('regularNextButton').style.display = 'none';
        document.getElementById('unsolvableNextButton').style.display = 'none';
        
        initSinglePlayerGame();
    } else {
        alert('ÊÅ≠Âñú‰Ω†ÂÆåÊàê‰∫ÜÊâÄÊúâÂÖ≥Âç°ÔºÅ');
        showScreen('singlePlayerLevelSelect');
    }
}

function resetSinglePlayerLevel() {
    // Âº∫Âà∂ÈöêËóèÊåâÈíÆ
    document.getElementById('regularNextButton').style.display = 'none';
    document.getElementById('unsolvableNextButton').style.display = 'none';
    
    // ÈáçÁΩÆÊ∏∏ÊàèÁä∂ÊÄÅ
    singlePlayerGame.player = findStartPosition(singlePlayerGame.maze);
    singlePlayerGame.moveCount = 0;
    singlePlayerGame.hasKey = false;
    singlePlayerGame.isUnlocking = false;
    singlePlayerGame.unlockTimeLeft = 10;
    clearInterval(singlePlayerGame.unlockTimer);
    
    // Êõ¥Êñ∞UI
    document.getElementById('moveCount').textContent = `ÁßªÂä®: 0`;
    document.getElementById('keyStatus').textContent = `Èí•Âåô: Êú™Ëé∑Âæó`;
    document.getElementById('unlockTimer').classList.add('hidden');
    
    drawSinglePlayerMaze();
}

        function updateSinglePlayerTimer() {
            const elapsed = Math.floor((Date.now() - singlePlayerGame.startTime) / 1000);
            const minutes = Math.floor(elapsed / 60);
            const seconds = elapsed % 60;
            document.getElementById('timeDisplay').textContent = 
                `Êó∂Èó¥: ${minutes}:${seconds.toString().padStart(2, '0')}`;
            document.getElementById('moveCount').textContent = `ÁßªÂä®: ${singlePlayerGame.moveCount}`;
        }

        function startMovingTraps() {
            if (singlePlayerGame.movingTrapsInterval) {
                clearInterval(singlePlayerGame.movingTrapsInterval);
            }
            
            singlePlayerGame.movingTrapsInterval = setInterval(moveTraps, 500);
        }

        function moveTraps() {
            const maze = singlePlayerGame.maze;
            const size = maze.length;
            const now = Date.now();
            
            // ÁßªÂä®ÊôÆÈÄöÈô∑Èò±
            for (let i = 0; i < singlePlayerGame.movingTraps.length; i++) {
                const trap = singlePlayerGame.movingTraps[i];
                
                // Â∞ùËØïÁßªÂä®
                let newX = trap.x + Math.round(trap.dx);
                let newY = trap.y + Math.round(trap.dy);
                
                // Ê£ÄÊü•ËæπÁïåÂíåÂ¢ôÂ£Å
                if (newX <= 0 || newX >= size-1 || newY <= 0 || newY >= size-1 || 
                    maze[newY][newX] === 1 || maze[newY][newX] >= 50) {
                    // ÊîπÂèòÊñπÂêë
                    trap.dx = Math.random() > 0.5 ? 1 : -1;
                    trap.dy = Math.random() > 0.5 ? 1 : -1;
                    continue;
                }
                
                // Êõ¥Êñ∞Èô∑Èò±‰ΩçÁΩÆ
                maze[trap.y][trap.x] = 0; // Ê∏ÖÈô§Êóß‰ΩçÁΩÆ
                trap.x = newX;
                trap.y = newY;
                maze[newY][newX] = 4; // ËÆæÁΩÆÊñ∞‰ΩçÁΩÆ
                
                // Ê£ÄÊü•ÊòØÂê¶Á¢∞Âà∞Áé©ÂÆ∂
                if (trap.x === singlePlayerGame.player.x && trap.y === singlePlayerGame.player.y) {
                    // ÂõûÂà∞Ëµ∑ÁÇπ
                    singlePlayerGame.player = findStartPosition(singlePlayerGame.maze);
                    // singlePlayerGame.hasKey = false;
                    // document.getElementById('keyStatus').textContent = `Èí•Âåô: Êú™Ëé∑Âæó`;
                }
            }
            
            // ÁßªÂä®Êïå‰∫∫ÔºàÁâπÊÆäÂÖ≥Âç°Ôºâ
            for (const enemy of singlePlayerGame.movingEnemies) {
                // Ê†πÊçÆÊó∂Èó¥Èó¥ÈöîÁßªÂä®
                if (now - enemy.lastMove < 500 / enemy.speed) continue;
                enemy.lastMove = now;
                
                // ËøΩÈÄêÁé©ÂÆ∂
                const dx = singlePlayerGame.player.x - enemy.x;
                const dy = singlePlayerGame.player.y - enemy.y;
                
                // ‰ºòÂÖàÁßªÂä®ÊñπÂêëÔºàÊ∞¥Âπ≥ÊàñÂûÇÁõ¥Ôºâ
                if (Math.abs(dx) > Math.abs(dy)) {
                    enemy.dx = dx > 0 ? 1 : -1;
                    enemy.dy = 0;
                } else {
                    enemy.dx = 0;
                    enemy.dy = dy > 0 ? 1 : -1;
                }
                
                // Â∞ùËØïÁßªÂä®
                let newX = enemy.x + enemy.dx;
                let newY = enemy.y + enemy.dy;
                
                // Ê£ÄÊü•ÊòØÂê¶ÂèØÁßªÂä®
                if (newX >= 0 && newX < size && newY >= 0 && newY < size && 
                    maze[newY][newX] !== 1 && maze[newY][newX] < 50) {
                    enemy.x = newX;
                    enemy.y = newY;
                }
                
                // Ê£ÄÊü•ÊòØÂê¶Á¢∞Âà∞Áé©ÂÆ∂
                if (enemy.x === singlePlayerGame.player.x && enemy.y === singlePlayerGame.player.y) {
                    // ÂõûÂà∞Ëµ∑ÁÇπ
                    singlePlayerGame.player = findStartPosition(singlePlayerGame.maze);
                    // singlePlayerGame.hasKey = false;
                    // document.getElementById('keyStatus').textContent = `Èí•Âåô: Êú™Ëé∑Âæó`;
                }
            }
            
            drawSinglePlayerMaze();
        }
/**
 * Áªü‰∏ÄÁöÑÁé©ÂÆ∂ÁßªÂä®Ê†∏ÂøÉÂáΩÊï∞
 * @param {string} key - Êåâ‰∏ãÁöÑÈîÆ ('ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight')
 * @param {number} [dx] - ÂèØÈÄâÔºåÁõ¥Êé•‰º†ÂÖ•XÊñπÂêëÁßªÂä®Èáè (Áî®‰∫éËß¶Êë∏ÊåâÈíÆ)
 * @param {number} [dy] - ÂèØÈÄâÔºåÁõ¥Êé•‰º†ÂÖ•YÊñπÂêëÁßªÂä®Èáè (Áî®‰∫éËß¶Êë∏ÊåâÈíÆ)
 */
function movePlayer(key, dx, dy) {
    // 1. Â∫îÁî®ÂèçËΩ¨Áä∂ÊÄÅÔºàÂ¶ÇÊûúÈúÄË¶ÅÔºâ
    let effectiveKey = key;
    if (gameState.controlsReversed) {
        effectiveKey = {
            'ArrowUp': 'ArrowDown',
            'ArrowDown': 'ArrowUp',
            'ArrowLeft': 'ArrowRight',
            'ArrowRight': 'ArrowLeft'
        }[key] || key;
        console.log('ÊéßÂà∂ÂèçËΩ¨‰∏≠:', key, '->', effectiveKey);
    }

    // 2. ËÆ°ÁÆóÁßªÂä®Èáè
    let moveDx = 0, moveDy = 0;
    if (dx !== undefined && dy !== undefined) {
        // Â¶ÇÊûúÁõ¥Êé•‰º†ÂÖ•‰∫Üdx, dy (Áî®‰∫éËß¶Êë∏ÊåâÈíÆ)ÔºåÂàôÁõ¥Êé•‰ΩøÁî®
        moveDx = dx;
        moveDy = dy;
    } else {
        // Âê¶ÂàôÔºåÊ†πÊçÆeffectiveKeyËÆ°ÁÆó
        switch(effectiveKey) {
            case 'ArrowUp': moveDy--; break;
            case 'ArrowDown': moveDy++; break;
            case 'ArrowLeft': moveDx--; break;
            case 'ArrowRight': moveDx++; break;
            default: return; // ‰∏çÊòØÊñπÂêëÈîÆÔºå‰∏çÂ§ÑÁêÜ
        }
    }

    // 3. Ê†πÊçÆÂΩìÂâçÊ∏∏ÊàèÊ®°ÂºèË∞ÉÁî®Â§ÑÁêÜÈÄªËæë
    if (gameState.currentScreen === 'singlePlayerGame') {
        handleSinglePlayerMove(moveDx, moveDy);
    } else if (gameState.currentScreen === 'multiplayerGame') {
        handleMultiplayerMove(moveDx, moveDy);
    }
}

/**
 * Âçï‰∫∫Ê∏∏ÊàèÁßªÂä®Â§ÑÁêÜ
 */
function handleSinglePlayerMove(dx, dy) {
    const player = singlePlayerGame.player;
    const originalX = player.x;
    const originalY = player.y;
    const newX = originalX + dx;
    const newY = originalY + dy;

    if (newX < 0 || newY < 0 || newY >= singlePlayerGame.maze.length || newX >= singlePlayerGame.maze[0].length) {
        return;
    }

    const cellValue = singlePlayerGame.maze[newY][newX];

    if (cellValue === 1) return; // Â¢ô

    // ÁßªÂä®Èô∑Èò±
    if (cellValue === 2 || cellValue === 4) {
        recordAchievement('trapHit', 1);
        player.x = findStartPosition(singlePlayerGame.maze).x;
        player.y = findStartPosition(singlePlayerGame.maze).y;
        singlePlayerGame.moveCount++;
        document.getElementById('moveCount').textContent = `ÁßªÂä®: ${singlePlayerGame.moveCount}`;
        drawSinglePlayerMaze();
        return;
    }

    // ‰º†ÈÄÅÈó®
    if (cellValue === 3 && singlePlayerGame.teleporters.length > 0) {
        const currentPortal = singlePlayerGame.teleporters.find(t => t.x === newX && t.y === newY);
        if (currentPortal) {
            const pairPortals = singlePlayerGame.teleporters.filter(t => 
                t.id === currentPortal.id && (t.x !== newX || t.y !== newY)
            );
            if (pairPortals.length > 0) {
                const targetPortal = pairPortals[Math.floor(Math.random() * pairPortals.length)];
                player.x = targetPortal.x;
                player.y = targetPortal.y;
                singlePlayerGame.moveCount++;
                document.getElementById('moveCount').textContent = `ÁßªÂä®: ${singlePlayerGame.moveCount}`;
                drawSinglePlayerMaze();
                checkSinglePlayerExit();
                return;
            }
        }
    }

    // Èí•Âåô
    if (cellValue === 8) {
        singlePlayerGame.hasKey = true;
        document.getElementById('keyStatus').textContent = `Èí•Âåô: Â∑≤Ëé∑Âæó`;
        singlePlayerGame.maze[newY][newX] = 0;
    }

    // Èó®
    if (cellValue === 9) {
        if (singlePlayerGame.hasKey) {
            startUnlockDoor();
            return;
        } else {
            alert("‰Ω†ÈúÄË¶ÅÈí•ÂåôÊâçËÉΩÊâìÂºÄËøôÊâáÈó®ÔºÅ");
            return;
        }
    }
    
    // Ê†áÂáÜÁßªÂä®
    player.x = newX;
    player.y = newY;
    singlePlayerGame.moveCount++;
    document.getElementById('moveCount').textContent = `ÁßªÂä®: ${singlePlayerGame.moveCount}`;
    drawSinglePlayerMaze();
    checkSinglePlayerExit();
}

/**
 * Â§ö‰∫∫Ê∏∏ÊàèÁßªÂä®Â§ÑÁêÜ (‰øÆÂ§çÁâà)
 */
// Ê∑ªÂä†Áé©ÂÆ∂ÁßªÂä®ÈîÅÔºåÈò≤Ê≠¢Âú®Âêå‰∏ÄÊó∂Èó¥Â§öÊ¨°ÁßªÂä®
let playerMoveLock = false;

// ‰øÆÂ§çÁâàÂ§ö‰∫∫Ê∏∏ÊàèÁßªÂä®ÈÄªËæë
function handleMultiplayerMoveLogic(dx, dy) {
    if (globalMoveLock) return;
    
    const currentPlayer = gameState.multiplayer.players[gameState.multiplayer.currentPlayerId];
    if (!currentPlayer || currentPlayer.reachedExit) return;

    const newX = currentPlayer.x + dx;
    const newY = currentPlayer.y + dy;

    // ËæπÁïåÊ£ÄÊü•
    if (!isValidPosition(newX, newY, gameState.multiplayer.maze)) return;

    const cellValue = gameState.multiplayer.maze[newY][newX];
    
    // Â§ÑÁêÜÁâπÊÆäÊ†ºÂ≠ê
    if (cellValue === 2) { // Èô∑Èò±
        if (!gameState.multiplayer.protectedPlayers[currentPlayer.id]) {
            currentPlayer.x = 1;
            currentPlayer.y = 1;
            gameState.multiplayer.moveCount++;
            document.getElementById('multiplayerMoveCount').textContent = `ÁßªÂä®: ${gameState.multiplayer.moveCount}`;
        }
        broadcastPlayerMove(currentPlayer.id);
        drawMultiplayerMaze();
        return;
    }
    
    // Â§ÑÁêÜ‰º†ÈÄÅÈó®
    if (cellValue === 3) {
        const teleporter = gameState.multiplayer.teleporters.find(t => 
            t.x === newX && t.y === newY);
        if (teleporter) {
            currentPlayer.x = teleporter.pairX;
            currentPlayer.y = teleporter.pairY;
            broadcastPlayerMove(currentPlayer.id);
            drawMultiplayerMaze();
            checkPlayerAtExit(currentPlayer);
            return;
        }
    }

    // Ê†áÂáÜÁßªÂä®
    if (cellValue !== 1 && cellValue !== 9) { // ÂÖÅËÆ∏ÈÄöËøá
        currentPlayer.x = newX;
        currentPlayer.y = newY;
        gameState.multiplayer.moveCount++;
        document.getElementById('multiplayerMoveCount').textContent = `ÁßªÂä®: ${gameState.multiplayer.moveCount}`;
        
        broadcastPlayerMove(currentPlayer.id);
        drawMultiplayerMaze();
        checkPlayerAtExit(currentPlayer);
    }
}

// ÂπøÊí≠Áé©ÂÆ∂ÁßªÂä®
function broadcastPlayerMove(playerId) {
    const player = gameState.multiplayer.players[playerId];
    if (player) {
        broadcast({
            type: 'player-move',
            playerId: playerId,
            x: player.x,
            y: player.y
        });
    }
}


// =============== ÈîÆÁõò‰∫ã‰ª∂Â§ÑÁêÜ ===============

function handleSinglePlayerKeyDown(e) {
    if (!['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight'].includes(e.key)) {
        return;
    }
    // ÈòªÊ≠¢ÈªòËÆ§ÊªöÂä®Ë°å‰∏∫
    e.preventDefault();
    movePlayer(e.key);
}



// Êõ¥Êñ∞ËÆ°Êó∂Âô®ÊòæÁ§∫
function updateUnlockTimer() {
    document.getElementById('unlockTimer').textContent = 
        `ÂºÄÈó®ÂÄíËÆ°Êó∂: ${singlePlayerGame.unlockTimeLeft}Áßí`;
}
function checkSinglePlayerExit() {
    // Ê£ÄÊü•Áé©ÂÆ∂ÊòØÂê¶Âú®Âá∫Âè£‰ΩçÁΩÆ
    if (singlePlayerGame.player.x === singlePlayerGame.exit.x && 
        singlePlayerGame.player.y === singlePlayerGame.exit.y) {
        
        // Â¶ÇÊûúÊòØÁâπÊÆäÂÖ≥Âç°‰∏îÊúâÈó®ÁöÑ‰ΩçÁΩÆ
        if (gameState.specialLevels.includes(gameState.currentLevel) && 
            singlePlayerGame.doorPosition) {
            
            // Ê£ÄÊü•Èó®ÊòØÂê¶Â∑≤ÁªèÊâìÂºÄ
            if (singlePlayerGame.maze[singlePlayerGame.doorPosition.y][singlePlayerGame.doorPosition.x] === 0) {
                // Èó®Â∑≤ÊâìÂºÄÔºåÂèØ‰ª•ÈÄöÂÖ≥
                completeLevel();
            } else {
                // Èó®Êú™ÊâìÂºÄÔºåÊèêÁ§∫Áé©ÂÆ∂ÈúÄË¶ÅÈí•Âåô
                alert("‰Ω†ÈúÄË¶ÅÊâæÂà∞Èí•ÂåôÂπ∂ÊâìÂºÄÈó®ÊâçËÉΩÈÄöÂÖ≥ÔºÅ");
                // Â∞ÜÁé©ÂÆ∂ÁßªÂõûÈó®ÂâçÁöÑ‰ΩçÁΩÆ
                const directions = [
                    {dx: 1, dy: 0}, {dx: -1, dy: 0}, 
                    {dx: 0, dy: 1}, {dx: 0, dy: -1}
                ];
                
                let moved = false;
                for (const dir of directions) {
                    const nx = singlePlayerGame.exit.x + dir.dx;
                    const ny = singlePlayerGame.exit.y + dir.dy;
                    
                    if (nx >= 0 && nx < singlePlayerGame.maze[0].length && 
                        ny >= 0 && ny < singlePlayerGame.maze.length &&
                        singlePlayerGame.maze[ny][nx] === 0) {
                        singlePlayerGame.player.x = nx;
                        singlePlayerGame.player.y = ny;
                        moved = true;
                        break;
                    }
                }
                
                // Â¶ÇÊûúÊó†Ê≥ïÁßªÂä®Áé©ÂÆ∂ÔºåÂàôÈáçÁΩÆÂà∞Ëµ∑ÁÇπ
                if (!moved) {
                    singlePlayerGame.player = findStartPosition(singlePlayerGame.maze);
                }
                
                drawSinglePlayerMaze();
            }
        } else {
            // ÊôÆÈÄöÂÖ≥Âç°ÔºåÁõ¥Êé•ÈÄöÂÖ≥
            completeLevel();
        }
    }
}

async function connectToMultiplayerGame() {
    const playerName = document.getElementById('playerName').value.trim() || 'Áé©ÂÆ∂';
    const roomCodeInput = document.getElementById('roomCode').value.trim();
    const maxPlayers = parseInt(document.getElementById('maxPlayers').value) || 4;
    
    // ËÆæÁΩÆÊúÄÂ§ßÁé©ÂÆ∂Êï∞
    gameState.multiplayer.maxPlayers = maxPlayers;
    
    if (roomCodeInput) {
        try {
            // ÂÖàÊ£ÄÊü•ÊàøÈó¥ÊòØÂê¶Â≠òÂú®
            const response = await fetch(`http://${roomManager.serverUrl}/api/rooms`, {
                timeout: 5000
            });
            
            if (response.ok) {
                const data = await response.json();
                const room = data.rooms.find(r => r.id === roomCodeInput);
                
                if (room) {
                    gameState.playerName = playerName;
                    gameState.roomCode = roomCodeInput;
                    
                    // Â∞ùËØïÂä†ÂÖ•ÊàøÈó¥ - ‰ΩøÁî®Êñ∞ÁöÑÂáΩÊï∞Âêç
                    await joinRoom(roomCodeInput);
                } else {
                    showNotification('ÊàøÈó¥‰∏çÂ≠òÂú®', 'error');
                }
            } else {
                throw new Error('Êó†Ê≥ïÊü•ËØ¢ÊàøÈó¥ÂàóË°®');
            }
        } catch (error) {
            showNotification(`Âä†ÂÖ•ÊàøÈó¥Â§±Ë¥•: ${error.message}`, 'error');
        }
        return;
    }

    try {
        // ‰ΩøÁî®Êñ∞ÁöÑÊàøÈó¥ÂàõÂª∫API
        const roomId = await roomManager.createRoom({
            playerName: playerName,
            maxPlayers: maxPlayers,
            roomName: `ÊàøÈó¥_${Math.floor(Math.random() * 1000)}`,
            isPrivate: false
        });
        
        if (roomId) {
            // ÂàõÂª∫ÊàêÂäüÔºåÁªßÁª≠‰ΩøÁî®ÂéüÊúâÁöÑP2PÈÄªËæë
            gameState.playerName = playerName;
            gameState.multiplayer.isHost = true;
            gameState.multiplayer.roomCode = roomId;
            
            // ÂàùÂßãÂåñPeerËøûÊé•
            gameState.multiplayer.peer = new Peer(roomId, {
                debug: 2,
                config: {
                    'iceServers': [
                        { urls: 'stun:stun.l.google.com:19302' },
                        { urls: 'stun:stun1.l.google.com:19302' }
                    ]
                }
            });
            
            // ËÆæÁΩÆPeer‰∫ã‰ª∂Â§ÑÁêÜ
            gameState.multiplayer.peer.on('open', (id) => {
                console.log('PeerËøûÊé•Âª∫Á´ãÔºåID:', id);
                gameState.multiplayer.currentPlayerId = id;
                setupAsHost(id);
            });
            
            gameState.multiplayer.peer.on('connection', (conn) => {
                console.log('Êî∂Âà∞ËøûÊé•ËØ∑Ê±Ç:', conn.peer);
                setupConnection(conn);
            });
            
            gameState.multiplayer.peer.on('error', (err) => {
                console.error('PeerÈîôËØØ:', err);
                alert('ËøûÊé•ÈîôËØØ: ' + err);
                showScreen('multiplayerSetup');
            });
        }
    } catch (error) {
        showNotification(`ÂàõÂª∫ÊàøÈó¥Â§±Ë¥•: ${error.message}`, 'error');
    }
}
async function testServerConnection() {
    const serverUrl = document.getElementById('serverUrl').value.trim();
    if (!serverUrl) {
        showNotification('ËØ∑ÂÖàËæìÂÖ•ÊúçÂä°Âô®Âú∞ÂùÄ', 'error');
        return;
    }

    // Êõ¥Êñ∞ÊàøÈó¥ÁÆ°ÁêÜÂô®ÁöÑÊúçÂä°Âô®Âú∞ÂùÄ
    roomManager.serverUrl = serverUrl;
    localStorage.setItem('serverUrl', serverUrl);

    const testBtn = document.getElementById('testServerBtn');
    const originalText = testBtn.textContent;
    testBtn.textContent = 'ÊµãËØï‰∏≠...';
    testBtn.disabled = true;

    try {
        showNotification('Ê≠£Âú®ÊµãËØïËøûÊé•...', 'info');
        
        // ÊµãËØïÂü∫Êú¨ËøûÊé•
        const response = await fetch(roomManager.getApiUrl('/api/server-status'), {
            timeout: 5000
        });

        if (response.ok) {
            const data = await response.json();
            showNotification(`‚úÖ ËøûÊé•ÊàêÂäüÔºÅÊúçÂä°Âô®ÁâàÊú¨: ${data.version || 'Êú™Áü•'}`, 'success');
            roomManager.checkServerConnection();
        } else {
            throw new Error(`HTTP ${response.status}`);
        }
    } catch (error) {
        console.error('ËøûÊé•ÊµãËØïÂ§±Ë¥•:', error);
        showNotification(`‚úó ËøûÊé•Â§±Ë¥•: ${error.message}`, 'error');
    } finally {
        testBtn.textContent = originalText;
        testBtn.disabled = false;
    }
}
function createLocalRoom() {
    const roomData = {
        playerName: document.getElementById('playerName').value.trim() || 'Áé©ÂÆ∂',
        maxPlayers: parseInt(document.getElementById('maxPlayers').value) || 4,
        roomName: `Êú¨Âú∞ÊàøÈó¥_${Math.floor(Math.random() * 1000)}`,
        isPrivate: false
    };

    // ÁîüÊàêÁÆÄÂçïÁöÑÊàøÈó¥‰ø°ÊÅØ
    const roomId = `OFF-${Math.floor(10000 + Math.random() * 90000)}`;
    
    showNotification(`Êú¨Âú∞ÊàøÈó¥ÂàõÂª∫ÊàêÂäüÔºÅÊàøÈó¥Á†Å: ${roomId}`, 'success');
    
    // Á´ãÂç≥Âä†ÂÖ•ÊàøÈó¥
    gameState.playerName = roomData.playerName;
    gameState.roomCode = roomId;
    
    // Ê®°ÊãüÂä†ÂÖ•ÊàøÈó¥ÁöÑËøáÁ®ã
    showScreen('multiplayerGame');
    startMultiplayerGame();
}
async function joinRoom(roomId) {
    const room = roomManager.rooms.get(roomId);
    if (!room || room.players >= room.maxPlayers) {
        return;
    }
    
    const playerName = document.getElementById('playerName').value.trim() || 'Áé©ÂÆ∂';
    if (!confirm(`Á°ÆÂÆöË¶ÅÂä†ÂÖ•ÊàøÈó¥ "${room.name}" ÂêóÔºü`)) {
        return;
    }
    
    // ‰ΩøÁî®Êñ∞ËøûÊé•ÈÄªËæë
    try {
        showNotification('Ê≠£Âú®ËøûÊé•...', 'info');
        
        // ÂàùÂßãÂåñPeerËøûÊé•
        gameState.multiplayer.peer = new Peer(null, {
            debug: 2,
            config: {
                'iceServers': [
                    { urls: 'stun:stun.l.google.com:19302' },
                    { urls: 'stun:stun1.l.google.com:19302' }
                ]
            }
        });
        
        gameState.multiplayer.peer.on('open', (id) => {
            gameState.multiplayer.currentPlayerId = id;
            
            // ËøûÊé•Âà∞ÊàøÈó¥
            const conn = gameState.multiplayer.peer.connect(roomId, {
                reliable: true
            });
            
            setupConnection(conn);
            
            conn.on('open', () => {
                // ÂèëÈÄÅÂä†ÂÖ•ËØ∑Ê±Ç
                conn.send({
                    type: 'player-join',
                    player: {
                        id: id,
                        name: playerName,
                        color: getRandomColor()
                    }
                });
                
                showNotification('ËøûÊé•ÊàêÂäüÔºÅ', 'success');
                showScreen('multiplayerGame');
            });
        });
        
    } catch (error) {
        console.error('Âä†ÂÖ•ÊàøÈó¥Â§±Ë¥•:', error);
        showNotification(`Âä†ÂÖ•ÊàøÈó¥Â§±Ë¥•: ${error.message}`, 'error');
    }
}

        function setupAsHost(peerId) {
            // ÁîüÊàêÂ§ö‰∫∫Ê∏∏ÊàèËø∑ÂÆ´
            console.log("ÁîüÊàêÂ§ö‰∫∫Ê∏∏ÊàèËø∑ÂÆ´")
            gameState.multiplayer.maze = generateMultiplayerMaze();
            
            // Ê∑ªÂä†Ëá™Â∑±‰Ωú‰∏∫Áé©ÂÆ∂
            gameState.multiplayer.players[peerId] = {
                id: peerId,
                name: gameState.playerName,
                x: 1,
                y: 1,
                color: getRandomColor(),
                reachedExit: false,
                isHost: true
            };
            
            // ËÆæÁΩÆÊàøÈó¥‰ª£Á†ÅÊòæÁ§∫
            document.getElementById('multiplayerRoomCode').textContent = 
                `ÊàøÈó¥: ${peerId}`;
            
            // ÂºÄÂßãÂ§ö‰∫∫Ê∏∏Êàè
            console.log("ÂºÄÂßãÂ§ö‰∫∫Ê∏∏Êàè")
            startMultiplayerGame();
        }

        function connectToHost(hostId) {
            try {
                // ËøûÊé•Âà∞‰∏ªÊú∫
                console.log("ËøûÊé•Ëá≥‰∏ªÊú∫")
                const conn = gameState.multiplayer.peer.connect(hostId, {
                    reliable: true
                });
                
                if (!conn) {
                    console.error("Êó†Ê≥ïÂª∫Á´ãËøûÊé•")
                    throw new Error('Êó†Ê≥ïÂª∫Á´ãËøûÊé•');
                }
                
                setupConnection(conn);
                
                conn.on('open', () => {
                    console.log('Â∑≤ËøûÊé•Âà∞‰∏ªÊú∫');
                    // ÂèëÈÄÅÂä†ÂÖ•ËØ∑Ê±Ç
                    conn.send({
                        type: 'player-join',
                        player: {
                            id: gameState.multiplayer.currentPlayerId,
                            name: gameState.playerName,
                            color: getRandomColor()
                        }
                    });
                    
                    updateConnectionStatus('connected');
                });
                
                conn.on('error', (err) => {
                    console.error('ËøûÊé•ÈîôËØØ:', err);
                    alert('ËøûÊé•‰∏ªÊú∫Â§±Ë¥•: ' + err);
                    updateConnectionStatus('disconnected');
                    disconnectMultiplayer()
                });
                
            } catch (err) {
                console.error('ËøûÊé•ÂºÇÂ∏∏:', err);
                alert('ËøûÊé•ÂºÇÂ∏∏: ' + err.message);
                updateConnectionStatus('disconnected');
                disconnectMultiplayer()
            }
        }

        function setupConnection(conn) {
            // Ê£ÄÊü•ÊòØÂê¶ËææÂà∞ÊúÄÂ§ßÁé©ÂÆ∂Êï∞
            if (gameState.multiplayer.isHost && 
                Object.keys(gameState.multiplayer.players).length >= gameState.multiplayer.maxPlayers) {
                console.log('ÊàøÈó¥Â∑≤Êª°ÔºåÊãíÁªùËøûÊé•:', conn.peer);
                conn.send({
                    type: 'room-full',
                    message: 'ÊàøÈó¥Â∑≤Êª°ÔºåÊó†Ê≥ïÂä†ÂÖ•'
                });
                conn.close();
                return;
            }
            
            // Â≠òÂÇ®ËøûÊé•
            gameState.multiplayer.connections[conn.peer] = conn;
            
            // Â§ÑÁêÜÊî∂Âà∞ÁöÑÊ∂àÊÅØ
            conn.on('data', (data) => {
                handleMultiplayerData(data, conn.peer);
            });
            
            conn.on('close', () => {
                console.log('ËøûÊé•ÂÖ≥Èó≠:', conn.peer);
                removePlayer(conn.peer);
            });
            
            conn.on('error', (err) => {
                console.error('ËøûÊé•ÈîôËØØ:', conn.peer, err);
                removePlayer(conn.peer);
            });
        }
// ÁîüÊàêÁÆÄÁü≠ÊàøÈó¥Âè∑Ôºà5‰ΩçÊï∞Â≠óÔºâ
function generateShortRoomCode() {
    // ÁîüÊàê5‰ΩçÈöèÊú∫Êï∞Â≠ó
    const code = Math.floor(10000 + Math.random() * 90000).toString();
    return `room_${code}`;
}
// Êó∂Èó¥ÊåëÊàòÊ®°Âºè
function startTimeChallenge() {
    gameState.currentChallenge = 'time';
    gameState.currentLevel = 1;
    showScreen('singlePlayerGame');
    
    // Ê∑ªÂä†Êó∂Èó¥ÊåëÊàòUI
    const timeChallengeInfo = document.createElement('div');
    timeChallengeInfo.className = 'time-challenge-info';
    timeChallengeInfo.id = 'timeChallengeInfo';
    timeChallengeInfo.innerHTML = '‚è±Ô∏è Êó∂Èó¥ÊåëÊàòÊ®°Âºè<br>Ââ©‰ΩôÊó∂Èó¥: <span id="challengeTimeLeft">60</span>Áßí';
    document.getElementById('singlePlayerGame').appendChild(timeChallengeInfo);
    
    // ÂêØÂä®Êó∂Èó¥ÊåëÊàòËÆ°Êó∂Âô®
    startTimeChallengeTimer();
}

function startTimeChallengeTimer() {
    let timeLeft = 60; // 60ÁßíÊåëÊàò
    const timerElement = document.getElementById('challengeTimeLeft');
    
    const challengeTimer = setInterval(() => {
        timeLeft--;
        timerElement.textContent = timeLeft;
        
        if (timeLeft <= 0) {
            clearInterval(challengeTimer);
            alert('Êó∂Èó¥Âà∞ÔºÅÊåëÊàòÂ§±Ë¥•ÔºÅ');
            showScreen('moreChallenges');
            document.getElementById('timeChallengeInfo').remove();
        }
        
        // Êó∂Èó¥Ë≠¶Âëä
        if (timeLeft <= 10) {
            timerElement.style.color = '#ff4444';
            timerElement.style.animation = 'pulse 0.5s infinite';
        }
    }, 1000);
    
    // ‰øùÂ≠òËÆ°Êó∂Âô®ÂºïÁî®‰ª•‰æøÊ∏ÖÁêÜ
    gameState.challengeTimer = challengeTimer;
}

// Ëß£Ë∞úÊ®°Âºè
function startPuzzleMode() {
    gameState.currentChallenge = 'puzzle';
    gameState.currentLevel = 1;
    showScreen('singlePlayerGame');
    
    // ËøôÈáåÂèØ‰ª•Ê∑ªÂä†ÁâπÊÆäÁöÑËß£Ë∞úÂÖ≥Âç°ÈÄªËæë
    // ‰æãÂ¶ÇÔºöÈúÄË¶ÅÊåâÁÖßÁâπÂÆöÈ°∫Â∫èË∏©Ë∏èÊåâÈíÆÁ≠â
}

// ÊàêÂ∞±Á≥ªÁªüÂáΩÊï∞
function updateAchievementProgress() {
    // Êõ¥Êñ∞ÊàêÂ∞±1ÔºöÈÄöÂÖ≥ÊâÄÊúâÂÖ≥Âç°
    const totalLevels = 80;
    const progress1 = (gameState.achievements.allLevelsCompleted ? totalLevels : gameState.gameStats.totalLevelsCompleted) / totalLevels * 100;
    document.getElementById('progress1').style.width = progress1 + '%';
    document.getElementById('progressText1').textContent = 
        gameState.achievements.allLevelsCompleted ? '80/80' : gameState.gameStats.totalLevelsCompleted + '/80';
    
    if (gameState.achievements.allLevelsCompleted) {
        document.getElementById('achievement1').classList.add('completed');
        document.getElementById('status1').textContent = 'Â∑≤ÂÆåÊàê';
    }
    
    // Êõ¥Êñ∞ÊàêÂ∞±2ÔºöÂ§ö‰∫∫Ê∏∏ÊàèËÉúÂà©
    const progress2 = Math.min(gameState.achievements.multiplayerWins / 10 * 100, 100);
    document.getElementById('progress2').style.width = progress2 + '%';
    document.getElementById('progressText2').textContent = gameState.achievements.multiplayerWins + '/10';
    
    if (gameState.achievements.multiplayerWins >= 10) {
        document.getElementById('achievement2').classList.add('completed');
        document.getElementById('status2').textContent = 'Â∑≤ÂÆåÊàê';
    }
    
    // Êõ¥Êñ∞ÊàêÂ∞±3ÔºöÈô∑Èò±Ê¨°Êï∞
    const progress3 = Math.min(gameState.achievements.trapHits / 10 * 100, 100);
    document.getElementById('progress3').style.width = progress3 + '%';
    document.getElementById('progressText3').textContent = gameState.achievements.trapHits + '/30';
    
    if (gameState.achievements.trapHits >= 30) {
        document.getElementById('achievement3').classList.add('completed');
        document.getElementById('status3').textContent = 'Â∑≤ÂÆåÊàê';
    }
}

// ËÆ∞ÂΩïÊàêÂ∞±ËøõÂ∫¶
function recordAchievement(type, value = 1) {
    switch(type) {
        case 'levelComplete':
            gameState.gameStats.totalLevelsCompleted += value;
            
            // Ê£ÄÊü•ÊòØÂê¶ÂÆåÊàêÊâÄÊúâÂÖ≥Âç°
            if (gameState.gameStats.totalLevelsCompleted == 80) {
                gameState.achievements.allLevelsCompleted = true;
                showAchievementUnlocked('Ëø∑ÂÆ´Â§ßÂ∏à', 'ÊÅ≠Âñú‰Ω†ÈÄöÂÖ≥ÊâÄÊúâÂÖ≥Âç°ÔºÅ');
            }
            break;
            
        case 'multiplayerWin':
            gameState.achievements.multiplayerWins += value;
            
            if (gameState.achievements.multiplayerWins == 10) {
                showAchievementUnlocked('Á§æ‰∫§Ëææ‰∫∫', 'ÂÆåÊàê10Ê¨°Â§ö‰∫∫ËÅîÊú∫ÊåëÊàòÔºÅ');
            }
            break;
            
        case 'trapHit':
            gameState.achievements.trapHits += value;
            
            if (gameState.achievements.trapHits == 30) {
                showAchievementUnlocked('Èô∑Èò±‰∏ìÂÆ∂', 'ÊàêÂäüË∏©‰∏≠Èô∑Èò±30Ê¨°ÔºÅ');
            }
            break;
    }
    
    saveGameData();
    updateAchievementProgress();
}

// ÊòæÁ§∫ÊàêÂ∞±Ëß£ÈîÅÊèêÁ§∫
function showAchievementUnlocked(title, description) {
    const notification = document.createElement('div');
    notification.style.cssText = `
        position: fixed;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        background: rgba(0, 0, 0, 0.9);
        border: 3px solid #FFD700;
        border-radius: 15px;
        padding: 20px;
        text-align: center;
        z-index: 10000;
        animation: popIn 0.5s ease-out;
    `;
    
    notification.innerHTML = `
        <h3 style="color: #FFD700; margin: 0 0 10px 0;">üèÜ ÊàêÂ∞±Ëß£ÈîÅÔºÅ</h3>
        <h4 style="color: white; margin: 0 0 10px 0;">${title}</h4>
        <p style="color: #ccc; margin: 0;">${description}</p>
    `;
    
    document.body.appendChild(notification);
    
    setTimeout(() => {
        notification.remove();
    }, 5000);
}

// Â≠òÊ°£Á≥ªÁªü
// Êñ∞Â¢ûÂà†Èô§Â≠òÊ°£ÂäüËÉΩ
function deleteSave(slot) {
    gameState.saveSlots[slot] = {};
    localStorage.setItem('saveSlots', JSON.stringify(gameState.saveSlots));
    showNotification(`Â≠òÊ°£‰ΩçÁΩÆ ${slot + 1} Â∑≤Âà†Èô§`);
}

// ‰øÆÊîπ‰øùÂ≠òÊ∏∏ÊàèÂáΩÊï∞ - Á°Æ‰øù‰øùÂ≠òÁé©ÂÆ∂‰ΩçÁΩÆ
function saveGame(slot = gameState.currentSaveSlot) {
    // ‰øùÂ≠òÊ†∏ÂøÉËøõÂ∫¶Êï∞ÊçÆÂíåÂΩìÂâçÁé©ÂÆ∂‰ΩçÁΩÆ
    const saveData = {
        unlockedLevel: gameState.unlockedLevel,
        completedLevels: gameState.completedLevels,
        achievements: gameState.achievements,
        gameStats: gameState.gameStats,
        currentLevel: gameState.currentLevel,
        playerData: {
            x: singlePlayerGame.player.x,
            y: singlePlayerGame.player.y,
            hasKey: singlePlayerGame.hasKey
        },
        mazeState: JSON.parse(JSON.stringify(singlePlayerGame.maze)) // ‰øùÂ≠òËø∑ÂÆ´Áä∂ÊÄÅ
    };
    
    gameState.saveSlots[slot] = saveData;
    localStorage.setItem('saveSlots', JSON.stringify(gameState.saveSlots));
    showNotification(`Ê∏∏ÊàèÂ∑≤Â≠òÊ°£Ëá≥‰ΩçÁΩÆ ${slot + 1}`);
}

// Ê≠£Á°ÆÂä†ËΩΩÁé©ÂÆ∂‰ΩçÁΩÆ
function loadGame(slot = gameState.currentSaveSlot) {
    const saveData = gameState.saveSlots[slot];
    if (!saveData) return false;
    
    // ÊÅ¢Â§çÊ∏∏ÊàèÁä∂ÊÄÅ
    gameState.unlockedLevel = saveData.unlockedLevel;
    gameState.completedLevels = saveData.completedLevels;
    gameState.achievements = saveData.achievements;
    gameState.gameStats = saveData.gameStats;
    gameState.currentLevel = saveData.currentLevel;
    
    // ÊÅ¢Â§çÁé©ÂÆ∂‰ΩçÁΩÆÂíåÁä∂ÊÄÅ
    if (saveData.playerData) {
        singlePlayerGame.player.x = saveData.playerData.x;
        singlePlayerGame.player.y = saveData.playerData.y;
        singlePlayerGame.hasKey = saveData.playerData.hasKey || false;
    } else {
        // ÂÖºÂÆπÊóßÂ≠òÊ°£
        singlePlayerGame.player.x = 1;
        singlePlayerGame.player.y = 1;
        singlePlayerGame.hasKey = false;
    }
    
    // ÊÅ¢Â§çËø∑ÂÆ´Áä∂ÊÄÅ
    if (saveData.mazeState) {
        singlePlayerGame.maze = saveData.mazeState;
        
        // ÊÅ¢Â§çÈí•ÂåôÂíåÈó®ÁöÑ‰ΩçÁΩÆÔºàÂ¶ÇÊûúÈúÄË¶ÅÔºâ
        if (saveData.playerData && saveData.playerData.hasKey) {
            // Êü•ÊâæÈí•Âåô‰ΩçÁΩÆÔºàÂ¶ÇÊûúÂ≠òÂú®Ôºâ
            for (let y = 0; y < singlePlayerGame.maze.length; y++) {
                for (let x = 0; x < singlePlayerGame.maze[y].length; x++) {
                    if (singlePlayerGame.maze[y][x] === 8) {
                        singlePlayerGame.keyPosition = {x, y};
                        break;
                    }
                }
            }
            
            // Êü•ÊâæÈó®‰ΩçÁΩÆÔºàÂ¶ÇÊûúÂ≠òÂú®Ôºâ
            for (let y = 0; y < singlePlayerGame.maze.length; y++) {
                for (let x = 0; x < singlePlayerGame.maze[y].length; x++) {
                    if (singlePlayerGame.maze[y][x] === 9) {
                        singlePlayerGame.doorPosition = {x, y};
                        break;
                    }
                }
            }
        }
    }
    
    showNotification(`Â∑≤Âä†ËΩΩÂ≠òÊ°£‰ΩçÁΩÆ ${slot + 1}`);
    return true;
}



// Ê∑ªÂä†ÈÄöÁü•ÊòæÁ§∫ÂäüËÉΩ
function showNotification(message, duration = 5000) {
    // ÁßªÈô§Áé∞ÊúâÁöÑÈÄöÁü•
    const existingNotification = document.getElementById('gameNotification');
    if (existingNotification) {
        existingNotification.remove();
    }

    // ÂàõÂª∫Êñ∞ÁöÑÈÄöÁü•ÂÖÉÁ¥†
    const notification = document.createElement('div');
    notification.id = 'gameNotification';
    notification.textContent = message;
    notification.style.cssText = `
        position: fixed;
        top: 20px;
        left: 50%;
        transform: translateX(-50%);
        background: rgba(0,0,0,0.7);
        color: white;
        padding: 10px 20px;
        border-radius: 5px;
        z-index: 1000;
        animation: fadeIn 0.3s ease-out;
    `;

    document.body.appendChild(notification);

    // Ëá™Âä®Ê∂àÂ§±
    setTimeout(() => {
        notification.style.animation = 'fadeOut 0.3s ease-out';
        setTimeout(() => notification.remove(), 5000);
    }, duration);

    // Ê∑ªÂä†Âä®ÁîªÂÖ≥ÈîÆÂ∏ß
    const style = document.createElement('style');
    style.textContent = `
        @keyframes fadeIn {
            from { opacity: 0; transform: translateX(-50%) translateY(-20px); }
            to { opacity: 1; transform: translateX(-50%) translateY(0); }
        }
        @keyframes fadeOut {
            from { opacity: 1; transform: translateX(-50%) translateY(0); }
            to { opacity: 0; transform: translateX(-50%) translateY(-20px); }
        }
    `;
    document.head.appendChild(style);
}



// ÈÄÄÂá∫Á°ÆËÆ§
function showExitConfirmation() {
    const modal = document.createElement('div');
    modal.id = 'exitConfirmationModal';
    modal.style.cssText = `
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: rgba(0,0,0,0.7);
        display: flex;
        justify-content: center;
        align-items: center;
        z-index: 1000;
    `;
    
    modal.innerHTML = `
        <div style="background: #333; padding: 20px; border-radius: 10px; width: 300px; max-width: 90%;">
            <h3 style="color: white; margin-top: 0; text-align: center;">ÈÄÄÂá∫ÂÖ≥Âç°</h3>
            <p style="color: #ccc; text-align: center;">ÊòØÂê¶Ë¶Å‰øùÂ≠òÂΩìÂâçËøõÂ∫¶Ôºü</p>
            <div style="display: flex; flex-direction: column; gap: 10px; margin-top: 20px;">
                <button id="saveAndExitBtn" style="padding: 10px; background: #4CAF50; color: white; border: none; border-radius: 5px;">‰øùÂ≠òÂπ∂ÈÄÄÂá∫</button>
                <button id="exitWithoutSavingBtn" style="padding: 10px; background: #f44336; color: white; border: none; border-radius: 5px;">‰∏ç‰øùÂ≠òÈÄÄÂá∫</button>
                <button id="cancelExitBtn" style="padding: 10px; background: #555; color: white; border: none; border-radius: 5px;">ÂèñÊ∂à</button>
            </div>
        </div>
    `;
    
    document.body.appendChild(modal);
    
    // Ê∑ªÂä†‰∫ã‰ª∂ÁõëÂê¨Âô®
    document.getElementById('saveAndExitBtn').addEventListener('click', () => {
        saveGame();  // ÈÄÄÂá∫Êó∂‰øùÂ≠ò
        showScreen('singlePlayerLevelSelect');
        modal.remove();
    });
    
    document.getElementById('exitWithoutSavingBtn').addEventListener('click', () => {
        showScreen('singlePlayerLevelSelect');
        modal.remove();
    });
    
    document.getElementById('cancelExitBtn').addEventListener('click', () => {
        modal.remove();
    });
}

function handleMultiplayerData(data, peerId) {
            if (peerId === gameState.multiplayer.currentPlayerId && (data.type !== 'game-state')) {
                return;
            }
            switch(data.type) {
                case 'private-message':
                    // Êî∂Âà∞ÁßÅËÅäÊ∂àÊÅØ
                    console.log(data);
                    const sender = gameState.multiplayer.players[data.from];
                    if (sender) {
                        const msg = `${data.message}`;
                        showMessageToSelf(msg);
                        alert(msg); // ÂºπÂá∫ÊèêÁ§∫
                    }
                    break;
                case 'room-full':
                    disconnectMultiplayer();
                    showScreen('multiplayerSetup');
                    alert('ÊàøÈó¥Â∑≤Êª°ÔºåÊó†Ê≥ïÂä†ÂÖ•');
                    break;
                case 'door-open':
                        gameState.multiplayer.maze[data.y][data.x] = 0;
                        document.getElementById('unlockTimer').classList.add('hidden');
                        gameState.multiplayer.isUnlocking = false;
                        drawMultiplayerMaze();
                    break;  
                case 'player-join':
                    // Êñ∞Áé©ÂÆ∂Âä†ÂÖ•
                    console.log(data);
                    addPlayer(data.player);
                    // Â¶ÇÊûúÊòØ‰∏ªÊú∫ÔºåÂèëÈÄÅÂΩìÂâçÊ∏∏ÊàèÁä∂ÊÄÅÁªôÊñ∞Áé©ÂÆ∂
                    if (gameState.multiplayer.isHost) {
                        gameState.multiplayer.connections[peerId].send({
                            type: 'game-state',
                            maze: gameState.multiplayer.maze,
                            players: gameState.multiplayer.players,
                            exit: gameState.multiplayer.exit,
                            teleporters: gameState.multiplayer.teleporters,
                            maxPlayers: gameState.multiplayer.maxPlayers,
                            protectedPlayers: gameState.multiplayer.protectedPlayers
                        });
                    }
                    drawMultiplayerMaze();
                    break;
                case 'key-pickup':
                    if (gameState.multiplayer.players[data.playerId]) {
                        gameState.multiplayer.players[data.playerId].hasKey = true;
                        delete gameState.multiplayer.keyPosition;
                        drawMultiplayerMaze();
                    }
                    break;
                case 'game-state':
                        // Êî∂Âà∞Ê∏∏ÊàèÁä∂ÊÄÅÔºàÂÆ¢Êà∑Á´ØÔºâ
                        gameState.multiplayer.maze = data.maze;
                        gameState.multiplayer.players = data.players;
                        gameState.multiplayer.exit = data.exit;
                        gameState.multiplayer.teleporters = data.teleporters;
                        gameState.multiplayer.movingEnemies = data.movingEnemies || [];
                        gameState.multiplayer.keyPosition = data.keyPosition || null;
                        gameState.multiplayer.doorPosition = data.doorPosition || null;
                        gameState.multiplayer.maxPlayers = data.maxPlayers;
                        gameState.multiplayer.protectedPlayers = data.protectedPlayers || {};
                        
                        // Ê∑ªÂä†Ëá™Â∑±Âà∞Áé©ÂÆ∂ÂàóË°®
                        if (!gameState.multiplayer.players[gameState.multiplayer.currentPlayerId]) {
                            gameState.multiplayer.players[gameState.multiplayer.currentPlayerId] = {
                                id: gameState.multiplayer.currentPlayerId,
                                name: gameState.playerName,
                                x: 1,
                                y: 1,
                                color: getRandomColor(),
                                reachedExit: false
                            };
                        }
                        
                        // ÂºÄÂßãÊ∏∏Êàè
                        startMultiplayerGame();
                        break;
                    
                case 'enemy-move':
                    // Êõ¥Êñ∞Êïå‰∫∫‰ΩçÁΩÆ
                    if (data.enemies) {
                        gameState.multiplayer.movingEnemies = data.enemies;
                        drawMultiplayerMaze();
                    }
                    break;
                case 'player-move':
                    if (peerId === gameState.multiplayer.currentPlayerId) {
                        break;
                    }
                    // Áé©ÂÆ∂ÁßªÂä®
                    if (gameState.multiplayer.players[peerId]) {
                        gameState.multiplayer.players[peerId].x = data.x;
                        gameState.multiplayer.players[peerId].y = data.y;
                        
                        // Ê£ÄÊü•ÊòØÂê¶Âà∞ËææÂá∫Âè£
                        if (data.x === gameState.multiplayer.exit.x && 
                            data.y === gameState.multiplayer.exit.y) {
                            gameState.multiplayer.players[peerId].reachedExit = true;
                            
                            // ÂπøÊí≠Áé©ÂÆ∂Âà∞ËææÂá∫Âè£
                            broadcast({
                                type: 'player-reached-exit',
                                playerId: peerId
                            });
                        }
                        
                        drawMultiplayerMaze();
                        updatePlayerList();
                    }
                    break;
                case 'key-pickup':
                        if (gameState.multiplayer.players[data.playerId]) {
                            gameState.multiplayer.players[data.playerId].hasKey = true;
                            delete gameState.multiplayer.keyPosition;
                            drawMultiplayerMaze();
                        }
                        break;
                        
                case 'door-open':
                        gameState.multiplayer.maze[data.y][data.x] = 0;
                        drawMultiplayerMaze();
                        break;
                        
                case 'enemy-move':
                        if (gameState.multiplayer.movingEnemies) {
                            gameState.multiplayer.movingEnemies = data.enemies;
                            drawMultiplayerMaze();
                        }
                        break;    
                case 'teleport-request':
                    // Â§ÑÁêÜ‰º†ÈÄÅËØ∑Ê±ÇÔºàÂè™Êúâ‰∏ªÊú∫‰ºöÊî∂Âà∞Ôºâ
                    console.log(data);
                    if (gameState.multiplayer.isHost) {
                        const teleporter = gameState.multiplayer.teleporters.find(t => 
                            t.x === data.teleporterX && t.y === data.teleporterY);
                        
                        if (teleporter && gameState.multiplayer.players[data.playerId]) {
                            // ‰º†ÈÄÅÁé©ÂÆ∂
                            gameState.multiplayer.players[data.playerId].x = teleporter.pairX;
                            gameState.multiplayer.players[data.playerId].y = teleporter.pairY;
                            
                            // ÂπøÊí≠‰º†ÈÄÅ
                            broadcast({
                                type: 'player-teleport',
                                playerId: data.playerId,
                                x: teleporter.pairX,
                                y: teleporter.pairY
                            });
                            
                            drawMultiplayerMaze();
                            updatePlayerList();
                        }
                    }
                    break;
                    
                case 'player-teleport':
                    console.log(data);
                    // Â§ÑÁêÜÁé©ÂÆ∂‰º†ÈÄÅ
                    if (gameState.multiplayer.players[data.playerId]) {
                        gameState.multiplayer.players[data.playerId].x = data.x;
                        gameState.multiplayer.players[data.playerId].y = data.y;
                        drawMultiplayerMaze();
                        updatePlayerList();
                    }
                    break;
                    
                case 'player-reached-exit':
                    console.log(data);
                    // Áé©ÂÆ∂Âà∞ËææÂá∫Âè£
                    if (gameState.multiplayer.players[data.playerId]) {
                        gameState.multiplayer.players[data.playerId].reachedExit = true;
                        
                        // Ê£ÄÊü•ÊòØÂê¶ÊâÄÊúâÁé©ÂÆ∂ÈÉΩÂà∞ËææÂá∫Âè£
                        checkAllPlayersReachedExit();
                        
                        updatePlayerList();
                    }
                    break;
                    
                case 'player-joined':
                    console.log(data);
                    // Êñ∞Áé©ÂÆ∂Âä†ÂÖ•ÈÄöÁü•
                    if (!gameState.multiplayer.players[data.player.id]) {
                        gameState.multiplayer.players[data.player.id] = data.player;
                        updatePlayerList();
                        drawMultiplayerMaze();
                    }
                    break;
                    
                case 'player-kicked':
                    console.log(data);
                    // Áé©ÂÆ∂Ë¢´Ë∏¢Âá∫ÈÄöÁü•
                    if (data.playerId === gameState.multiplayer.currentPlayerId) {
                        alert('‰Ω†Â∑≤Ë¢´ÁÆ°ÁêÜÂëòË∏¢Âá∫ÊàøÈó¥');
                        disconnectMultiplayer();
                        showScreen('multiplayerSetup');
                    } else {
                        removePlayer(data.playerId);
                    }
                    break;
                    
                case 'player-protected':
                    console.log(data);
                    // Áé©ÂÆ∂‰øùÊä§Áä∂ÊÄÅÊõ¥Êñ∞
                    if (data.protected) {
                        gameState.multiplayer.protectedPlayers[data.playerId] = true;
                    } else {
                        delete gameState.multiplayer.protectedPlayers[data.playerId];
                    }
                    updatePlayerList();
                    break;
                    
                case 'kick-player':
                    console.log(data);
                    // Ë∏¢Âá∫Áé©ÂÆ∂ËØ∑Ê±ÇÔºàÂè™Êúâ‰∏ªÊú∫‰ºöÊî∂Âà∞Ôºâ
                    if (gameState.multiplayer.isHost) {
                        const playerId = data.playerId;
                        const reason = data.reason || 'Êú™Áü•ÂéüÂõ†';
                        
                        // Ê£ÄÊü•Áé©ÂÆ∂ÊòØÂê¶Âèó‰øùÊä§
                        if (gameState.multiplayer.protectedPlayers[playerId]) {
                            // ÂèëÈÄÅË∏¢Âá∫Â§±Ë¥•Ê∂àÊÅØ
                            gameState.multiplayer.connections[data.requestorId].send({
                                type: 'kick-failed',
                                playerId: playerId,
                                reason: 'err75937'
                            });
                        } else {
                            // Ë∏¢Âá∫Áé©ÂÆ∂
                            kickPlayer(playerId, reason);
                        }
                    }
                    break;
                    
                case 'kick-failed':
                    console.log(data);
                    // Ë∏¢Âá∫Â§±Ë¥•ÈÄöÁü•
                    alert(`Ë∏¢Âá∫Áé©ÂÆ∂Â§±Ë¥•: ${data.reason}`);
                    break;
            }
        }

        function addPlayer(player) {
            gameState.multiplayer.players[player.id] = {
                ...player,
                x: 1,
                y: 1,
                reachedExit: false
            };
            
            // ÂπøÊí≠Êñ∞Áé©ÂÆ∂Âä†ÂÖ•ÔºàÈô§‰∫ÜËá™Â∑±Ôºâ
            broadcast({
                type: 'player-joined',
                player: gameState.multiplayer.players[player.id]
            }, player.id);
            
            updatePlayerList();
            drawMultiplayerMaze();
        }

        function removePlayer(playerId) {
            delete gameState.multiplayer.players[playerId];
            delete gameState.multiplayer.connections[playerId];
            delete gameState.multiplayer.protectedPlayers[playerId];
            
            updatePlayerList();
            drawMultiplayerMaze();
        }


function broadcast(data, excludePlayerId = null) {
    for (const connId in gameState.multiplayer.connections) {
        if (connId !== excludePlayerId) {
            const connection = gameState.multiplayer.connections[connId];
            if (connection.open) {  // Âè™ÊúâËøûÊé•ÊâìÂºÄÊó∂ÊâçÂèëÈÄÅ
                try {
                    connection.send(data);
                } catch (err) {
                    console.error('ÂπøÊí≠ÈîôËØØ:', err);
                    showNotification(`‚ùå ÂπøÊí≠ÈîôËØØ: ${err.message}`, 'error');
                    // Â¶ÇÊûúÂèëÈÄÅÂ§±Ë¥•ÔºåÂ§ÑÁêÜËøûÊé•Â§±ÊïàÁöÑÊÉÖÂÜµ
                    removePlayer(connId);
                }
            }
        }
    }
}

        function startMultiplayerGame() {
            gameState.multiplayer.connected = true;
            gameState.multiplayer.moveCount = 0;
            gameState.multiplayer.hasKey = false;
            gameState.multiplayer.isUnlocking = false;
            gameState.multiplayer.unlockTimeLeft = 10;
            clearInterval(gameState.multiplayer.unlockTimer);
            
            // Â¶ÇÊûúÊòØËû∫ÊóãËø∑ÂÆ´ÔºåÊòæÁ§∫Êïå‰∫∫Ë≠¶Âëä
            if (gameState.multiplayer.movingEnemies) {
                document.getElementById('enemyInfo').classList.remove('hidden');
                document.getElementById('keyInfo').classList.remove('hidden');
            } else {
                document.getElementById('enemyInfo').classList.add('hidden');
                document.getElementById('keyInfo').classList.add('hidden');
            }
                    
            // ËÆæÁΩÆÊàøÈó¥‰ª£Á†ÅÊòæÁ§∫
            document.getElementById('multiplayerRoomCode').textContent = 
                `ÊàøÈó¥: ${gameState.multiplayer.roomCode}`;
            document.getElementById('multiplayerMoveCount').textContent = `ÁßªÂä®: 0`;
            updatePlayerCount();

            // ÂàùÂßãÂåñÁîªÂ∏É
            console.log("ÂàùÂßãÂåñÁîªÂ∏É")
            initMultiplayerCanvas();
            // ÂºÄÂßãËÆ°Êó∂
            console.log("ÂºÄÂßãËÆ°Êó∂")
            startMultiplayerTimer();
            
            // Êõ¥Êñ∞ËøûÊé•Áä∂ÊÄÅ
            console.log("Êõ¥Êñ∞ËøûÊé•Áä∂ÊÄÅ")
            updateConnectionStatus('connected');
            
            // ÊòæÁ§∫Ê∏∏ÊàèÁïåÈù¢
            console.log("ÊòæÁ§∫Ê∏∏ÊàèÁîªÈù¢")
            showScreen('multiplayerGame');

            function gameLoop() {
                // updateMultiplayerGame();
                EventSystem.update();
                requestAnimationFrame(gameLoop);
            }
            
            // ÂêØÂä®Ê∏∏ÊàèÂæ™ÁéØ
            gameLoop();
            // Â∫îÁî®UIËÆæÁΩÆ
            console.log("Â∫îÁî®UIËÆæÁΩÆ")
            applyUISettings();
        }

function handleMultiplayerMoveLogic(dx, dy) {
    // 1. Ëé∑ÂèñÂΩìÂâçÂõûÂêàÁöÑÁé©ÂÆ∂ÂØπË±°
    const currentPlayer = gameState.multiplayer.players[gameState.multiplayer.currentPlayerId];
    if (!currentPlayer || currentPlayer.reachedExit) {
        return; // Â¶ÇÊûúÁé©ÂÆ∂‰∏çÂ≠òÂú®ÊàñÂ∑≤ÁªèÂà∞ËææÁªàÁÇπÔºåÂàô‰∏çÂÅö‰ªª‰Ωï‰∫ã
    }

    // 2. ËÆ°ÁÆóÊñ∞ÁöÑÁõÆÊ†á‰ΩçÁΩÆ
    const newX = currentPlayer.x + dx;
    const newY = currentPlayer.y + dy;

    // 3. ËæπÁïåÊ£ÄÊü•
    if (newY < 0 || newY >= gameState.multiplayer.maze.length || 
        newX < 0 || newX >= gameState.multiplayer.maze[0].length) {
        return;
    }

    const cellValue = gameState.multiplayer.maze[newY][newX];
    
    // 4. ËßÑÂàôÊ£ÄÊü•
    // --------------------------------------------------

    // 4.1 Â¢ô
    if (cellValue === 1) return;

    // 4.2 Èô∑Èò±
    if (cellValue === 2) {
        // Â¶ÇÊûúÁé©ÂÆ∂ÊòØ‰∏ªÊú∫‰∏îÂèó‰øùÊä§ÔºàÊó†ÊïåÔºâÔºåÂàôÂøΩÁï•Èô∑Èò±
        if (currentPlayer.isHost && gameState.multiplayer.protectedPlayers[currentPlayer.id]) {
            console.log('‰∏ªÊú∫Áé©ÂÆ∂Êó†ÊïåÔºåÊó†ËßÜÈô∑Èò±');
        } else {
            // ÊôÆÈÄöÁé©ÂÆ∂ÔºåÂõûÂà∞Ëµ∑ÁÇπ
            currentPlayer.x = 1;
            currentPlayer.y = 1;
            gameState.multiplayer.moveCount++;
            document.getElementById('multiplayerMoveCount').textContent = `ÁßªÂä®: ${gameState.multiplayer.moveCount}`;
            console.log('Ë∏©Âà∞Èô∑Èò±ÔºåÂõûÂà∞Ëµ∑ÁÇπÔºÅ');
            
            // „ÄêÂÖ≥ÈîÆ‰øÆÂ§ç 1„ÄëÂç≥‰ΩøÂõûÂà∞Ëµ∑ÁÇπÔºå‰πüÈúÄË¶ÅÂπøÊí≠ËøôÊ¨°ÁßªÂä®Ôºå‰ª•Êõ¥Êñ∞ÊâÄÊúâÁé©ÂÆ∂ÁöÑËßÜÂõæ
            if (currentPlayer.isHost) {
                // ‰∏ªÊú∫Áé©ÂÆ∂ÁßªÂä®ÂêéÔºåÈúÄË¶ÅÊõ¥Êñ∞ÊâÄÊúâÁé©ÂÆ∂ÁöÑËßÜÂõæ
                broadcast({
                    type: 'player-move',
                    playerId: currentPlayer.id,
                    x: currentPlayer.x,
                    y: currentPlayer.y
                });
            } else {
                // ÊôÆÈÄöÁé©ÂÆ∂Âè™ÈúÄË¶ÅÊõ¥Êñ∞Ëá™Â∑±ÁöÑËßÜÂõæ
                drawMultiplayerMaze();
                updatePlayerList();
            }
            return; // Èô∑Èò±Â§ÑÁêÜÁªìÊùüÔºå‰∏çÂÜçÊâßË°åÂêéÁª≠ÈÄªËæë
        }
    }
    
    // 4.3 ‰º†ÈÄÅÈó®
    if (cellValue === 3) {
        // ÊâæÂà∞‰º†ÈÄÅÈó®ÂØπË±°
        const teleporter = gameState.multiplayer.teleporters.find(t => t.x === newX && t.y === newY);
        if (teleporter) {
            // ÊâßË°å‰º†ÈÄÅ
            currentPlayer.x = teleporter.pairX;
            currentPlayer.y = teleporter.pairY;
            
            // „ÄêÂÖ≥ÈîÆ‰øÆÂ§ç 2„Äë‰º†ÈÄÅÊìç‰ΩúÂÆåÊàêÂêéÔºåÂøÖÈ°ªÂπøÊí≠Êñ∞‰ΩçÁΩÆ
            broadcast({
                type: 'player-teleport',
                playerId: currentPlayer.id,
                x: currentPlayer.x,
                y: currentPlayer.y
            });
            
            gameState.multiplayer.moveCount++;
            document.getElementById('multiplayerMoveCount').textContent = `ÁßªÂä®: ${gameState.multiplayer.moveCount}`;
            
            console.log('‰º†ÈÄÅ!');

            drawMultiplayerMaze();
            updatePlayerList();
            // ‰º†ÈÄÅÂêéÊ£ÄÊü•ÊòØÂê¶Âà∞ËææÂá∫Âè£
            checkPlayerAtExit(currentPlayer);
            return; // ‰º†ÈÄÅÈÄªËæëÁªìÊùü
        }
    }

    // 4.4 Èí•Âåô
    if (cellValue === 8) {
        // Ê£ÄÊü•Áé©ÂÆ∂ÊòØÂê¶Âèó‰øùÊä§ÔºåÈò≤Ê≠¢ÂÖ∂‰ªñÁé©ÂÆ∂ÂÅ∑Èí•Âåô
        if (gameState.multiplayer.protectedPlayers[currentPlayer.id]) {
            console.log('Áé©ÂÆ∂Âèó‰øùÊä§ÔºåÂÖ∂‰ªñÁé©ÂÆ∂Êó†Ê≥ïÊç°Èí•Âåô');
        } else {
            currentPlayer.hasKey = true;
            gameState.multiplayer.maze[newY][newX] = 0; // ÁßªÈô§Èí•Âåô
            delete gameState.multiplayer.keyPosition;

            // ÂπøÊí≠Èí•ÂåôÊãæÂèñ‰∫ã‰ª∂
            broadcast({
                type: 'key-pickup',
                playerId: currentPlayer.id
            });
            console.log('ÊãøÂà∞Èí•Âåô!');
        }
    }

    // 4.5 Èó®
    if (cellValue === 9) {
        if (currentPlayer.hasKey) {
            startMultiplayerUnlockDoor();
            return; // ÂºÄÈó®ÂÄíËÆ°Êó∂ÂºÄÂßãÔºåÊú¨Ê¨°ÁßªÂä®ÁªìÊùü
        } else {
            alert("‰Ω†ÈúÄË¶ÅÈí•ÂåôÊâçËÉΩÊâìÂºÄËøôÊâáÈó®ÔºÅ");
            return; // Ê≤°ÊúâÈí•ÂåôÔºåÂºÄÈó®Â§±Ë¥•ÔºåÊú¨Ê¨°ÁßªÂä®ÁªìÊùü
        }
    }

    // 5. ÊâßË°åÊ†áÂáÜÁßªÂä®
    // --------------------------------------------------
    // Â¶ÇÊûúÈÄöËøá‰∫ÜÊâÄÊúâÊ£ÄÊü•ÔºåËØ¥ÊòéÊòØÊúâÊïàÁöÑÊôÆÈÄöÁßªÂä®
    currentPlayer.x = newX;
    currentPlayer.y = newY;
    
    gameState.multiplayer.moveCount++;
    document.getElementById('multiplayerMoveCount').textContent = `ÁßªÂä®: ${gameState.multiplayer.moveCount}`;
    
    // ÂπøÊí≠ÁßªÂä®
    broadcast({
        type: 'player-move',
        playerId: currentPlayer.id,
        x: currentPlayer.x,
        y: currentPlayer.y
    });
    
    console.log('ÁßªÂä®!');

    // 6. ÁªòÂà∂UIÂíåÊ£ÄÊü•Âá∫Âè£
    drawMultiplayerMaze();
    updatePlayerList();
    
    // Ê£ÄÊü•ÊòØÂê¶Âà∞ËææÂá∫Âè£
    checkPlayerAtExit(currentPlayer);
}

/**
 * Ê£ÄÊü•ÁâπÂÆöÁé©ÂÆ∂ÊòØÂê¶Âà∞Ëææ‰∫ÜÂá∫Âè£ÔºåÂπ∂Ëß¶ÂèëÁõ∏Â∫îÈÄªËæë„ÄÇ
 * @param {object} player - Ë¶ÅÊ£ÄÊü•ÁöÑÁé©ÂÆ∂ÂØπË±°
 */
function checkPlayerAtExit(player) {
    const exit = gameState.multiplayer.exit;
    if (player.x === exit.x && player.y === exit.y) {
        // Áé©ÂÆ∂Âà∞ËææÂá∫Âè£
        player.reachedExit = true;
        console.log(`${player.name} Âà∞Ëææ‰∫ÜÂá∫Âè£ÔºÅ`);

        // ÂπøÊí≠Âà∞ËææÂá∫Âè£‰∫ã‰ª∂
        broadcast({
            type: 'player-reached-exit',
            playerId: player.id
        });

        // Ê£ÄÊü•ÊòØÂê¶ÊâÄÊúâ‰∫∫ÈÉΩÂà∞‰∫Ü
        checkAllPlayersReachedExit();
    }
}

function initMultiplayerCanvas() {
    const canvas = document.getElementById('multiplayerCanvas');
    if (!canvas) {
        console.error('Â§ö‰∫∫Ê∏∏ÊàèÁîªÂ∏ÉÊú™ÊâæÂà∞');
        return;
    }
    
    const ctx = canvas.getContext('2d');
    
    // Ë∞ÉÊï¥ÁîªÂ∏ÉÂ§ßÂ∞è
    const maxWidth = window.innerWidth - 40;
    const maxHeight = window.innerHeight - 180;
    
    // Á°Æ‰øùËø∑ÂÆ´Â∑≤ÂàùÂßãÂåñ
    if (!gameState.multiplayer.maze || gameState.multiplayer.maze.length === 0) {
        console.error("Â§ö‰∫∫Ê∏∏ÊàèËø∑ÂÆ´Êú™ÂàùÂßãÂåñ");
        canvas.width = 300;
        canvas.height = 300;
        return;
    }
    
    const mazeWidth = gameState.multiplayer.maze[0].length;
    const mazeHeight = gameState.multiplayer.maze.length;
    
    const cellSize = Math.min(30, Math.floor(maxWidth / mazeWidth), 
                             Math.floor(maxHeight / mazeHeight));
    
    canvas.width = mazeWidth * cellSize;
    canvas.height = mazeHeight * cellSize;
    
    // ‰øùÂ≠òÂçïÂÖÉÊ†ºÂ§ßÂ∞è‰æõÂêéÁª≠‰ΩøÁî®
    gameState.multiplayer.cellSize = cellSize;
    
    // ÁªòÂà∂ÂàùÂßãËø∑ÂÆ´
    drawMultiplayerMaze();
    
    // Êõ¥Êñ∞Áé©ÂÆ∂ÂàóË°®
    updatePlayerList();
    
    // Ê∑ªÂä†ÈîÆÁõò‰∫ã‰ª∂ÁõëÂê¨
    window.addEventListener('keydown', handleMultiplayerKeyDown);
}

        function handleMultiplayerKeyDown(e) {
            if (!gameState.multiplayer.connected) return;
            
            e.preventDefault();
            const player = gameState.multiplayer.players[gameState.multiplayer.currentPlayerId];
            if (!player || player.reachedExit) return;
            
            let newX = player.x;
            let newY = player.y;
            
            switch(e.key) {
                case 'ArrowUp': newY--; break;
                case 'ArrowDown': newY++; break;
                case 'ArrowLeft': newX--; break;
                case 'ArrowRight': newX++; break;
                default: return;
            }
            
            // Ê£ÄÊü•ÁßªÂä®ÊòØÂê¶ÊúâÊïà
            if (newX >= 0 && newX < gameState.multiplayer.maze[0].length && 
                newY >= 0 && newY < gameState.multiplayer.maze.length) {
                
                const cellValue = gameState.multiplayer.maze[newY][newX];
                
                // Ê£ÄÊü•ÊòØÂê¶ÊòØÂ¢ô
                if (cellValue === 1) return;
                
                // Ê£ÄÊü•ÊòØÂê¶ÊòØÈô∑Èò±
                if (cellValue === 2) {
                    // Ê£ÄÊü•Áé©ÂÆ∂ÊòØÂê¶Âèó‰øùÊä§ÔºàÊó†ÊïåÁä∂ÊÄÅÔºâ
                    if (gameState.multiplayer.protectedPlayers[gameState.multiplayer.currentPlayerId]) {
                        // Êó†ÊïåÁä∂ÊÄÅÔºåÂøΩÁï•Èô∑Èò±
                        console.log('Êó†ÊïåÁä∂ÊÄÅÔºåÂøΩÁï•Èô∑Èò±');
                    } else {
                        // ÂõûÂà∞Ëµ∑ÁÇπ
                        player.x = 1;
                        player.y = 1;
                        gameState.multiplayer.moveCount++;
                        document.getElementById('multiplayerMoveCount').textContent = 
                            `ÁßªÂä®: ${gameState.multiplayer.moveCount}`;
                        
                        // ÂπøÊí≠ÁßªÂä®
                        broadcast({
                            type: 'player-move',
                            playerId: gameState.multiplayer.currentPlayerId,
                            x: player.x,
                            y: player.y
                        });
                        
                        drawMultiplayerMaze();
                        
                    }
                }
                
                // Ê£ÄÊü•ÊòØÂê¶ÊòØ‰º†ÈÄÅÈó®
                if (cellValue === 3) {
                    // ÊâæÂà∞ÈÖçÂØπÁöÑ‰º†ÈÄÅÈó®
                    const teleporter = gameState.multiplayer.teleporters.find(t => 
                        t.x === newX && t.y === newY);
                    
                    if (teleporter) {
                        // Â¶ÇÊûúÊòØ‰∏ªÊú∫ÔºåÁõ¥Êé•Â§ÑÁêÜ‰º†ÈÄÅ
                        if (gameState.multiplayer.isHost) {
                            newX = teleporter.pairX;
                            newY = teleporter.pairY;
                            
                            player.x = newX;
                            player.y = newY;
                            
                            // ÂπøÊí≠‰º†ÈÄÅ
                            broadcast({
                                type: 'player-teleport',
                                playerId: gameState.multiplayer.currentPlayerId,
                                x: newX,
                                y: newY
                            });
                            drawMultiplayerMaze();
                        } else {
                            // Â¶ÇÊûúÊòØÂÆ¢Êà∑Á´ØÔºåÂêë‰∏ªÊú∫ÂèëÈÄÅ‰º†ÈÄÅËØ∑Ê±Ç
                            const conn = Object.values(gameState.multiplayer.connections)[0];
                            if (conn) {
                                conn.send({
                                    type: 'teleport-request',
                                    playerId: gameState.multiplayer.currentPlayerId,
                                    teleporterX: newX,
                                    teleporterY: newY
                                });
                            }
                            return; // Á≠âÂæÖ‰∏ªÊú∫Â§ÑÁêÜ
                            drawMultiplayerMaze();
                        }
                    }
                } else {
                    // ÊôÆÈÄöÁßªÂä®
                    player.x = newX;
                    player.y = newY;
                }
                
                gameState.multiplayer.moveCount++;
                document.getElementById('multiplayerMoveCount').textContent = 
                    `ÁßªÂä®: ${gameState.multiplayer.moveCount}`;
                
                // ÂπøÊí≠ÁßªÂä®
                broadcast({
                    type: 'player-move',
                    playerId: gameState.multiplayer.currentPlayerId,
                    x: player.x,
                    y: player.y
                });
                drawMultiplayerMaze();
                // Ê£ÄÊü•ÊòØÂê¶Âà∞ËææÂá∫Âè£
                if (player.x === gameState.multiplayer.exit.x && player.y === gameState.multiplayer.exit.y) {
                    player.reachedExit = true;
                    
                    // ÂπøÊí≠Âà∞ËææÂá∫Âè£
                    broadcast({
                        type: 'player-reached-exit',
                        playerId: gameState.multiplayer.currentPlayerId
                    });
                    
                    // Ê£ÄÊü•ÊòØÂê¶ÊâÄÊúâÁé©ÂÆ∂ÈÉΩÂà∞ËææÂá∫Âè£
                    checkAllPlayersReachedExit();
                }
                drawMultiplayerMaze();
                if (cellValue === 8) {
                    gameState.multiplayer.hasKey = true;
                    // ÁßªÈô§Èí•Âåô
                    gameState.multiplayer.maze[newY][newX] = 0;
                    delete gameState.multiplayer.keyPosition;
                    
                    // ÂπøÊí≠Èí•ÂåôÊãæÂèñ
                    broadcast({
                        type: 'key-pickup',
                        playerId: gameState.multiplayer.currentPlayerId
                    });
                }
                
                // Ê£ÄÊü•ÊòØÂê¶ÊòØÈó®
                if (cellValue === 9) {
                        if (gameState.multiplayer.hasKey) {
                            // ÂºÄÂßãÂºÄÈó®ÂÄíËÆ°Êó∂
                            startMultiplayerUnlockDoor();
                            
                        } else {
                            // Ê≤°ÊúâÈí•ÂåôÔºå‰∏çËÉΩÈÄöËøá
                            alert("‰Ω†ÈúÄË¶ÅÈí•ÂåôÊâçËÉΩÊâìÂºÄËøôÊâáÈó®ÔºÅ");
                            
                        }
                drawMultiplayerMaze();
                updatePlayerList();
            }
        }
    }
function startUnlockDoor() {
    // Ê∏ÖÈô§ÂèØËÉΩÂ≠òÂú®ÁöÑÊóßÂÆöÊó∂Âô®
    clearInterval(singlePlayerGame.unlockTimer);
    
    singlePlayerGame.isUnlocking = true;
    singlePlayerGame.unlockTimeLeft = 10;
    document.getElementById('unlockTimer').classList.remove('hidden');
    updateUnlockTimer();
    
    singlePlayerGame.unlockTimer = setInterval(() => {
        singlePlayerGame.unlockTimeLeft--;
        updateUnlockTimer();
        
        if (singlePlayerGame.unlockTimeLeft <= 0) {
            clearInterval(singlePlayerGame.unlockTimer);
            // ÂºÄÈó®ÊàêÂäü
            singlePlayerGame.maze[singlePlayerGame.doorPosition.y][singlePlayerGame.doorPosition.x] = 0;
            document.getElementById('unlockTimer').classList.add('hidden');
            singlePlayerGame.isUnlocking = false;
            
            drawSinglePlayerMaze();
            alert("Èó®Â∑≤ÊâìÂºÄÔºÅÁé∞Âú®‰Ω†ÂèØ‰ª•ËøõÂÖ•Âá∫Âè£‰∫Ü„ÄÇ");
        }
    }, 1000);
}


function startMultiplayerUnlockDoor() {
    // Ê∏ÖÈô§ÂèØËÉΩÂ≠òÂú®ÁöÑÊóßÂÆöÊó∂Âô®
    clearInterval(gameState.multiplayer.unlockTimer);
    
    gameState.multiplayer.isUnlocking = true;
    gameState.multiplayer.unlockTimeLeft = 10;
    document.getElementById('unlockTimer').classList.remove('hidden');
    updateMultiplayerUnlockTimer();
    
    gameState.multiplayer.unlockTimer = setInterval(() => {
        gameState.multiplayer.unlockTimeLeft--;
        updateMultiplayerUnlockTimer();
        
        if (gameState.multiplayer.unlockTimeLeft <= 0) {
            clearInterval(gameState.multiplayer.unlockTimer);
            // ÂºÄÈó®ÊàêÂäü
            gameState.multiplayer.maze[
                gameState.multiplayer.doorPosition.y][
                gameState.multiplayer.doorPosition.x] = 0;
            document.getElementById('unlockTimer').classList.add('hidden');
            gameState.multiplayer.isUnlocking = false;
            
            // Â¶ÇÊûúÊòØ‰∏ªÊú∫ÔºåÂπøÊí≠ÂºÄÈó®
            if (gameState.multiplayer.isHost) {
                broadcast({
                    type: 'door-open',
                    x: gameState.multiplayer.doorPosition.x,
                    y: gameState.multiplayer.doorPosition.y
                });
            }
            
            drawMultiplayerMaze();
            alert("Èó®Â∑≤ÊâìÂºÄÔºÅ");
        }
    }, 1000);
}

function updateUnlockTimer() {
    document.getElementById('unlockTimer').textContent = 
        `ÂºÄÈó®ÂÄíËÆ°Êó∂: ${singlePlayerGame.unlockTimeLeft}Áßí`;
}

function checkAllPlayersReachedExit() {
    const allReached = Object.values(gameState.multiplayer.players).every(p => p.reachedExit);
    if (allReached) {
        alert('ÊâÄÊúâÁé©ÂÆ∂ÈÉΩÂà∞Ëææ‰∫ÜÂá∫Âè£ÔºÅÊ∏∏ÊàèËÉúÂà©ÔºÅ');
        
        // ËÆ∞ÂΩïÂ§ö‰∫∫Ê∏∏ÊàèÊàêÂ∞±
        recordAchievement('multiplayerWin', 1);
    }
}

// ÂàùÂßãÂåñÂáΩÊï∞
function initializeNewFeatures() {
    updateAchievementProgress();
    
    // Êõ¥Êñ∞ÊåëÊàòÁïåÈù¢Êï∞ÊçÆ
    document.getElementById('timeChallengeBest').textContent = 
        gameState.gameStats.timeChallengeBest > 0 ? 
        gameState.gameStats.timeChallengeBest + 'Áßí' : 'ÊöÇÊó†';
    
    document.getElementById('puzzleCompleted').textContent = 
        gameState.gameStats.puzzleLevelsCompleted + '/10';
    
    
}
// Âú®È°µÈù¢Âä†ËΩΩÊó∂Ë∞ÉÁî®
window.addEventListener('load', initializeNewFeatures);

        function disconnectMultiplayer() {
            if (gameState.multiplayer.peer) {
                gameState.multiplayer.peer.destroy();
            }
            
            gameState.multiplayer.connected = false;
            gameState.multiplayer.connections = {};
            gameState.multiplayer.players = {};
            gameState.multiplayer.protectedPlayers = {};
            clearInterval(gameState.multiplayer.timerInterval);
            window.removeEventListener('keydown', handleMultiplayerKeyDown);
            showScreen('mainMenu');
        }

        function updateConnectionStatus(status) {
            const statusElement = document.getElementById('connectionStatus');
            
            switch(status) {
                case 'connecting':
                    statusElement.textContent = 'ËøûÊé•‰∏≠...';
                    statusElement.className = 'connection-status disconnected';
                    break;
                case 'connected':
                    statusElement.textContent = 'Â∑≤ËøûÊé• Â§ö‰∫∫ËÅîÊú∫ÊµãËØï';
                    statusElement.className = 'connection-status connected';
                    break;
                case 'disconnected':
                    statusElement.textContent = 'Êñ≠ÂºÄËøûÊé• Â§ö‰∫∫ËÅîÊú∫ÊµãËØï';
                    statusElement.className = 'connection-status disconnected';
                    break;
            }
        }

        function updatePlayerList() {
            const container = document.getElementById('playersContainer');
            container.innerHTML = '';
            
            for (const playerId in gameState.multiplayer.players) {
                const player = gameState.multiplayer.players[playerId];
                const div = document.createElement('div');
                div.className = 'player-item';
                
                const playerInfo = document.createElement('div');
                playerInfo.className = 'player-info';
                playerInfo.innerHTML = `
                    <div class="player-color" style="background-color:${player.color}"></div>
                    ${player.name} ${player.reachedExit ? '‚úì' : ''}
                    ${gameState.multiplayer.protectedPlayers[playerId] ? 'üõ°Ô∏è' : ''}
                `;
                
                div.appendChild(playerInfo);
                
                // Â¶ÇÊûúÊòØÊàø‰∏ª‰∏î‰∏çÊòØËá™Â∑±ÔºåÊòæÁ§∫Ë∏¢Âá∫ÊåâÈíÆ
                if (gameState.multiplayer.isHost && 
                    gameState.multiplayer.currentPlayerId !== playerId) {
                    const kickButton = document.createElement('button');
                    kickButton.className = 'kick-button';
                    kickButton.textContent = 'Ë∏¢Âá∫';
                    kickButton.onclick = () => {
                        if (confirm(`Á°ÆÂÆöË¶ÅË∏¢Âá∫Áé©ÂÆ∂ ${player.name} ÂêóÔºü`)) {
                            // Ê£ÄÊü•Áé©ÂÆ∂ÊòØÂê¶Âèó‰øùÊä§
                            if (gameState.multiplayer.protectedPlayers[playerId]) {
                                alert('Ë∏¢Âá∫Â§±Ë¥•Ôºöerr75937 (Áé©ÂÆ∂Âèó‰øùÊä§)');
                            } else {
                                kickPlayer(playerId, 'Ë¢´ÁÆ°ÁêÜÂëòË∏¢Âá∫');
                            }
                        }
                    };
                    div.appendChild(kickButton);
                }
                
                container.appendChild(div);
            }
            
            updatePlayerCount();
        }

        function updatePlayerCount() {
            const currentPlayers = Object.keys(gameState.multiplayer.players).length;
            const maxPlayers = gameState.multiplayer.maxPlayers;
            document.getElementById('multiplayerPlayerCount').textContent = 
                `Áé©ÂÆ∂: ${currentPlayers}/${maxPlayers}`;
        }

function kickPlayer(playerId, reason) {
    // Ê£ÄÊü•ÊòØÂê¶ÊòØÊàø‰∏ª‰∏î‰∏çÊòØÂº∫Âà∂Ë∏¢Âá∫
    const isHost = gameState.multiplayer.players[playerId]?.isHost;
    if (isHost && !reason.includes('(Âº∫Âà∂)')) {
        output.innerHTML += '\nÈîôËØØ: ‰∏çËÉΩË∏¢Âá∫Êàø‰∏ª(Èô§Èùû‰ΩøÁî®forceÂèÇÊï∞)';
        return;
    }
    
    // ÂèëÈÄÅË∏¢Âá∫Ê∂àÊÅØÁªôËØ•Áé©ÂÆ∂
    if (gameState.multiplayer.connections[playerId]) {
        gameState.multiplayer.connections[playerId].send({
            type: 'player-kicked',
            playerId: playerId,
            reason: reason
        });
        gameState.multiplayer.connections[playerId].close();
    }
    
    // ÂπøÊí≠ÁªôÂÖ∂‰ªñÁé©ÂÆ∂
    broadcast({
        type: 'player-kicked',
        playerId: playerId,
        reason: reason
    });
    
    // ‰ªéÂàóË°®‰∏≠ÁßªÈô§
    removePlayer(playerId);
}


        function resetMultiplayerPlayer() {
            const player = gameState.multiplayer.players[gameState.multiplayer.currentPlayerId];
            if (player) {
                player.x = 1;
                player.y = 1;
                player.reachedExit = false;
                
                // ÂπøÊí≠ÁßªÂä®
                broadcast({
                    type: 'player-move',
                    playerId: gameState.multiplayer.currentPlayerId,
                    x: player.x,
                    y: player.y
                });
                
                drawMultiplayerMaze();
                updatePlayerList();
            }
        }
function addKeyAndDoormultiplayer(size, maze) {
    // ÈöèÊú∫ÊîæÁΩÆÈí•Âåô
    let keyX, keyY;
    do {
        keyX = Math.floor(Math.random() * (size - 4)) + 2;
        keyY = Math.floor(Math.random() * (size - 4)) + 2;
    } while (maze[keyY][keyX] === 1 || 
             (keyX === 1 && keyY === size - 2) || 
             (keyX === Math.floor(size/2) && keyY === Math.floor(size/2)));
    
    // ÊîæÁΩÆÈí•Âåô(8)
    maze[keyY][keyX] = 8;
    gameState.multiplayer.keyPosition = {x: keyX, y: keyY};
    
    // Âú®Âá∫Âè£ÂâçÊîæÁΩÆÈó®(9)
    let doorX = gameState.multiplayer.exit.x;
    let doorY = gameState.multiplayer.exit.y;
    
    // Á°ÆÂÆöÈó®ÁöÑ‰ΩçÁΩÆ
    if (doorX < size-1 && maze[doorY][doorX+1] === 0) {
        doorX++;
    } else if (doorX > 0 && maze[doorY][doorX-1] === 0) {
        doorX--;
    } else if (doorY < size-1 && maze[doorY+1][doorX] === 0) {
        doorY++;
    } else if (doorY > 0 && maze[doorY-1][doorX] === 0) {
        doorY--;
    }
    
    maze[doorY][doorX] = 9;
    gameState.multiplayer.doorPosition = {x: doorX, y: doorY};
}

function generateMultiplayerMaze() {
    const size = 15;
    let maze;
    let validMaze = false;
    let attempts = 0;
    
    // 10%Ê¶ÇÁéáÁîüÊàêËû∫ÊóãËø∑ÂÆ´(Â∫îÊïå‰∫∫Êó†Ê≥ïÊ∏≤ÊüìÔºåÊöÇÊó∂ÂÖ≥Èó≠)
    const isSpiralMaze = false;
    // const isSpiralMaze = Math.random() < 0.1;
    // %100ÁîüÊàê
    // const isSpiralMaze = true;
    if (isSpiralMaze) {
        maze = generateSpiralMaze(size);
        gameState.multiplayer.exit = { 
            x: Math.floor(size/2), 
            y: Math.floor(size/2) 
        };
        
        // Ê∑ªÂä†ÁßªÂä®Êïå‰∫∫
        gameState.multiplayer.movingEnemies = [];
        for (let i = 0; i < 3; i++) {
            gameState.multiplayer.movingEnemies.push({
                x: Math.floor(Math.random() * (size-4)) + 2,
                y: Math.floor(Math.random() * (size-4)) + 2,
                dx: Math.random() > 0.5 ? 1 : -1,
                dy: Math.random() > 0.5 ? 1 : -1,
                speed: 0.3 + Math.random() * 0.4,
                color: `hsl(${Math.random() * 360}, 80%, 60%)`,
                lastMove: 0
            });
        }
        
        // Ê∑ªÂä†Èí•ÂåôÂíåÈó®
        addKeyAndDoormultiplayer(size, maze);
    } else {
        // ÊôÆÈÄöËø∑ÂÆ´
        while (!validMaze && attempts < 5) {
            maze = Array(size).fill().map(() => Array(size).fill(1));
            validMaze = tryGenerateValidMaze(maze, size);
            attempts++;
        }
        
        if (!validMaze) {
            maze = generateBackupMaze(size);
        }
        
        // ËÆæÁΩÆÂá∫Âè£
        maze[size-2][size-1] = 0;
        gameState.multiplayer.exit = {x: size-1, y: size-2};
    }
    
    // Ê∑ªÂä†‰º†ÈÄÅÈó®
    addMultiplayerTeleporters(maze, size);
    
    return maze;
}

function tryGenerateValidMaze(maze, size) {
    // ‰ΩøÁî®ÈöèÊú∫PrimÁÆóÊ≥ïÁîüÊàêËø∑ÂÆ´
    const walls = [];
    maze[1][1] = 0;
    walls.push(...getCellWalls(1, 1, maze));
    
    while (walls.length > 0) {
        const wallIndex = Math.floor(Math.random() * walls.length);
        const wall = walls[wallIndex];
        walls.splice(wallIndex, 1);
        
        const opposite = getOppositeCell(wall, maze);
        
        if (opposite.x > 0 && opposite.x < size-1 && 
            opposite.y > 0 && opposite.y < size-1 && 
            maze[opposite.y][opposite.x] === 1) {
            
            maze[wall.y][wall.x] = 0;
            maze[opposite.y][opposite.x] = 0;
            walls.push(...getCellWalls(opposite.x, opposite.y, maze));
        }
    }
    
    // Á°Æ‰øùÊúâ‰∏ÄÊù°‰ªéËµ∑ÁÇπ(1,1)Âà∞ÁªàÁÇπ(size-2, size-1)ÁöÑË∑ØÂæÑ
    return validateMaze(maze);
}

function addMultiplayerTraps(maze, size) {
    // Ê∑ªÂä†Èô∑Èò±ÔºàÈÅøÂºÄÂÖ≥ÈîÆË∑ØÂæÑÔºâ
    const criticalPath = findCriticalPath(maze);
    for (let i = 0; i < 5; i++) {
        let x, y;
        let attempts = 0;
        do {
            x = Math.floor(Math.random() * (size-2)) + 1;
            y = Math.floor(Math.random() * (size-2)) + 1;
            attempts++;
        } while ((maze[y][x] !== 0 || 
                  criticalPath.some(p => p.x === x && p.y === y) || 
                  (x === 1 && y === 1)) && attempts < 50);
        
        if (attempts < 50) {
            maze[y][x] = 2;
        }
    }
}

function addMultiplayerTeleporters(maze, size) {
    gameState.multiplayer.teleporters = [];
    for (let i = 0; i < 2; i++) {
        let x1, y1, x2, y2;
        let attempts = 0;
        do {
            x1 = Math.floor(Math.random() * (size-2)) + 1;
            y1 = Math.floor(Math.random() * (size-2)) + 1;
            x2 = Math.floor(Math.random() * (size-2)) + 1;
            y2 = Math.floor(Math.random() * (size-2)) + 1;
            attempts++;
        } while ((maze[y1][x1] !== 0 || maze[y2][x2] !== 0 || 
                 (x1 === 1 && y1 === 1) || (x2 === 1 && y2 === 1)) && attempts < 50);
        
        if (attempts < 50) {
            maze[y1][x1] = 3;
            maze[y2][x2] = 3;
            gameState.multiplayer.teleporters.push({x: x1, y: y1, pairX: x2, pairY: y2});
            gameState.multiplayer.teleporters.push({x: x2, y: y2, pairX: x1, pairY: y1});
        }
    }
}



function getOppositeCell(wall, maze) {
    const directions = [
        {dx: 1, dy: 0}, {dx: -1, dy: 0}, 
        {dx: 0, dy: 1}, {dx: 0, dy: -1}
    ];
    
    for (const dir of directions) {
        const nx = wall.x + dir.dx;
        const ny = wall.y + dir.dy;
        
        if (nx >= 0 && nx < maze[0].length && 
            ny >= 0 && ny < maze.length && 
            maze[ny][nx] === 0) {
            return {x: wall.x - dir.dx, y: wall.y - dir.dy};
        }
    }
    
    return {x: -1, y: -1};
}

            // ËæÖÂä©ÂáΩÊï∞
            function getCellWalls(x, y, maze) {
                const walls = [];
                const directions = [
                    {dx: 1, dy: 0}, {dx: -1, dy: 0}, 
                    {dx: 0, dy: 1}, {dx: 0, dy: -1}
                ];
                
                for (const dir of directions) {
                    const nx = x + dir.dx;
                    const ny = y + dir.dy;
                    
                    if (nx >= 0 && nx < maze[0].length && 
                        ny >= 0 && ny < maze.length && 
                        maze[ny][nx] === 1) {
                        walls.push({x: nx, y: ny});
                    }
                }
                
                return walls;
            }
            
            function getOppositeCell(wall, maze) {
                const directions = [
                    {dx: 1, dy: 0}, {dx: -1, dy: 0}, 
                    {dx: 0, dy: 1}, {dx: 0, dy: -1}
                ];
                
                for (const dir of directions) {
                    const nx = wall.x + dir.dx;
                    const ny = wall.y + dir.dy;
                    
                    if (nx >= 0 && nx < maze[0].length && 
                        ny >= 0 && ny < maze.length && 
                        maze[ny][nx] === 0) {
                        return {x: wall.x - dir.dx, y: wall.y - dir.dy};
                    }
                }
                
                return {x: -1, y: -1};
            }
        

        function drawMultiplayerMaze() {
            const canvas = document.getElementById('multiplayerCanvas');
            const ctx = canvas.getContext('2d');
            const cellSize = gameState.multiplayer.cellSize;
            
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // ÁªòÂà∂Ëø∑ÂÆ´
            for (let y = 0; y < gameState.multiplayer.maze.length; y++) {
                for (let x = 0; x < gameState.multiplayer.maze[y].length; x++) {
                    const cellValue = gameState.multiplayer.maze[y][x];
                    
                    switch(cellValue) {
                        case 1: // Â¢ô
                            ctx.fillStyle = '#333';
                            break;
                        case 2: // Èô∑Èò±
                            ctx.fillStyle = '#FF0';
                            break;
                        case 3: // ‰º†ÈÄÅÈó®
                            ctx.fillStyle = '#0FF';
                            break;
                        default: // Ë∑Ø
                            ctx.fillStyle = '#111';
                    }
                    
                    ctx.fillRect(x * cellSize, y * cellSize, cellSize, cellSize);
                    
                    // ÁªòÂà∂Èô∑Èò±ÂõæÊ°à
                    if (cellValue === 2) {
                        ctx.fillStyle = '#000';
                        ctx.beginPath();
                        ctx.arc(
                            x * cellSize + cellSize/2,
                            y * cellSize + cellSize/2,
                            cellSize/4,
                            0,
                            Math.PI * 2
                        );
                        ctx.fill();
                    }
                       if (gameState.multiplayer.keyPosition) {
                            ctx.fillStyle = 'gold';
                            ctx.fillRect(
                                gameState.multiplayer.keyPosition.x * cellSize,
                                gameState.multiplayer.keyPosition.y * cellSize,
                                cellSize, cellSize
                            );
                        }
                        
                        // ÁªòÂà∂Èó®
                        if (gameState.multiplayer.doorPosition) {
                            ctx.fillStyle = '#8B4513';
                            ctx.fillRect(
                                gameState.multiplayer.doorPosition.x * cellSize,
                                gameState.multiplayer.doorPosition.y * cellSize,
                                cellSize, cellSize
                            );
                        }
                        
                        // ÁªòÂà∂ÁßªÂä®Êïå‰∫∫ÔºàÂ¶ÇÊûúÊòØËû∫ÊóãËø∑ÂÆ´Ôºâ
                        if (gameState.multiplayer.movingEnemies) {
                            gameState.multiplayer.movingEnemies.forEach(enemy => {
                                ctx.fillStyle = enemy.color;
                                ctx.beginPath();
                                ctx.arc(
                                    enemy.x * cellSize + cellSize/2,
                                    enemy.y * cellSize + cellSize/2,
                                    cellSize/2 - 2,
                                    0,
                                    Math.PI * 2
                                );
                                ctx.fill();
                                
                                // ÁªòÂà∂Êïå‰∫∫ÁúºÁùõ
                                ctx.fillStyle = '#FFF';
                                ctx.beginPath();
                                ctx.arc(
                                    enemy.x * cellSize + cellSize/3,
                                    enemy.y * cellSize + cellSize/3,
                                    cellSize/8,
                                    0,
                                    Math.PI * 2
                                );
                                ctx.fill();
                            });
                        }
                }
            
                
            
            
            // ÁªòÂà∂Âá∫Âè£
            ctx.fillStyle = '#F00';
            ctx.fillRect(gameState.multiplayer.exit.x * cellSize, 
                        gameState.multiplayer.exit.y * cellSize, 
                        cellSize, cellSize);
            ctx.fillStyle = '#FFF';
            ctx.font = 'bold ' + (cellSize/2) + 'px Arial';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText('Âá∫', 
                gameState.multiplayer.exit.x * cellSize + cellSize/2,
                gameState.multiplayer.exit.y * cellSize + cellSize/2
            );
            
            // ÁªòÂà∂ÊâÄÊúâÁé©ÂÆ∂
            for (const playerId in gameState.multiplayer.players) {
                const player = gameState.multiplayer.players[playerId];
                
                ctx.fillStyle = player.color;
                ctx.beginPath();
                ctx.arc(
                    player.x * cellSize + cellSize/2,
                    player.y * cellSize + cellSize/2,
                    cellSize/2 - 2,
                    0,
                    Math.PI * 2
                );
                ctx.fill();
                
                // ÁªòÂà∂Áé©ÂÆ∂ÂêçÂ≠ó
                ctx.fillStyle = '#FFF';
                ctx.font = 'bold ' + (cellSize/4) + 'px Arial';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(player.name.charAt(0), 
                    player.x * cellSize + cellSize/2,
                    player.y * cellSize + cellSize/2
                );
            }
        }
    }
function updateMultiplayerGame() {
    // ÁßªÂä®Êïå‰∫∫
    const now = Date.now();
    const size = gameState.multiplayer.maze.length; // Ëé∑ÂèñËø∑ÂÆ´Â§ßÂ∞è
    
    if (gameState.multiplayer.movingEnemies) {
        gameState.multiplayer.movingEnemies.forEach(enemy => {
            // Ê†πÊçÆÊó∂Èó¥Èó¥ÈöîÁßªÂä®
            if (now - enemy.lastMove < 500 / enemy.speed) return;
            enemy.lastMove = now;
            
            // ËøΩÈÄêÊúÄËøëÁöÑÁé©ÂÆ∂
            let closestPlayer = null;
            let minDistance = Infinity;
            
            for (const playerId in gameState.multiplayer.players) {
                const player = gameState.multiplayer.players[playerId];
                const distance = Math.sqrt(
                    Math.pow(player.x - enemy.x, 2) + 
                    Math.pow(player.y - enemy.y, 2)
                );
                
                if (distance < minDistance) {
                    minDistance = distance;
                    closestPlayer = player;
                }
            }
            
            if (closestPlayer) {
                // ËÆ°ÁÆóÁßªÂä®ÊñπÂêë
                enemy.dx = closestPlayer.x - enemy.x > 0 ? 1 : -1;
                enemy.dy = closestPlayer.y - enemy.y > 0 ? 1 : -1;
                
                // Â∞ùËØïÁßªÂä®
                let newX = enemy.x + enemy.dx;
                let newY = enemy.y + enemy.dy;
                
                // Ê£ÄÊü•ÊòØÂê¶ÂèØ‰ª•ÁßªÂä®
                if (newX >= 0 && newX < size && newY >= 0 && newY < size && 
                    gameState.multiplayer.maze[newY][newX] !== 1) {
                    enemy.x = newX;
                    enemy.y = newY;
                    
                    // Ê£ÄÊü•ÊòØÂê¶Á¢∞Âà∞Áé©ÂÆ∂
                    for (const playerId in gameState.multiplayer.players) {
                        const player = gameState.multiplayer.players[playerId];
                        
                        if (enemy.x === player.x && enemy.y === player.y && 
                            !gameState.multiplayer.protectedPlayers[playerId]) {
                            // Áé©ÂÆ∂Ë¢´ÈÄÅÂõûËµ∑ÁÇπ
                            player.x = 1;
                            player.y = 1;
                            
                            // ÂπøÊí≠ÁßªÂä®
                            broadcast({
                                type: 'player-move',
                                playerId: playerId,
                                x: player.x,
                                y: player.y
                            });
                        }
                    }
                }
            }
        });
        
        // ÂπøÊí≠Êïå‰∫∫ÁßªÂä®
        broadcast({
            type: 'enemy-move',
            enemies: gameState.multiplayer.movingEnemies
        });
        
        drawMultiplayerMaze();
    }
}

        function updateMultiplayerUnlockTimer() {
            document.getElementById('unlockTimer').textContent = 
                `ÂºÄÈó®ÂÄíËÆ°Êó∂: ${gameState.multiplayer.unlockTimeLeft}Áßí`;
        }

        function startMultiplayerTimer() {
            clearInterval(gameState.multiplayer.timerInterval);
            gameState.multiplayer.startTime = Date.now();
            updateMultiplayerUnlockTimer();
            gameState.multiplayer.timerInterval = setInterval(updateMultiplayerUnlockTimer, 1000);
        }



        function getRandomColor() {
            const colors = ['#FF6B6B', '#4ECDC4', '#45B7D1', '#96CEB4', '#FFEAA7', '#DDA0DD', '#98D8C8', '#F7DC6F'];
            return colors[Math.floor(Math.random() * colors.length)];
        }




        // =============== ÈîÆÁõòÂø´Êç∑ÈîÆ ===============
        document.addEventListener('keydown', function(e) {
            // Ctrl+Shift+C ÊâìÂºÄ/ÂÖ≥Èó≠ÊéßÂà∂Âè∞
            if (e.ctrlKey && e.shiftKey && e.key === 'C') {
                e.preventDefault();
                toggleConsole();
            }
            
            // Ctrl+Shift+D ÂàáÊç¢ÂºÄÂèëËÄÖÊ®°Âºè
            if (e.ctrlKey && e.shiftKey && e.key === 'D') {
                e.preventDefault();
                gameState.devMode = !gameState.devMode;
                console.log('ÂºÄÂèëËÄÖÊ®°Âºè:', gameState.devMode ? 'ÂºÄÂêØ' : 'ÂÖ≥Èó≠');
                
                // ÊòæÁ§∫ÊèêÁ§∫
                const hint = document.createElement('div');
                hint.className = 'console-hint';
                hint.textContent = `ÂºÄÂèëËÄÖÊ®°Âºè ${gameState.devMode ? 'ÂºÄÂêØ' : 'ÂÖ≥Èó≠'}`;
                document.body.appendChild(hint);
                
                setTimeout(() => {
                    hint.classList.add('hidden');
                    setTimeout(() => hint.remove(), 500);
                }, 2000);
            }
            
            // ÊéßÂà∂Âè∞ËæìÂÖ•Â§ÑÁêÜ
            if (consoleVisible && e.key === 'Enter') {
                const input = document.getElementById('consoleInput');
                const command = input.value.trim();
                input.value = '';
                    
                if (command) {
                    consoleHistory.push(command);
                    historyIndex = consoleHistory.length;
                    executeCommand(command);
                }
            }
        });

        // ÊéßÂà∂Âè∞ËæìÂÖ•Ê°Ü‰∫ã‰ª∂Â§ÑÁêÜ
        document.getElementById('consoleInput').addEventListener('keydown', handleConsoleInput);

        // ÂàùÂßãÂåñÂÖ≥Âç°ÊåâÈíÆ
        generateLevelButtons();
        
        // Êõ¥Êñ∞‰∏ã‰∏ÄÂÖ≥ÊåâÈíÆÊòæÁ§∫
function updateNextLevelButtons() {
    const regularBtn = document.getElementById('regularNextButton');
    const unsolvableBtn = document.getElementById('unsolvableNextButton');
    
    // Á°Æ‰øùÂú®‰ªª‰ΩïÊó∂ÂÄôË∞ÉÁî®Ëøô‰∏™ÂáΩÊï∞ÈÉΩËÉΩÊ≠£Á°ÆËÆæÁΩÆÊåâÈíÆÁä∂ÊÄÅ
    if (gameState.unsolvableLevels.includes(gameState.currentLevel)) {
        regularBtn.style.display = 'none';
        unsolvableBtn.style.display = 'block'; // Êîπ‰∏∫block‰ª•Á°Æ‰øùÊòæÁ§∫
    } else {
        regularBtn.style.display = 'block'; // Êîπ‰∏∫block‰ª•Á°Æ‰øùÊòæÁ§∫
        unsolvableBtn.style.display = 'none';
    }
}

        // ÂàùÂßãÂ∫îÁî®UIËÆæÁΩÆ
        applyUISettings();
document.addEventListener('touchstart', function(e) {
    // Ê£ÄÊü•ÁÇπÂáªÁöÑÊòØÂê¶ÊòØÁõÆÊ†áÊåâÈíÆ
    if (e.target.id === 'multiplayerBtn' || e.target.parentElement.id === 'multiplayerBtn') {
        e.preventDefault();
        showScreen('multiplayerSetup');
    }
    
    if (e.target.id === 'startMultiplayerBtn' || e.target.parentElement.id === 'startMultiplayerBtn') {
        e.preventDefault();
        connectToMultiplayerGame();
    }
    
    if (e.target.id === 'backToMenuBtn' || e.target.parentElement.id === 'backToMenuBtn') {
        e.preventDefault();
        showScreen('mainMenu');
    }
}, { passive: false });


    </script>
</body>
</html>
